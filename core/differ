diff -b -w -d ./anarace.cpp /home/claw/work/sc1064/sc/core/anarace.cpp
14,66d13
< STATISTICS::STATISTICS():
< 	needSupply(0),
< 	haveSupply(0),
< 	minerals(0),
< 	gas(0),
< 	fitness(0)
< { }
< 
< STATISTICS::~STATISTICS() {}
< 
< void STATISTICS::resetData()
< {
< 	needSupply=0;
< 	haveSupply=0;
< 	minerals=0;
< 	gas=0;
< 	fitness=0;
< }
< 
< PROGRAM::PROGRAM():
< 	built(false),
< 	time(0),
< 	location(0),
< 	successType(0),
< 	successUnit(0),
< 	facility(0),
< 	BT(0)
< {
< 	for(int i=UNIT_TYPE_COUNT;i--;)
< 	{
< 		forceCount[i]=0;
< 		availibleCount[i]=0;
< 	}
< }
< 
< PROGRAM::~PROGRAM() {}
< 
< void PROGRAM::resetData()
< {
< 	built=false;
< 	time=0;
< 	location=0;
< 	successType=0;
< 	successUnit=0;
< 	facility=0;
< 	BT=0;
< 		for(int i=UNIT_TYPE_COUNT;i--;)
< 		{
< 				forceCount[i]=0;
< 				availibleCount[i]=0;
< 		}
< }
< 
69d15
< 	PRERACE::resetStaticPrerace();
76a23,27
> 	fitnessAverage(0),
> 	fitnessVariance(0),
> 	positiveCrossover(0),
> 	wayneCrossover(0),
> 	negativeCrossover(0),
91,99c42
< 	averageLength(0),
< 	fitnessAverage(0),
< 	fitnessVariance(0),
< 	positiveCrossover(0),
< 	wayneCrossover(0),
< 	negativeCrossover(0)
< {
< 	
< 	for(int i = MAX_LENGTH;i--;)
---
> 	averageLength(0)
101,105c44
< 		phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
< 		ipStatistics[i].resetData();
< 		ipStatistics[i+1].resetData();
< 		program[i].resetData();
< 	}
---
> 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
133,139c72
< 		for(int i = MAX_LENGTH;i--;)
< 		{
< 				phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
< 				ipStatistics[i].resetData();
< 				ipStatistics[i+1].resetData();
< 				program[i].resetData();
< 		}
---
> 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
148a82,86
> 	fitnessAverage( object.fitnessAverage ),
> 	fitnessVariance( object.fitnessVariance ),
> 	positiveCrossover( object.positiveCrossover ),
> 	wayneCrossover( object.wayneCrossover ), 
> 	negativeCrossover( object.negativeCrossover ),
163,170c101
< 	averageLength( object.averageLength ),
< 	fitnessAverage( object.fitnessAverage ),
< 	fitnessVariance( object.fitnessVariance ),
< 	positiveCrossover( object.positiveCrossover ),
< 	wayneCrossover( object.wayneCrossover ), 
< 	negativeCrossover( object.negativeCrossover )
< {
< 	for(int i = MAX_LENGTH;i--;)
---
> 	averageLength( object.averageLength )
172,177c103,104
< 		phaenoCode[i] = object.phaenoCode[i];
< 		program[i] = object.program[i];
< 		ipStatistics[i] = object.ipStatistics[i];
< 	}	
< 	for(int i = MAX_TIME;i--;)
< 		timeStatistics[i] = object.timeStatistics[i];
---
> 	memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
> 	memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
182a110,114
> 	fitnessAverage = object.fitnessAverage;
> 	fitnessVariance = object.fitnessVariance;
> 	positiveCrossover = object.positiveCrossover;
> 	wayneCrossover = object.wayneCrossover;
> 	negativeCrossover = object.negativeCrossover;
198,210c130,131
< 	fitnessAverage = object.fitnessAverage;
< 	fitnessVariance = object.fitnessVariance;
< 	positiveCrossover = object.positiveCrossover;
< 	wayneCrossover = object.wayneCrossover;
< 	negativeCrossover = object.negativeCrossover;
< 	for(int i = MAX_LENGTH;i--;)
< 	{
< 		phaenoCode[i] = object.phaenoCode[i];
< 		program[i] = object.program[i];
< 		ipStatistics[i] = object.ipStatistics[i];
< 	}
< 	for(int i = MAX_TIME;i--;)
< 		timeStatistics[i] = object.timeStatistics[i];
---
>         memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
>         memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
223d143
< 	setMaxtFitness(MAX_TFITNESS);
241,257c161,162
< 	for(int i=2*MAX_LENGTH;i--;)
< 	{
< 		setIPStatisticsHaveSupply(i, 0);
< 		setIPStatisticsHaveMinerals(i, 0);
< 		setIPStatisticsHaveGas(i, 0);
< 		setIPStatisticsNeedSupply(i, 0);
< 		setIPStatisticsFitness(i, 0);
< 	}
< 	
< 	for(int i=MAX_TIME;i--;)
< 	{
< 		setTimeStatisticsHaveSupply(i, 0);
< 		setTimeStatisticsHaveMinerals(i, 0);
< 		setTimeStatisticsHaveGas(i, 0);
< 		setTimeStatisticsNeedSupply(i, 0);
< 		setTimeStatisticsFitness(i, 0);
< 	}
---
> 	memset(timeStatistics, 0, MAX_LENGTH * sizeof(STATISTICS));
> 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));
259,276c164,166
< 	for(int i=MAX_LENGTH;i--;)//ANA~
< 	{
< 		setProgramSuccessType(i, 0);
< 		setProgramSuccessUnit(i, 0);
< 		setProgramIsBuilt(i, false);
< 		setProgramTime(i, 0);
< 		for(int j=UNIT_TYPE_COUNT;j--;)
< 		{
< 			setProgramAvailibleCount(i, j, 0);
< 			setProgramTotalCount(i, j, 0);
< 		}
< 		//program[i].temp=0;
< 		setProgramLocation(i,0);
< //		setProgramIsGoal(i,false);
< 		setProgramFacility(i,0);
< 		setProgramBT(i,0);
< 		phaenoCode[i]=0;
< 	}
---
> 	std::list<PROGRAM>::iterator i = programList.begin();
> 	while(i!=programList.end())
> 		i = programList.erase(i);	
310,315c200,204
< 		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
< 		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
< 		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
< 		setTimeStatisticsHaveGas(getTimer(), getGas());
< 		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
< 
---
> //		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
> //		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
> //		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
> //		setTimeStatisticsHaveGas(getTimer(), getGas());
> //		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
319d207
< 
325a214,236
> 		unsigned int code = getpGoal()->toPhaeno(getCurrentCode());
> 		if((code >= BUILD_PARALLEL_2) && (code <= BUILD_PARALLEL_16))
>                 {
>                         setIP(getIP()-1);
>                         while((getpGoal()->toPhaeno(getCurrentCode()) > GAS_SCV)&&(getIP()))
>                                 setIP(getIP()-1);
>                         PARALLEL_COMMAND* pcommand = new PARALLEL_COMMAND;
>                         switch(code)
>                         {
>                                 case BUILD_PARALLEL_2:pcommand->count = 2;break;
>                                 case BUILD_PARALLEL_4:pcommand->count = 4;break;
>                                 case BUILD_PARALLEL_8:pcommand->count = 8;break;
>                                 case BUILD_PARALLEL_16:pcommand->count = 16;break;
>                                 default:break; // ~~
>                         }
>                         pcommand->unit = getpGoal()->toPhaeno(getCurrentCode());
> 			
>                         if(getIP()) 
> 				setIP(getIP()-1);
>                         parallelCommandQueues.push_back(pcommand);
>                         ok = true;
>                 } else
> 		{
329,333d239
< 		setIPStatisticsNeedSupply(getIP()*2+1, getNeedSupply());
< 		setIPStatisticsHaveSupply(getIP()*2+1, getHaveSupply());
< 		setIPStatisticsHaveMinerals(getIP()*2+1, getMinerals());
< 		setIPStatisticsHaveGas(getIP()*2+1, getGas());
< 		setIPStatisticsFitness(getIP()*2+1, calculatePrimaryFitness(ready));
337,348d242
< 		setIPStatisticsNeedSupply(getIP()*2, getNeedSupply());
< 		setIPStatisticsHaveSupply(getIP()*2, getHaveSupply());
< 		setIPStatisticsHaveMinerals(getIP()*2, getMinerals());
< 		setIPStatisticsHaveGas(getIP()*2, getGas());
< 		setIPStatisticsFitness(getIP()*2, calculatePrimaryFitness(ready));
< 	
< 		if(successType>0)
< 		{
< 			setProgramSuccessType(getIP(), successType);
< 			setProgramSuccessUnit(getIP(), successUnit);
< 		}
< 		
352,365c246,247
< 		if((ok)||(!getTimeOut())) {
< 			if(ok) {
< 				setProgramTime(getIP(), getTimer());
< 			} else {
< 				setProgramTime(getIP(),configuration.getMaxTime());
< 				setProgramSuccessType(getIP(), TIMEOUT_ERROR);
< 				setProgramSuccessUnit(getIP(), 0);
< //				setProgramSuccessLocation(0);
< 			}
< 			for(int i=UNIT_TYPE_COUNT;i--;)	{
< 				setProgramTotalCount(getIP(), i, getLocationTotal(GLOBAL, i));
< 				setProgramAvailibleCount(getIP(),i,getLocationAvailible(GLOBAL, i));
< 			}
< 	
---
> 			if((ok) || (!getTimeOut())) 
> 			{
368a251,266
>                 	else if(!ok)
> 	                {
> // TEST FOR PARALLEL COMMANDQUEUES
>         	                std::list<PARALLEL_COMMAND*>::iterator command = parallelCommandQueues.begin(); 
>                 	        while(command != parallelCommandQueues.end())
>                         	{
>                                 	ok = buildGene((*command)->unit);
> 	                                if(ok)  
>         	                        {
>                 	                        (*command)->count--;
>                         	                if(!(*command)->count)
>                                 	                command = parallelCommandQueues.erase(command);
>                 	                } else command++;
> 		               	}
>                 	}
> 		}
372c270
< 	int t=calculateIdleTime();
---
> 	unsigned int t = calculateIdleTime();
376c274,281
< 	for(int i=0;i<t;i++)
---
> //	if(t>0)
> //	{
> //		setProgramSuccessType(getIP(), TIMEOUT_ERROR);
> //		setProgramSuccessUnit(getIP(), 0); TODO
> //		setProgramSuccessLocation(0);
> //	}
> 
> 	for(unsigned int i = t; i--;)
378,382c283,287
<  		setTimeStatisticsNeedSupply(getTimer()-i, getNeedSupply());
< 		setTimeStatisticsHaveSupply(getTimer()-i, getHaveSupply());
< 		setTimeStatisticsHaveMinerals(getTimer()-i, getMinerals()+harvestMinerals()*i);
< 		setTimeStatisticsHaveGas(getTimer()-i, getGas()+harvestGas()*i);
< 		setTimeStatisticsFitness(getTimer()-i, calculatePrimaryFitness(ready)); // ~~
---
>  		timeStatistics[getTimer()-i].setNeedSupply(getNeedSupply());
> 		timeStatistics[getTimer()-i].setHaveSupply(getHaveSupply());
> 		timeStatistics[getTimer()-i].setHaveMinerals(getMinerals()+harvestMinerals()*i);
> 		timeStatistics[getTimer()-i].setHaveGas(getGas()+harvestGas()*i);
> 		timeStatistics[getTimer()-i].setFitness(calculatePrimaryFitness(ready)); // ~~
408c313
< 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2);			
---
> 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2, build.getUnitCount());
457,460c362,365
< 			setProgramFacility(build.getIP(), build.getFacility());
< 			setProgramIsBuilt(build.getIP(),true);
< 			setProgramLocation(build.getIP(),build.getLocation());
< 			setProgramBT(build.getIP(),build.getTotalBuildTime()); //~~~
---
> //			setProgramFacility(build.getIP(), build.getFacility());
> //			setProgramIsBuilt(build.getIP(), true);
> //			setProgramLocation(build.getIP(), build.getLocation());
> //			setProgramBT(build.getIP(), build.getTotalBuildTime()); //~~~
666a572,588
> const bool ANARACE::buildIt(const unsigned int build_unit)
> {
> 	//Zuerst: availible pruefen ob am Ort gebaut werden kann
> 	//Wenn nicht => +/- absteigen bis alle locations durch sind
> 
> 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> 	bool ok = false;
> 	unsigned int picked_facility = 0;
> 	unsigned int current_location_window = 1; // TODO
> //	unsigned int ttloc=0;
> //	unsigned int j=0;
> 
> /*	if(lastcounter>0)
> 	{	
> 		lastcounter--;
> 		tloc=last[lastcounter].location;
> 	}*/
667a590,732
> 	if(stat->facility[0]==0)
> 		ok=true;
> 	else
> 	// special rule for morphing units of protoss
> 	if((stat->facility2>0) && ((stat->facilityType == IS_LOST) || (stat->facilityType == IS_MORPHING)) && (stat->facility[0] == stat->facility2))
> 	{
> 		if(getLocationAvailible(current_location_window, stat->facility2) >=2)
> 		{
> 			ok = true;
> 			picked_facility = 0;
> 		}
> 	} else
> 	{
> 		// research/upgrade:
> 		if((stat->facility2==0) || (getLocationAvailible(current_location_window, stat->facility2)>=1))
> 		{
> 		// pick one availible facility: 
> 			for(picked_facility = 0; picked_facility<3; picked_facility++)
> 				if((stat->facility[picked_facility]>0)&&(getLocationAvailible(current_location_window, stat->facility[picked_facility])>0))
> 				{
> 					ok=true;
> 					break;
> 				}
> 		}						
> 	}
> 				
> //				j=1;
> 				// none found? search other parts of the map... TODO
> /*				if(!ok)
> 					while(j<MAX_LOCATIONS)
> 					{
> 						ttloc=(*pMap)->getLocation(tloc)->getNearest(j);
> //						if((stat->facility2==0)||(getLocationAvailible(ttloc,stat->facility2)>0)) TODO
> //						{
> //						for(fac=3;fac--;)
> 						for(fac=0;fac<3; fac++)
> 						if(
> 						// special rules for morphing units of protoss
> 						((stat->facilityType != IS_LOST) || (stat->facility[fac] != stat->facility2) || (getLocationAvailible(ttloc, stat->facility[fac]) >= 2)) &&
> 						((stat->facility[fac] > 0) && (getLocationAvailible(ttloc, stat->facility[fac])))
> 						|| ((stat->facility[fac]==0)&&(fac==0))) //~~
> 																													   
> //					  for(fac=3;fac--;)
> //						  if( ((stat->facility[fac]>0)&&(getLocationAvailible(ttloc,stat->facility[fac])>((stat->facilityType==IS_LOST)&&(stat->facility[fac]==stat->facility2)))) || ((stat->facility[fac]==0)&&(fac==0)))
> 							{
> 								tloc=ttloc;
> 								ok=true;
> 								break;
> 							}
> //						  break;
> //					  }
> 						j++;
> 					}*/
> 																													   
> 	if((ok)&&(build_unit==REFINERY)) {
> 		if(getMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR) <=0)
> 			ok=false;
> 		else
> 			removeOneMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR);
> 	}
> //TODO: Wenn verschiedene facilities moeglich sind, dann das letzte nehmen
> //			  bewegliche Sachen ueberdenken...
> //				  evtl zusaetzliche Eigenschaft 'speed' einbauen (muss sowieso noch...)... bei speed>0 ... mmmh... trifft aber auch nur auf scvs zu ... weil bringt ja wenig erst mit der hydra rumzulaufen und dann zum lurker... mmmh... aber waere trotzdem zu ueberlegen...
> //				  auch noch ueberlegen, wenn z.B. mit scv ohne kommandozentrale woanders gesammelt wird...
> //	  Phagen ueber Phagen...
> 	if(ok)
> 	{ 
>  		if((getpGoal()->getRace()==ZERG) &&
> //		  ((*pStats)[build_unit].facility[0]==LARVA)&&
> 			(build_unit!=LARVA) &&
> 		// Larva wird benoetigt zum Bau? Fein, dann bauen wir eine neue Larva falls nicht schon alle hatcheries etc. belegt sidn
> 				// Gesamtzahl der Larven < 3 * HATCHERY?
> 		   ((getLocationTotal(current_location_window, HATCHERY)+
> 			 getLocationTotal(current_location_window, LAIR)+
> 			 getLocationTotal(current_location_window, HIVE)) *3 > 
> 			 (larvaInProduction[current_location_window]+getLocationTotal(current_location_window, LARVA)))  &&
> // max 1 larva pro Gebaeude produzieren
>  		   ((getLocationTotal(current_location_window, HATCHERY)+
> 			 getLocationTotal(current_location_window, LAIR)+
> 			 getLocationTotal(current_location_window, HIVE) > 
> 			  larvaInProduction[current_location_window]))) // => zuwenig Larven da!
> 			{
> 				addLarvaToQueue(current_location_window);
> 				if(!buildIt(LARVA));
> //					removeLarvaFromQueue(current_location_window);
> 			}
> 
> 																												  
> 		Building build;
> 		build.setOnTheRun(false);
> 		build.setFacility(stat->facility[picked_facility]);
> 		build.setLocation(current_location_window);
> 		if(build_unit == FROM_GAS_TO_MINERALS)
> 			build.setUnitCount(getLocationAvailible(current_location_window, GAS_SCV));
> 		else
> 			build.setUnitCount(1+(stat->create == build_unit));
> 		build.setBuildFinishedTime(getTimer()-stat->BT);
> 		build.setTotalBuildTime(stat->BT);
> 		build.setType(build_unit);
> 		buildingQueue.push(build);
> 
> 		PROGRAM program;
> //		for(unsigned int i = UNIT_TYPE_COUNT; i--;)
> //		{
> //			program.setTotalCount(i, getLocationTotal(GLOBAL, i));
> //			program.setAvailibleCount(i, getLocationAvailible(GLOBAL, i));
> //		}
> 		program.setUnit(build_unit);
> 		program.setTime(getTimer());
> 		program.setFacility(build.getFacility());
> 		program.setLocation(build.getLocation());
> 		program.setBT(build.getTotalBuildTime());
> 	/*	if(successType>0)
> 		{
> 			program.setSuccessType(successType);
> 			program.setSuccessUnit(successUnit);
> 		}*/ //?
> 	
> 		program.before.setNeedSupply(getNeedSupply());
> 		program.before.setHaveSupply(getHaveSupply());
> 		program.before.setHaveMinerals(getMinerals());
> 		program.before.setHaveGas(getGas());
> 
> // upgrade_cost is 0 if it's no upgrade
> 		setMinerals(getMinerals()-(stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> 		setGas(getGas()-(stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> 		setNeedSupply(getNeedSupply()+stat->needSupply);
> //		if((stat->needSupply>0)||(((*pStats)[stat->facility[0]].needSupply<0)&&(stat->facilityType==IS_LOST)))  TODO!!!!
> //		setNeedSupply(getNeedSupply()-stat->needSupply); //? Beschreibung!
> 		adjustAvailibility(current_location_window, picked_facility, stat);
> 		
> 		program.after.setNeedSupply(getNeedSupply());
> 		program.after.setHaveSupply(getHaveSupply());
> 		program.after.setHaveMinerals(getMinerals());
> 		program.after.setHaveGas(getGas());
> 
> 		program.setUsedFacilityCount(getLocationTotal(GLOBAL, stat->facility[picked_facility]) - getLocationAvailible(GLOBAL, stat->facility[picked_facility])); // TODO evtl nach Ort
> 
>                	programList.push_back(program);
> 
> 	} //end if(ok)
> 	return(ok);
> }
778,783d842
< 
< 
< 
< 
< 
< 
diff -b -w -d ./anarace.hpp /home/claw/work/sc1064/sc/core/anarace.hpp
5,37c5,6
< 
< class STATISTICS
< {
< 	public:
< 		STATISTICS();
< 		~STATISTICS();
< 		void resetData();
< 		unsigned int needSupply;		// supply that is used up by all units
< 		unsigned int haveSupply;		// total supply of supply buildings (overlord, supply depot, command center, ...)
< 		unsigned int minerals;			// minerals at that time
< 		unsigned int gas;			// gas at that time
< 		unsigned int fitness;	//fitness at that time
< };
< 
< struct PROGRAM
< {
< 	public:
< 		PROGRAM();
< 		~PROGRAM();
< 		void resetData();		
< 		bool built;			// was this order successfully built?
< 		unsigned int time;			// at which time this order was started
< 		unsigned int location;		// at which location was this unit built
< 		unsigned int successType;	// type of error
< 		unsigned int successUnit;	// unit number
< 	//	int isGoal;			// is this unit part of the goal list? DOES NOT WORK YET :)
< 		unsigned int forceCount[UNIT_TYPE_COUNT];
< 		unsigned int availibleCount[UNIT_TYPE_COUNT];
< 		unsigned int facility; 	// where it was produced
< 		unsigned int BT;		//real buildtime, incl. moving scv etc.
< //		int isConstant; //this build order may not be moved. In addition no order may be inserted before the order, if the previous order is also constant.
< // TODO: Zeitfenster machen!
< };
---
> #include "program.hpp"
> #include "statistics.hpp"
41,83d9
< 	private:
< 		unsigned int unitsTotal; // total number of all unit types at the end
< 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
< 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
< 		unsigned int unchangedGenerations;
< 		unsigned int currentRun;
< 		bool optimizing;
< 		bool active;
< 		unsigned int totalGeneration;
< 		unsigned int maxpFitness;
< 		unsigned int maxsFitness;
< 		unsigned int maxtFitness;
< 		unsigned int timePercentage;
< 		unsigned int goalPercentage;
< 		unsigned int currentpFitness;
< 		unsigned int averageLength;
< 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
< 
< 		PROGRAM program[MAX_LENGTH];
< 		STATISTICS ipStatistics[2*MAX_LENGTH]; // before and after command!
< 		STATISTICS timeStatistics[MAX_TIME];
< 	
< //		const bool* fixed;
< 		
< 		static unsigned int successType; //type of error
< 		static unsigned int successUnit; //unit number
< 
< 		void setCurrentpFitness(unsigned int current_pfitness);
< 		
< 		const bool buildGene(const unsigned int build_unit);
< 
< 		void setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply);
< 		void setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply);
< 		void setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness);
< 		void setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals);
< 		void setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas);
< 
< 		void setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply);
< 		void setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply);
< 		void setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness);
< 		void setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals);
< 		void setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas);
< 		
111a38,40
> 		std::list<PROGRAM>& getProgramList();
> 		STATISTICS* getTimeStatistics();
> 
124d52
< //		const bool getProgramIsConstant(const unsigned int ip) const;
128,129d55
< 		const unsigned int getProgramSuccessType(const unsigned int ip) const;	// determines the type of the last error before the item was built at that IP
< 		const unsigned int getProgramSuccessUnit(const unsigned int ip) const;	// what unit was missing? (connected to successtype)
131,153d56
< 		const unsigned int getIPStatisticsNeedSupply(const unsigned int ip) const;	// supply that is used up by all units
< 		const unsigned int getIPStatisticsHaveSupply(const unsigned int ip) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
< 		const unsigned int getIPStatisticsFitness(const unsigned int ip) const;
< 		const unsigned int getIPStatisticsHaveMinerals(const unsigned int ip) const; // minerals at that time
< 		const unsigned int getIPStatisticsHaveGas(const unsigned int ip) const;		// gas at that time
< 
< 		const unsigned int getTimeStatisticsNeedSupply(const unsigned int time) const;	// supply that is used up by all units
< 		const unsigned int getTimeStatisticsHaveSupply(const unsigned int time) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
< 		const unsigned int getTimeStatisticsFitness(const unsigned int time) const;
< 		const unsigned int getTimeStatisticsHaveMinerals(const unsigned int time) const; // minerals at that time
< 		const unsigned int getTimeStatisticsHaveGas(const unsigned int time) const;		// gas at that time
< 
< 		const bool getProgramIsBuilt(const unsigned int ip) const;		// was this order successfully built?
< 
< 		const unsigned int getProgramTime(const unsigned int ip) const;			// at which time this order was started
< 		const unsigned int getRealProgramTime(const unsigned int ip) const;			// at which time this order was started
< 		const unsigned int getProgramLocation(const unsigned int ip) const;		// at which location was this unit built
< //		const bool getProgramIsGoal(const unsigned int ip) const;		// is this unit part of the goal list? NOT YET WORKING!
< 		const unsigned int getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const;	// how many units of the type at phaenoCode[s] do exist at that time?
< 		const unsigned int getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const;	 // how many units of the type at phaenoCode[s] do exist at that time?
< 
< 		const unsigned int getProgramFacility(const unsigned int ip) const;
< 		const unsigned int getProgramBT(const unsigned int ip) const;
160c63
< 		const unsigned int getMaxtFitness() const;			// gets tertiary fitness (build order appearance, some heuristics)
---
> 		const unsigned int getMaxtFitness() const;
174,185d76
< //		void setProgramIsConstant(const unsigned int ip, const bool isConstant);
< 		void setProgramFacility(const unsigned int ip, const unsigned int program_facility);
< 		void setProgramBT(const unsigned int ip, const unsigned int program_bt);
< 		void setProgramSuccessType(const unsigned int ip, const unsigned int program_success_type);
< 		void setProgramSuccessUnit(const unsigned int ip, const unsigned int program_success_unit);
< 		void setProgramIsBuilt(const unsigned int ip, const bool program_is_built);
< 		void setProgramLocation(const unsigned int ip, const unsigned int program_location);
< 		void setProgramTime(const unsigned int ip, const unsigned int program_time);
< //		void setProgramIsGoal(const unsigned int ip, const bool isGoal);	
< 		void setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);	
< 		void setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);
< 
192a84,113
> 		std::list<PROGRAM> programList; // TODO private machen
> 	private:
> 		unsigned int unitsTotal; // total number of all unit types at the end
> 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
> 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
> 		unsigned int unchangedGenerations;
> 		unsigned int currentRun;
> 		bool optimizing;
> 		bool active;
> 		unsigned int totalGeneration;
> 		unsigned int maxpFitness;
> 		unsigned int maxsFitness;
> 		unsigned int maxtFitness;
> 		unsigned int timePercentage;
> 		unsigned int goalPercentage;
> 		unsigned int currentpFitness;
> 		unsigned int averageLength;
> 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
> 
> 		STATISTICS timeStatistics[MAX_TIME];
> 
> //		const bool* fixed;
> 		
> 		static unsigned int successType; //type of error
> 		static unsigned int successUnit; //unit number
> 
> 		void setCurrentpFitness(unsigned int current_pfitness);
> 		
> 		const bool buildGene(const unsigned int build_unit);
> 		const bool buildIt(const unsigned int build_unit);
209,210c130,138
< inline const unsigned int ANARACE::getAverageLength() const
< {
---
> inline std::list<PROGRAM>& ANARACE::getProgramList() {
> 	return(programList);
> }
> 
> inline STATISTICS* ANARACE::getTimeStatistics() {
> 	return(timeStatistics);
> }
> 
> inline const unsigned int ANARACE::getAverageLength() const {
244,245c172
< inline const bool ANARACE::isActive() const
< {
---
> inline const bool ANARACE::isActive() const {
249,250c176
< inline void ANARACE::setActive(const bool set_active)
< {
---
> inline void ANARACE::setActive(const bool set_active) {
254,255c180
< inline const bool ANARACE::isOptimizing() const
< {
---
> inline const bool ANARACE::isOptimizing() const {
259,260c184
< inline void ANARACE::setOptimizing(const bool set_optimizing)
< {
---
> inline void ANARACE::setOptimizing(const bool set_optimizing) {
264,420d187
< inline const unsigned int ANARACE::getProgramFacility(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if(ip >= MAX_LENGTH) {
< 		toLog("DEBUG: (ANARACE::getProgramFacility): Value ip out of range.");return(0);
< 	}
< 	if(program[ip].facility >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::getProgramFacility): Variable not initialized.");return(0);
< 	}
< #endif
< //	if((getRace()==PROTOSS)&&(program[ip].facility==PROBE))
< //		while(true);
< 
< 	return(program[ip].facility);
< }
< 
< inline const unsigned int ANARACE::getProgramBT(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramBT): Value ip out of range.");return(0);
< 	}
< 	if(program[ip].BT >= MAX_TIME) {
< 		toLog("DEBUG: (ANARACE::getProgramBT): Variable not initialized.");return(0);
< 	}
< #endif
< 	return(program[ip].BT);
< }																	  
< 
< inline const unsigned int ANARACE::getProgramSuccessType(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Value ip out of range.");return(0);
< 	}
< 	if(program[ip].successType >= ERROR_MESSAGES) {
< 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Variable not initialized.");return(0);
< 	}
< #endif
< 	return(program[ip].successType);
< }
< 
< inline const unsigned int ANARACE::getProgramSuccessUnit(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Value ip out of range.");return(0);
< 	}
< 	if(program[ip].successUnit >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Variable not initialized.");return(0);
< 	}
< #endif
< 	return(program[ip].successUnit);
< }
< 
< /*inline void ANARACE::setProgramIsConstant(const unsigned int ip, const bool isConstant)
< {
< 		if((ip >= MAX_LENGTH)) {
< 				toLog("DEBUG: (ANARACE::setProgramIsConstant): Value ip out of range.");return(0);
< 		}
< 		program[ip].isConstant = isConstant;
< };*/
< 
< inline void ANARACE::setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value ip out of range.");return;
< 	}
< 	if(unit_type >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_type out of range.");return;
< 	}
< 	if(unit_count >= MAX_TOTAL_UNITS) {
< 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_count out of range.");return;
< 	}
< #endif
< 	program[ip].availibleCount[unit_type] = unit_count;
< }
< 
< inline void ANARACE::setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value ip out of range.");return;
< 	}
< 	if(unit_type >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_type out of range.");return;
< 	}
< 	if(unit_count >= MAX_TOTAL_UNITS) {
< 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_count out of range.");return;
< 	}
< #endif
< 	program[ip].forceCount[unit_type] = unit_count;
< }
< 
< // first time is 0!
< inline void ANARACE::setProgramTime(const unsigned int ip, const unsigned int program_time)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramTime): Value ip out of range.");return;
< 	}
< 	if(program_time > configuration.getMaxTime()) {
< 		toLog("DEBUG: (ANARACE::setProgramTime): Value program_time out of range.");return;
< 	}
< #endif
< 	program[ip].time = program_time;
< }
< 
< inline void ANARACE::setProgramBT(const unsigned int ip, const unsigned int program_bt)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramBT): Value ip out of range.");return;
< 	}
< 	if(program_bt >= MAX_TIME) {
< 		toLog("DEBUG: (ANARACE::setProgramBT): Value program_bt out of range.");return;
< 	}
< #endif
< 	program[ip].BT = program_bt;
< }
< 
< inline void ANARACE::setProgramIsBuilt(const unsigned int ip, const bool program_is_built)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramIsBuilt): Value ip out of range.");return;
< 	}
< #endif
< 	program[ip].built = program_is_built;
< }
< 
< inline void ANARACE::setProgramLocation(const unsigned int ip, const unsigned int program_location)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramLocation): Value ip out of range.");return;
< 	}
< 	if(program_location >= MAX_LOCATIONS) {
< 		toLog("DEBUG: (ANARACE::setProgramLocation): Value program_location out of range.");return;
< 	}
< #endif
< 	program[ip].location = program_location;
< }
< // ------ STATISTICS SET FUNCTIONS ------
< inline void ANARACE::setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply)
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value ip out of range.");return;
<     }
< 	if(need_supply > 10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value need_supply out of range.");return;
< 	}
< #endif
< 	ipStatistics[ip].needSupply = need_supply;
< }
422,739d188
< inline void ANARACE::setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply)
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value ip out of range.");return;
<     }
< 	if(have_supply > 10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value have_supply out of range.");return;
< 	}
< #endif
< 	ipStatistics[ip].haveSupply = have_supply;
< }
< 
< inline void ANARACE::setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals)
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value ip out of range.");return;
<     }
< 	if(have_minerals >= MAX_MINERALS) {
< 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value have_minerals out of range.");return;
< 	}
< #endif
< 	ipStatistics[ip].minerals = have_minerals;
< }
< 																				
< inline void ANARACE::setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas)
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value ip out of range.");return;
<     }
< 	if(have_gas >= MAX_GAS) {
< 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value have_gas out of range.");return;
< 	}
< #endif
< 	ipStatistics[ip].gas = have_gas;
< }
< 
< inline void ANARACE::setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness)
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value ip out of range.");return;
<     }
< 	if(fitness > MAX_PFITNESS) {
< 		toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value fitness out of range.");return;
< 	}
< #endif
< 	ipStatistics[ip].fitness = fitness;
< }
< 
< 
< inline void ANARACE::setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply)
< {
< #ifdef _SCC_DEBUG
<     if((time>=MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value time out of range.");return;
<     }
< 	if(need_supply>10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value need_supply out of range.");return;
< 	}
< #endif
< 	timeStatistics[time].needSupply = need_supply;
< }
< 
< inline void ANARACE::setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply)
< {
< #ifdef _SCC_DEBUG
<     if((time>=MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value time out of range.");return;
<     }
< 	if(have_supply>10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value have_supply out of range.");return;
< 	}
< #endif
< 	timeStatistics[time].haveSupply = have_supply;
< }
< 
< inline void ANARACE::setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals)
< {
< #ifdef _SCC_DEBUG
<     if((time >= MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value time out of range.");return;
<     }
< 	if(have_minerals >= MAX_MINERALS) {
< 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value have_minerals out of range.");return;
< 	}
< #endif
< 	timeStatistics[time].minerals = have_minerals;
< }
< 																				
< inline void ANARACE::setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas)
< {
< #ifdef _SCC_DEBUG
<     if((time >= MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value time out of range.");return;
<     }
< 	if(have_gas >= MAX_GAS) {
< 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value have_gas out of range.");return;
< 	}
< #endif
< 	timeStatistics[time].gas = have_gas;
< }
< 
< inline void ANARACE::setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness)
< {
< #ifdef _SCC_DEBUG
<     if((time>=MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value time out of range.");return;
<     }
< 	if(fitness>MAX_PFITNESS) {
< 		toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value fitness out of range.");return;
< 	}
< #endif
< 	timeStatistics[time].fitness=fitness;
< }
< // ------ END OF STATISTICS SET FUNCTIONS ------
< 
< 
< inline const unsigned int ANARACE::getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const	   // how many units of the type at phaenoCode[s] do exist at that time?
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value ip out of range.");return(0);
< 	}
< 	if(unit_type >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value unit_type out of range.");return(0);
< 	}
< #endif
< 	return(program[ip].forceCount[unit_type]);
< }
< 
< // how many units of the type at phaenoCode[s] do exist at that time?
< inline const unsigned int ANARACE::getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const	   
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value ip out of range.");return(0);
< 	}
< 	if(unit_type >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value unit_type out of range.");return(0);
< 	}
< #endif
< 	return(program[ip].availibleCount[unit_type]);
< }
< 
< inline void ANARACE::setProgramFacility(const unsigned int ip, const unsigned int facility)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramFacility): Value ip out of range.");return;
< 	}
< 	if(facility>=UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::setProgramFacility): Value facility out of range.");return;
< 	}
< #endif
< 	program[ip].facility = facility;
< }
< 
< inline void ANARACE::setProgramSuccessType(const unsigned int ip, const unsigned int type)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value ip out of range.");return;
< 	}
< 	if(type >= ERROR_MESSAGES) {
< 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value type out of range.");return;
< 	}
< #endif
< 	program[ip].successType = type;
< }
< 
< inline void ANARACE::setProgramSuccessUnit(const unsigned int ip, const unsigned int unit_type)
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value ip out of range.");return;
< 	}
< 	if(unit_type >= UNIT_TYPE_COUNT) {
< 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value unit_type out of range.");return;
< 	}
< #endif
< 	program[ip].successUnit = unit_type;
< }
< 
< // ------ STATISTICS GET FUNCTIONS ------
< inline const unsigned int ANARACE::getIPStatisticsNeedSupply(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Value ip out of range.");return(0);
<     }
< 	if(ipStatistics[ip].needSupply > 10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Variable ipStatistics.needSupply not initialized.");	return(0);
< 	}
< #endif
< 	return(ipStatistics[ip].needSupply);
< }
< 
< inline const unsigned int ANARACE::getIPStatisticsHaveSupply(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Value ip out of range.");return(0);
<     }
< 	if(ipStatistics[ip].haveSupply > 10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Variable ipStatistics.haveSupply not initialized.");return(0);
< 	}
< #endif
< 	return(ipStatistics[ip].haveSupply);
< }
< 
< inline const unsigned int ANARACE::getIPStatisticsHaveMinerals(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
< 	        toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Value ip out of range.");return(0);
< 	}
< 	if(ipStatistics[ip].minerals > MAX_MINERALS) {
< 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Variable ipStatistics.minerals not initialized.");return(0);
< 	}
< #endif
< 	return(ipStatistics[ip].minerals);
< }
< 
< inline const unsigned int ANARACE::getIPStatisticsHaveGas(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Value ip out of range.");return(0);
<     }
< 	if(ipStatistics[ip].gas > MAX_GAS) {
< 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Variable ipStatistics.gas not initialized.");return(0);
< 	}
< #endif
< 	return(ipStatistics[ip].gas);
< }
< 
< inline const unsigned int ANARACE::getIPStatisticsFitness(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
<     if((ip >= 2*MAX_LENGTH)) {
<         toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Value ip out of range.");return(0);
<     }
< 	// TODO max pfitness 
< 	if(ipStatistics[ip].fitness>MAX_PFITNESS) {
< 		toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Variable ipStatistics.fitness not initialized.");return(0);
< 	}
< #endif
< 	return(ipStatistics[ip].fitness);
< }
< 
< 
< inline const unsigned int ANARACE::getTimeStatisticsNeedSupply(const unsigned int time) const
< {
< #ifdef _SCC_DEBUG
<     if((time>=MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Value time out of range.");return(0);
<     }
< 	if(timeStatistics[time].needSupply>10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Variable timeStatistics.needSupply not initialized.");return(0);
< 	}
< #endif
< 	return(timeStatistics[time].needSupply);
< }
< 
< inline const unsigned int ANARACE::getTimeStatisticsHaveSupply(const unsigned int time) const
< {
< #ifdef _SCC_DEBUG
<     if((time>=MAX_TIME)) {
<         toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Value time out of range.");return(0);
<     }
< 	if(timeStatistics[time].haveSupply>10*MAX_SUPPLY) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Variable timeStatistics.haveSupply not initialized.");return(0);
< 	}
< #endif
< 	return(timeStatistics[time].haveSupply);
< }
< 
< inline const unsigned int ANARACE::getTimeStatisticsHaveMinerals(const unsigned int time) const
< {
< #ifdef _SCC_DEBUG
<     if((time>=MAX_TIME)) {
< 	        toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Value time out of range.");return(0);
< 	}
< 	if(timeStatistics[time].minerals>MAX_MINERALS) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Variable timeStatistics.minerals not initialized.");return(0);
< 	}
< #endif
< 	return(timeStatistics[time].minerals);
< }
< inline const unsigned int ANARACE::getTimeStatisticsHaveGas(const unsigned int time) const
< {
< #ifdef _SCC_DEBUG
< 	if((time>=MAX_TIME)) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Value time out of range.");return(0);
< 	}
< 	if(timeStatistics[time].gas>MAX_GAS) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Variable timeStatistics.gas not initialized.");return(0);
< 	}
< #endif
< 	return(timeStatistics[time].gas);
< }
< 
< inline const unsigned int ANARACE::getTimeStatisticsFitness(const unsigned int time) const
< {
< #ifdef _SCC_DEBUG
< 	if((time>=MAX_TIME)) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Value time out of range.");return(0);
< 	}
< 	// TODO max pfitness 
< 	if(timeStatistics[time].fitness>MAX_PFITNESS) {
< 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Variable timeStatistics.fitness not initialized.");return(0);
< 	}
< #endif
< 	return(timeStatistics[time].fitness);
< }
742,800c191
< inline const bool ANARACE::getProgramIsBuilt(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramIsBuilt): Value ip out of range.");return(0);
< 	}
< #endif
< 	return(program[ip].built);
< }
< 
< 
< /*const bool ANARACE::getProgramIsConstant(const unsigned int ip)
< {
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramIsConstant): Value ip [%i] out of range.",IP);return(false);
< 	}
< 	return(program[ip].isConstant);
< };*/
< 
< // first program time is
< inline const unsigned int ANARACE::getProgramTime(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramTime): Value ip out of range.");return(0);
< 	}
< 	if(program[ip].time > configuration.getMaxTime()) {
< 		toLog("DEBUG: (ANARACE::getProgramTime): Variable not initialized.");return(0);
< 	}
< #endif
< 	return(program[ip].time);
< }
< 
< inline const unsigned int ANARACE::getRealProgramTime(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
< 	}
< #endif
< 	return(configuration.getMaxTime() - getProgramTime(ip));
< }
< 
< 
< inline const unsigned int ANARACE::getProgramLocation(const unsigned int ip) const
< {
< #ifdef _SCC_DEBUG
< 	if((ip >= MAX_LENGTH)) {
< 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
< 	}
< 	if(program[ip].location > MAX_LOCATIONS) {
< 		toLog("DEBUG: (ANARACE::getProgramLocation): Variable program.location not initialized.");return(0);
< 	}
< #endif
< 	return(program[ip].location);
< }
< 
< inline const unsigned int ANARACE::getTimePercentage() const
< {
---
> inline const unsigned int ANARACE::getTimePercentage() const {
804,805c195
< inline const unsigned int ANARACE::getFastestGoalTime() const
< {
---
> inline const unsigned int ANARACE::getFastestGoalTime() const {
808,809c198,199
< inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const
< {
---
> 
> inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const {
913a304
> 
934,935c325
< inline void ANARACE::setTotalGeneration(const unsigned int total_generation)
< {
---
> inline void ANARACE::setTotalGeneration(const unsigned int total_generation) {
969d358
< //int getProgramSuccessType(int IP);
Files ./anarace.o and /home/claw/work/sc1064/sc/core/anarace.o differ
diff -b -w -d ./basicmap.cpp /home/claw/work/sc1064/sc/core/basicmap.cpp
1a2
> #include <iostream>
24a26,43
> unsigned int BASIC_MAP::calculateDistance(unsigned int i, unsigned int j)
> {
> 	if(i==j)
> 		return(0);
> 	if(location[i].getDistance(j) < 9999)
> 		return(location[i].getDistance(j));
> 	unsigned int min = 9999;
> 	for(unsigned int k=1;k<getMaxLocations();k++)
> 		if(location[i].getDistance(k) < 9999)
> 		{
> 			unsigned int temp = location[i].getDistance(k) + calculateDistance(j, k);
> 			if(temp < min)
> 				min = temp;
> 		}
> 	return(min);	
> }
> 
> 
27c46,71
< 	for(int i=1;i<MAX_LOCATIONS;i++)
---
> 	for(unsigned int i=1;i<getMaxLocations();i++)
> 		for(unsigned int j=1;j<getMaxLocations();j++)
> 			if(location[i].getDistance(j) < 9999)
> 				location[j].setDistance(i, location[i].getDistance(j));
> 
> 	for(unsigned int i = 1; i < getMaxLocations(); i++)
> 	{
> 		std::cout << "Location " << i << " ";
> 		for(unsigned int j = 1; j < getMaxLocations(); j++)
> 			std::cout << getLocation(i)->getDistance(j) << " ";
> 		std::cout << std::endl;
> 	}
> 				
> 	for(unsigned int i=1;i<getMaxLocations();i++)
> 		for(unsigned int j=1;j<getMaxLocations();j++)
> 			location[i].setDistance(j, calculateDistance(i, j));
> 
> 	for(unsigned int i = 1; i < getMaxLocations(); i++)
> 	{
> 		std::cout << "Location " << i << " ";
> 		for(unsigned int j = 1; j < getMaxLocations(); j++)
> 			std::cout << getLocation(i)->getDistance(j) << " ";
> 		std::cout << std::endl;
> 	}
> 
> 	for(unsigned int i=1;i<getMaxLocations();i++)
diff -b -w -d ./basicmap.hpp /home/claw/work/sc1064/sc/core/basicmap.hpp
16a17
> 		unsigned int calculateDistance(unsigned int i, unsigned int j);
35c36
< 		void setLocationDistance(const unsigned int location_number, std::list<std::string> distances);// needs never be changed so a list is fine
---
> 		void setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance);
74c75
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= maxLocations)) {
84c85
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= maxLocations)) {
94c95
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= maxLocations)) {
104c105
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= maxLocations)) {
114c115
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= maxLocations)) {
124c125
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= maxLocations)) {
131c132
< inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const std::list<std::string> distances)
---
> inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance)
134,147c135,136
< 	if((location_number >= MAX_LOCATIONS)) {
< 		toLog("DEBUG: (MAP::setLocationDistance): Value out of range.");return;
< 	}
< 	if(location_number >= distances.size()) {
< 		toLog("DEBUG: (MAP::setLocationDistance): Too many locations.");return;
< 	}
< #endif
< 	std::list<std::string>::const_iterator i=distances.begin();
< 	unsigned int j=0;
< 	while(i!=distances.end())
< 	{
< 		location[location_number].setDistance(j, atoi(i->c_str()));
< 		i++;
< 		j++;
---
> 	if((location_number >= maxLocations)) {
> 		toLog("DEBUG: (MAP::setLocationDistance): Value location_number out of range.");return;
149,151c138,139
< #ifdef _SCC_DEBUG
< 	if( j < location_number ) {
< 		toLog("DEBUG: (MAP::setLocationDistance): Not enough locations.");return;
---
> 	if((target >= maxLocations)) {
> 		toLog("DEBUG: (MAP::setLocationDistance): Value target out of range.");return;
152a141,144
> //	if(distance >= 1000) {
> //		toLog("DEBUG: (MAP::setLocationDistance): Value distance out of range.");return;
> //	}
> 	
153a146
> 	location[location_number].setDistance(target, distance);
163a157
> 	MAP_LOCATION::setMaxLocations(max_locations);
179c173
< 	if(location_number >= MAX_LOCATIONS) {
---
> 	if(location_number >= maxLocations) {
186,187d179
< 
< 
Files ./basicmap.o and /home/claw/work/sc1064/sc/core/basicmap.o differ
diff -b -w -d ./building.cpp /home/claw/work/sc1064/sc/core/building.cpp
9c9
< 	IP(0),
---
> //	IP(0),
21c21
< 	IP(object.IP),
---
> //	IP(object.IP),
34c34
< 	IP = object.IP;
---
> //	IP = object.IP;
diff -b -w -d ./building.hpp /home/claw/work/sc1064/sc/core/building.hpp
14c14
< 	unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
---
> //		unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
18a19,22
> 
> 		Building();
> 		Building(const Building& object);
> 		Building& operator=(const Building& object);
24,28c28
< 	}
< 	Building();
< 	Building(const Building& object);
< 	Building& operator=(const Building& object);
< 	
---
> 		};
38c38
< 	const unsigned int getIP() const;
---
> //		const unsigned int getIP() const;
49c49
< 	void setIP(const unsigned int building_IP);
---
> //		void setIP(const unsigned int building_IP);
107c107
< inline const unsigned int Building::getIP() const
---
> /*inline const unsigned int Building::getIP() const
115c115
< }
---
> }*/
120c120
< 	if(location > MAX_LOCATIONS) {
---
> 	if(location >= MAX_LOCATIONS) { // TODO
197c197
< inline void Building::setIP(const unsigned int building_IP)
---
> /*inline void Building::setIP(const unsigned int building_IP)
205c205
< }
---
> }*/
Files ./building.o and /home/claw/work/sc1064/sc/core/building.o differ
diff -b -w -d ./configuration.hpp /home/claw/work/sc1064/sc/core/configuration.hpp
10d9
< #include <deque>
Files ./configuration.o and /home/claw/work/sc1064/sc/core/configuration.o differ
diff -b -w -d ./defs.cpp /home/claw/work/sc1064/sc/core/defs.cpp
38c38
< const std::string CORE_VERSION="Beta 1.62final";
---
> const std::string CORE_VERSION="Beta 1.63a";
198,202c198,202
< {"Move 3 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Move 1 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Move 1 Backward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
---
> {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
311,315c311,315
< {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
---
> {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
420,424c420,424
< {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
---
> {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
diff -b -w -d ./defs.hpp /home/claw/work/sc1064/sc/core/defs.hpp
11c11
< #define MAX_LOCATIONS 3
---
> #define MAX_LOCATIONS 5
200,205c200,206
< 	MOVE_ONE_3_FORWARD,
< 	MOVE_ONE_1_FORWARD,
< 	MOVE_ONE_1_BACKWARD,
< 	ROTATE, 
< 	FOLLOW,// 70
< 	RESET,
---
> 	BUILD_PARALLEL_2,
> 	BUILD_PARALLEL_4,
> 	BUILD_PARALLEL_8,
> 	BUILD_PARALLEL_16,
> 	
> 	FROM_GAS_TO_MINERALS,
> 	LAST_UNIT,// 70
Files ./defs.o and /home/claw/work/sc1064/sc/core/defs.o differ
diff -b -w -d ./differ /home/claw/work/sc1064/sc/core/differ
1,44c1,56
< diff -b -w -d ./anarace.cpp /home/claw/work/sc1064/sc/core/anarace.cpp
< 14,66d13
< < STATISTICS::STATISTICS():
< < 	needSupply(0),
< < 	haveSupply(0),
< < 	minerals(0),
< < 	gas(0),
< < 	fitness(0)
< < { }
< < 
< < STATISTICS::~STATISTICS() {}
< < 
< < void STATISTICS::resetData()
< < {
< < 	needSupply=0;
< < 	haveSupply=0;
< < 	minerals=0;
< < 	gas=0;
< < 	fitness=0;
< < }
< < 
< < PROGRAM::PROGRAM():
< < 	built(false),
< < 	time(0),
< < 	location(0),
< < 	successType(0),
< < 	successUnit(0),
< < 	facility(0),
< < 	BT(0)
< < {
< < 	for(int i=UNIT_TYPE_COUNT;i--;)
< < 	{
< < 		forceCount[i]=0;
< < 		availibleCount[i]=0;
< < 	}
< < }
< < 
< < PROGRAM::~PROGRAM() {}
< < 
< < void PROGRAM::resetData()
< < {
< < 	built=false;
< < 	time=0;
< < 	location=0;
---
> diff ./anarace.cpp /home/claw/work/sc1063b/sc/core/anarace.cpp
> 13a14,66
> > STATISTICS::STATISTICS():
> > 	needSupply(0),
> > 	haveSupply(0),
> > 	minerals(0),
> > 	gas(0),
> > 	fitness(0)
> > { }
> > 
> > STATISTICS::~STATISTICS() {}
> > 
> > void STATISTICS::resetData()
> > {
> > 	needSupply=0;
> > 	haveSupply=0;
> > 	minerals=0;
> > 	gas=0;
> > 	fitness=0;
> > }
> > 
> > PROGRAM::PROGRAM():
> > 	built(false),
> > 	time(0),
> > 	location(0),
> > 	successType(0),
> > 	successUnit(0),
> > 	facility(0),
> > 	BT(0)
> > {
> > 	for(int i=UNIT_TYPE_COUNT;i--;)
> > 	{
> > 		forceCount[i]=0;
> > 		availibleCount[i]=0;
> > 	}
> > }
> > 
> > PROGRAM::~PROGRAM() {}
> > 
> > void PROGRAM::resetData()
> > {
> > 	built=false;
> > 	time=0;
> > 	location=0;
> > 	successType=0;
> > 	successUnit=0;
> > 	facility=0;
> > 	BT=0;
> > 		for(int i=UNIT_TYPE_COUNT;i--;)
> > 		{
> > 				forceCount[i]=0;
> > 				availibleCount[i]=0;
> > 		}
> > }
> > 
> 16,17c69,71
47,65c59,63
< < 	facility=0;
< < 	BT=0;
< < 		for(int i=UNIT_TYPE_COUNT;i--;)
< < 		{
< < 				forceCount[i]=0;
< < 				availibleCount[i]=0;
< < 		}
< < }
< < 
< 69d15
< < 	PRERACE::resetStaticPrerace();
< 76a23,27
< > 	fitnessAverage(0),
< > 	fitnessVariance(0),
< > 	positiveCrossover(0),
< > 	wayneCrossover(0),
< > 	negativeCrossover(0),
< 91,99c42
< < 	averageLength(0),
---
> ---
> > 	PRERACE::resetStaticPrerace();
> > 	successType=0;
> > 	successUnit=0;
> 23,27d76
70,73c68,72
< < 	negativeCrossover(0)
< < {
< < 	
< < 	for(int i = MAX_LENGTH;i--;)
---
> < 	negativeCrossover(0),
> 37a87
> > 	maxtFitness(MAX_TFITNESS),
> 41c91,96
> < 	averageLength(0)
75,81c74,81
< > 	averageLength(0)
< 101,105c44
< < 		phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
< < 		ipStatistics[i].resetData();
< < 		ipStatistics[i+1].resetData();
< < 		program[i].resetData();
< < 	}
---
> > 	averageLength(0),
> > 	fitnessAverage(0),
> > 	fitnessVariance(0),
> > 	positiveCrossover(0),
> > 	wayneCrossover(0),
> > 	negativeCrossover(0)
> 43c98,105
> < 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
83,91c83,113
< > 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
< 133,139c72
< < 		for(int i = MAX_LENGTH;i--;)
< < 		{
< < 				phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
< < 				ipStatistics[i].resetData();
< < 				ipStatistics[i+1].resetData();
< < 				program[i].resetData();
< < 		}
---
> > 	
> > 	for(int i = MAX_LENGTH;i--;)
> > 	{
> > 		phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
> > 		ipStatistics[i].resetData();
> > 		ipStatistics[i+1].resetData();
> > 		program[i].resetData();
> > 	}
> 51,72c113,141
> < 	unitsTotal = 4;
> < 	unitsTotalMax = 4;
> < 	nonGoalsUnitsTotalMax = 4;
> < 	unchangedGenerations = 0;
> < 	currentRun = 0;
> < 	optimizing = false;
> < 	active = true;
> < 	totalGeneration = 0;
> < 	maxpFitness = 0;
> < 	maxsFitness = 0;
> < 	timePercentage = 0;
> < 	goalPercentage = 0;
> < 	currentpFitness = 0;
> < 	averageLength = 0;
> < 	fitnessAverage = 0;
> < 	fitnessVariance = 0;
> < 	positiveCrossover = 0;
> < 	wayneCrossover = 0;
> < 	negativeCrossover = 0;
> < 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
> < 	for(int i = MAX_TIME;i--;)
> < 		timeStatistics[i].resetData();
93,101c115,144
< > 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
< 148a82,86
< > 	fitnessAverage( object.fitnessAverage ),
< > 	fitnessVariance( object.fitnessVariance ),
< > 	positiveCrossover( object.positiveCrossover ),
< > 	wayneCrossover( object.wayneCrossover ), 
< > 	negativeCrossover( object.negativeCrossover ),
< 163,170c101
< < 	averageLength( object.averageLength ),
---
> > 		unitsTotal=4;
> > 		unitsTotalMax=4;
> > 		nonGoalsUnitsTotalMax=4;
> > 		unchangedGenerations=0;
> > 		currentRun=0;
> > 		optimizing=false;
> > 		active=true;
> > 		totalGeneration=0;
> > 		maxpFitness=0;
> > 		maxsFitness=0;
> > 		maxtFitness=MAX_TFITNESS;
> > 		timePercentage=0;
> > 		goalPercentage=0;
> > 		currentpFitness=0;
> > 		averageLength=0;
> > 		fitnessAverage=0;
> > 		fitnessVariance=0;
> > 		positiveCrossover=0;
> > 		wayneCrossover=0;
> > 		negativeCrossover=0;
> > 		for(int i = MAX_LENGTH;i--;)
> > 		{
> > 				phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
> > 				ipStatistics[i].resetData();
> > 				ipStatistics[i+1].resetData();
> > 				program[i].resetData();
> > 		}
> > 		for(int i = MAX_TIME;i--;)
> > 				timeStatistics[i].resetData();
> 80,84d148
106,108c149,153
< < 	negativeCrossover( object.negativeCrossover )
< < {
< < 	for(int i = MAX_LENGTH;i--;)
---
> < 	negativeCrossover( object.negativeCrossover ),
> 94a159
> > 	maxtFitness( object.maxtFitness ),
> 98c163,168
> < 	averageLength( object.averageLength )
110,117c155,163
< > 	averageLength( object.averageLength )
< 172,177c103,104
< < 		phaenoCode[i] = object.phaenoCode[i];
< < 		program[i] = object.program[i];
< < 		ipStatistics[i] = object.ipStatistics[i];
< < 	}	
< < 	for(int i = MAX_TIME;i--;)
< < 		timeStatistics[i] = object.timeStatistics[i];
---
> > 	averageLength( object.averageLength ),
> > 	fitnessAverage( object.fitnessAverage ),
> > 	fitnessVariance( object.fitnessVariance ),
> > 	positiveCrossover( object.positiveCrossover ),
> > 	wayneCrossover( object.wayneCrossover ), 
> > 	negativeCrossover( object.negativeCrossover )
> 100,101c170,177
> < 	memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
> < 	memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
119,127c165,173
< > 	memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
< > 	memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
< 182a110,114
< > 	fitnessAverage = object.fitnessAverage;
< > 	fitnessVariance = object.fitnessVariance;
< > 	positiveCrossover = object.positiveCrossover;
< > 	wayneCrossover = object.wayneCrossover;
< > 	negativeCrossover = object.negativeCrossover;
< 198,210c130,131
---
> > 	for(int i = MAX_LENGTH;i--;)
> > 	{
> > 		phaenoCode[i] = object.phaenoCode[i];
> > 		program[i] = object.program[i];
> > 		ipStatistics[i] = object.ipStatistics[i];
> > 	}	
> > 	for(int i = MAX_TIME;i--;)
> > 		timeStatistics[i] = object.timeStatistics[i];
> 107,111d182
133c179,277
< < 	for(int i = MAX_LENGTH;i--;)
---
> 121a193
> > 	maxtFitness = object.maxtFitness;
> 126,128c198,211
> <         memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
> <         memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
> < 
> ---
> > 	fitnessAverage = object.fitnessAverage;
> > 	fitnessVariance = object.fitnessVariance;
> > 	positiveCrossover = object.positiveCrossover;
> > 	wayneCrossover = object.wayneCrossover;
> > 	negativeCrossover = object.negativeCrossover;
> > 	for(int i = MAX_LENGTH;i--;)
> > 	{
> > 		phaenoCode[i] = object.phaenoCode[i];
> > 		program[i] = object.program[i];
> > 		ipStatistics[i] = object.ipStatistics[i];
> > 	}
> > 	for(int i = MAX_TIME;i--;)
> > 		timeStatistics[i] = object.timeStatistics[i];
> > 		
> 139a223
> > 	setMaxtFitness(MAX_TFITNESS);
> 141,146c225,230
> < 	unitsTotal = 1; // ~4 ?
> < 	unitsTotalMax = 1;
> < 	nonGoalsUnitsTotalMax = 1;
> < 	timePercentage = 0;
> < 	goalPercentage = 0;
> < 	averageLength = 0;
> ---
> > 	unitsTotal=1; // ~4 ?
> > 	unitsTotalMax=1;
> > 	nonGoalsUnitsTotalMax=1;
> > 	timePercentage=0;
> > 	goalPercentage=0;
> > 	averageLength=0;
> 157,162c241,276
> < 	memset(timeStatistics, 0, MAX_LENGTH * sizeof(STATISTICS));
> < 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));
> < 
> < 	std::list<PROGRAM>::iterator i = programList.begin();
> < 	while(i!=programList.end())
> < 		i = programList.erase(i);	
> ---
> > 	for(int i=2*MAX_LENGTH;i--;)
> > 	{
> > 		setIPStatisticsHaveSupply(i, 0);
> > 		setIPStatisticsHaveMinerals(i, 0);
> > 		setIPStatisticsHaveGas(i, 0);
> > 		setIPStatisticsNeedSupply(i, 0);
> > 		setIPStatisticsFitness(i, 0);
> > 	}
> > 	
> > 	for(int i=MAX_TIME;i--;)
> > 	{
> > 		setTimeStatisticsHaveSupply(i, 0);
> > 		setTimeStatisticsHaveMinerals(i, 0);
> > 		setTimeStatisticsHaveGas(i, 0);
> > 		setTimeStatisticsNeedSupply(i, 0);
> > 		setTimeStatisticsFitness(i, 0);
> > 	}
> > 	
> > 	for(int i=MAX_LENGTH;i--;)//ANA~
> > 	{
> > 		setProgramSuccessType(i, 0);
> > 		setProgramSuccessUnit(i, 0);
> > 		setProgramIsBuilt(i, false);
> > 		setProgramTime(i, 0);
> > 		for(int j=UNIT_TYPE_COUNT;j--;)
> > 		{
> > 			setProgramAvailibleCount(i, j, 0);
> > 			setProgramTotalCount(i, j, 0);
> > 		}
> > 		//program[i].temp=0;
> > 		setProgramLocation(i,0);
> > //		setProgramIsGoal(i,false);
> > 		setProgramFacility(i,0);
> > 		setProgramBT(i,0);
> > 		phaenoCode[i]=0;
> > 	}
> 196,200c310,315
> < //		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
> < //		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
> < //		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
> < //		setTimeStatisticsHaveGas(getTimer(), getGas());
> < //		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
> ---
> > 		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
> > 		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
> > 		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
> > 		setTimeStatisticsHaveGas(getTimer(), getGas());
> > 		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
> > 
> 203a319
> > 
> 210,232d325
> < 		unsigned int code = getpGoal()->toPhaeno(getCurrentCode());
> < 		if((code >= BUILD_PARALLEL_2) && (code <= BUILD_PARALLEL_16))
135,137c279,289
< < 		phaenoCode[i] = object.phaenoCode[i];
< < 		program[i] = object.program[i];
< < 		ipStatistics[i] = object.ipStatistics[i];
---
> <                         setIP(getIP()-1);
> <                         while((getpGoal()->toPhaeno(getCurrentCode()) > GAS_SCV)&&(getIP()))
> <                                 setIP(getIP()-1);
> <                         PARALLEL_COMMAND* pcommand = new PARALLEL_COMMAND;
> <                         switch(code)
> <                         {
> <                                 case BUILD_PARALLEL_2:pcommand->count = 2;break;
> <                                 case BUILD_PARALLEL_4:pcommand->count = 4;break;
> <                                 case BUILD_PARALLEL_8:pcommand->count = 8;break;
> <                                 case BUILD_PARALLEL_16:pcommand->count = 16;break;
> <                                 default:break; // ~~
139,140c291,303
< < 	for(int i = MAX_TIME;i--;)
< < 		timeStatistics[i] = object.timeStatistics[i];
---
> <                         pcommand->unit = getpGoal()->toPhaeno(getCurrentCode());
> < 			
> <                         if(getIP()) 
> < 				setIP(getIP()-1);
> <                         parallelCommandQueues.push_back(pcommand);
> <                         ok = true;
> <                 } else
> < 		{
> 234,237c327,333
> < 			neededMinerals = MAX_MINERALS;
> < 			neededGas = MAX_GAS;
> < 			
> < 			ok = buildGene(getpGoal()->toPhaeno(getCurrentCode()));
142,147c305,328
< >         memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
< >         memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
< 223d143
< < 	setMaxtFitness(MAX_TFITNESS);
< 241,257c161,162
< < 	for(int i=2*MAX_LENGTH;i--;)
---
> > 		neededMinerals=MAX_MINERALS;
> > 		neededGas=MAX_GAS;
> > 		setIPStatisticsNeedSupply(getIP()*2+1, getNeedSupply());
> > 		setIPStatisticsHaveSupply(getIP()*2+1, getHaveSupply());
> > 		setIPStatisticsHaveMinerals(getIP()*2+1, getMinerals());
> > 		setIPStatisticsHaveGas(getIP()*2+1, getGas());
> > 		setIPStatisticsFitness(getIP()*2+1, calculatePrimaryFitness(ready));
> 238a335,348
> > 		ok=buildGene(getpGoal()->toPhaeno(getCurrentCode()));
> > 	
> > 		setIPStatisticsNeedSupply(getIP()*2, getNeedSupply());
> > 		setIPStatisticsHaveSupply(getIP()*2, getHaveSupply());
> > 		setIPStatisticsHaveMinerals(getIP()*2, getMinerals());
> > 		setIPStatisticsHaveGas(getIP()*2, getGas());
> > 		setIPStatisticsFitness(getIP()*2, calculatePrimaryFitness(ready));
> > 	
> > 		if(successType>0)
> > 		{
> > 			setProgramSuccessType(getIP(), successType);
> > 			setProgramSuccessUnit(getIP(), successUnit);
> > 		}
> > 		
> 242,261c352,367
> < 			if((ok) || (!getTimeOut())) 
149,153c330,346
< < 		setIPStatisticsHaveSupply(i, 0);
< < 		setIPStatisticsHaveMinerals(i, 0);
< < 		setIPStatisticsHaveGas(i, 0);
< < 		setIPStatisticsNeedSupply(i, 0);
< < 		setIPStatisticsFitness(i, 0);
---
> < 				setTimeOut(configuration.getMaxTimeOut());
> < 				setIP(getIP()-1);
> < 			}		
> <                 	else if(!ok)
> < 	                {
> < // TEST FOR PARALLEL COMMANDQUEUES
> <         	                std::list<PARALLEL_COMMAND*>::iterator command = parallelCommandQueues.begin(); 
> <                 	        while(command != parallelCommandQueues.end())
> <                         	{
> <                                 	ok = buildGene((*command)->unit);
> < 	                                if(ok)  
> <         	                        {
> <                 	                        (*command)->count--;
> <                         	                if(!(*command)->count)
> <                                 	                command = parallelCommandQueues.erase(command);
> <                 	                } else command++;
> < 		               	}
154a348,369
> ---
> > 		if((ok)||(!getTimeOut())) {
> > 			if(ok) {
> > 				setProgramTime(getIP(), getTimer());
> > 			} else {
> > 				setProgramTime(getIP(),configuration.getMaxTime());
> > 				setProgramSuccessType(getIP(), TIMEOUT_ERROR);
> > 				setProgramSuccessUnit(getIP(), 0);
> > //				setProgramSuccessLocation(0);
> > 			}
> > 			for(int i=UNIT_TYPE_COUNT;i--;)	{
> > 				setProgramTotalCount(getIP(), i, getLocationTotal(GLOBAL, i));
> > 				setProgramAvailibleCount(getIP(),i,getLocationAvailible(GLOBAL, i));
> > 			}
> > 	
> > 			setTimeOut(configuration.getMaxTimeOut());
> > 			setIP(getIP()-1);
> 266c372
> < 	unsigned int t = calculateIdleTime();
> ---
> > 	int t=calculateIdleTime();
> 269,284c375,383
156c371,378
< < 	for(int i=MAX_TIME;i--;)
---
> < //	if(t>0)
> < //	{
> < //		setProgramSuccessType(getIP(), TIMEOUT_ERROR);
> < //		setProgramSuccessUnit(getIP(), 0); TODO
> < //		setProgramSuccessLocation(0);
> < //	}
> < 
> < 	for(unsigned int i = t; i--;)
158,162c380,384
< < 		setTimeStatisticsHaveSupply(i, 0);
< < 		setTimeStatisticsHaveMinerals(i, 0);
< < 		setTimeStatisticsHaveGas(i, 0);
< < 		setTimeStatisticsNeedSupply(i, 0);
< < 		setTimeStatisticsFitness(i, 0);
---
> <  		timeStatistics[getTimer()-i].setNeedSupply(getNeedSupply());
> < 		timeStatistics[getTimer()-i].setHaveSupply(getHaveSupply());
> < 		timeStatistics[getTimer()-i].setHaveMinerals(getMinerals()+harvestMinerals()*i);
> < 		timeStatistics[getTimer()-i].setHaveGas(getGas()+harvestGas()*i);
> < 		timeStatistics[getTimer()-i].setFitness(calculatePrimaryFitness(ready)); // ~~
165,168c387,451
< > 	memset(timeStatistics, 0, MAX_LENGTH * sizeof(STATISTICS));
< > 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));
< 259,276c164,166
< < 	for(int i=MAX_LENGTH;i--;)//ANA~
---
> > 
> > 	for(int i=0;i<t;i++)
> > 	{
> >  		setTimeStatisticsNeedSupply(getTimer()-i, getNeedSupply());
> > 		setTimeStatisticsHaveSupply(getTimer()-i, getHaveSupply());
> > 		setTimeStatisticsHaveMinerals(getTimer()-i, getMinerals()+harvestMinerals()*i);
> > 		setTimeStatisticsHaveGas(getTimer()-i, getGas()+harvestGas()*i);
> > 		setTimeStatisticsFitness(getTimer()-i, calculatePrimaryFitness(ready)); // ~~
> > 	} 
> 299,300c398,399
> < 	bool foundAnother = true;
> < 	while((!buildingQueue.empty()) && (foundAnother == true))
> ---
> > 	bool foundAnother=true;
> > 	while((!buildingQueue.empty())&&(foundAnother==true))
> 304c403
> < 			foundAnother = true;
> ---
> > 			foundAnother=true;
> 306c405
> < 			const UNIT_STATISTICS* stat = &((*pStats)[build.getType()]);
> ---
> > 			const UNIT_STATISTICS* stat=&((*pStats)[build.getType()]);
> 309c408
> < 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2, build.getUnitCount());
> ---
> > 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2);			
> 311,312c410,411
> < 			addLocationTotal(build.getLocation(), build.getType(), build.getUnitCount());
> < 			addLocationAvailible(build.getLocation(), build.getType(), build.getUnitCount());
> ---
> > 			addLocationTotal(build.getLocation(),build.getType(), build.getUnitCount());
> > 			addLocationAvailible(build.getLocation(),build.getType(),build.getUnitCount());
> 317c416
> < 			if(build.getType() == REFINERY) {
> ---
> > 			if(build.getType()==REFINERY) {
> 321c420
> < 			if((build.getType() == COMMAND_CENTER)&&(!getLocationTotal(build.getLocation(), COMMAND_CENTER))) {
> ---
> > 			if((build.getType()==COMMAND_CENTER)&&(!getLocationTotal(build.getLocation(),COMMAND_CENTER))) {
> 326c425
> < 			if((build.getType() == LARVA) && (getpGoal()->getRace() == ZERG)) {
> ---
> > 			if((build.getType()==LARVA)&&(getpGoal()->getRace()==ZERG)) {
> 334c433
> < 			ready = calculateReady();
> ---
> > 			ready=calculateReady();
> 358,361c457,460
> < //			setProgramFacility(build.getIP(), build.getFacility());
> < //			setProgramIsBuilt(build.getIP(), true);
> < //			setProgramLocation(build.getIP(), build.getLocation());
> < //			setProgramBT(build.getIP(), build.getTotalBuildTime()); //~~~
> ---
> > 			setProgramFacility(build.getIP(), build.getFacility());
> > 			setProgramIsBuilt(build.getIP(),true);
> > 			setProgramLocation(build.getIP(),build.getLocation());
> > 			setProgramBT(build.getIP(),build.getTotalBuildTime()); //~~~
> 366c465
> < 		else foundAnother = false;
> ---
> > 		else foundAnother=false;
> 568,571d666
> < const bool ANARACE::buildIt(const unsigned int build_unit)
170,174c453,463
< < 		setProgramSuccessType(i, 0);
< < 		setProgramSuccessUnit(i, 0);
< < 		setProgramIsBuilt(i, false);
< < 		setProgramTime(i, 0);
< < 		for(int j=UNIT_TYPE_COUNT;j--;)
---
> < 	//Zuerst: availible pruefen ob am Ort gebaut werden kann
> < 	//Wenn nicht => +/- absteigen bis alle locations durch sind
> 573,728d667
> < 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> < 	bool ok = false;
> < 	unsigned int picked_facility = 0;
> < 	unsigned int current_location_window = 1; // TODO
> < //	unsigned int ttloc=0;
> < //	unsigned int j=0;
> < 
> < /*	if(lastcounter>0)
176,177c465,491
< < 			setProgramAvailibleCount(i, j, 0);
< < 			setProgramTotalCount(i, j, 0);
---
> < 		lastcounter--;
> < 		tloc=last[lastcounter].location;
> < 	}*/
> < 
> < 	if(stat->facility[0]==0)
> < 		ok=true;
> < 	else
> < 	// special rule for morphing units of protoss
> < 	if((stat->facility2>0) && ((stat->facilityType == IS_LOST) || (stat->facilityType == IS_MORPHING)) && (stat->facility[0] == stat->facility2))
> < 	{
> < 		if(getLocationAvailible(current_location_window, stat->facility2) >=2)
> < 		{
> < 			ok = true;
> < 			picked_facility = 0;
> < 		}
> < 	} else
> < 	{
> < 		// research/upgrade:
> < 		if((stat->facility2==0) || (getLocationAvailible(current_location_window, stat->facility2)>=1))
> < 		{
> < 		// pick one availible facility: 
> < 			for(picked_facility = 0; picked_facility<3; picked_facility++)
> < 				if((stat->facility[picked_facility]>0)&&(getLocationAvailible(current_location_window, stat->facility[picked_facility])>0))
> < 				{
> < 					ok=true;
> < 					break;
> < 				}
179,184d492
< < 		//program[i].temp=0;
< < 		setProgramLocation(i,0);
< < //		setProgramIsGoal(i,false);
< < 		setProgramFacility(i,0);
< < 		setProgramBT(i,0);
< < 		phaenoCode[i]=0;
186,195d493
< ---
< > 	std::list<PROGRAM>::iterator i = programList.begin();
< > 	while(i!=programList.end())
< > 		i = programList.erase(i);	
< 310,315c200,204
< < 		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
< < 		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
< < 		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
< < 		setTimeStatisticsHaveGas(getTimer(), getGas());
< < 		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
197,203c495,509
< ---
< > //		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
< > //		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
< > //		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
< > //		setTimeStatisticsHaveGas(getTimer(), getGas());
< > //		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
< 319d207
---
> < //				j=1;
> < 				// none found? search other parts of the map... TODO
> < /*				if(!ok)
> < 					while(j<MAX_LOCATIONS)
> < 					{
> < 						ttloc=(*pMap)->getLocation(tloc)->getNearest(j);
> < //						if((stat->facility2==0)||(getLocationAvailible(ttloc,stat->facility2)>0)) TODO
> < //						{
> < //						for(fac=3;fac--;)
> < 						for(fac=0;fac<3; fac++)
> < 						if(
> < 						// special rules for morphing units of protoss
> < 						((stat->facilityType != IS_LOST) || (stat->facility[fac] != stat->facility2) || (getLocationAvailible(ttloc, stat->facility[fac]) >= 2)) &&
> < 						((stat->facility[fac] > 0) && (getLocationAvailible(ttloc, stat->facility[fac])))
> < 						|| ((stat->facility[fac]==0)&&(fac==0))) //~~
205,213c511,625
< 325a214,236
< > 		unsigned int code = getpGoal()->toPhaeno(getCurrentCode());
< > 		if((code >= BUILD_PARALLEL_2) && (code <= BUILD_PARALLEL_16))
< >                 {
< >                         setIP(getIP()-1);
< >                         while((getpGoal()->toPhaeno(getCurrentCode()) > GAS_SCV)&&(getIP()))
< >                                 setIP(getIP()-1);
< >                         PARALLEL_COMMAND* pcommand = new PARALLEL_COMMAND;
< >                         switch(code)
---
> < //					  for(fac=3;fac--;)
> < //						  if( ((stat->facility[fac]>0)&&(getLocationAvailible(ttloc,stat->facility[fac])>((stat->facilityType==IS_LOST)&&(stat->facility[fac]==stat->facility2)))) || ((stat->facility[fac]==0)&&(fac==0)))
> < 							{
> < 								tloc=ttloc;
> < 								ok=true;
> < 								break;
> < 							}
> < //						  break;
> < //					  }
> < 						j++;
> < 					}*/
> < 																													   
> < 	if((ok)&&(build_unit==REFINERY)) {
> < 		if(getMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR) <=0)
> < 			ok=false;
> < 		else
> < 			removeOneMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR);
> < 	}
> < //TODO: Wenn verschiedene facilities moeglich sind, dann das letzte nehmen
> < //			  bewegliche Sachen ueberdenken...
> < //				  evtl zusaetzliche Eigenschaft 'speed' einbauen (muss sowieso noch...)... bei speed>0 ... mmmh... trifft aber auch nur auf scvs zu ... weil bringt ja wenig erst mit der hydra rumzulaufen und dann zum lurker... mmmh... aber waere trotzdem zu ueberlegen...
> < //				  auch noch ueberlegen, wenn z.B. mit scv ohne kommandozentrale woanders gesammelt wird...
> < //	  Phagen ueber Phagen...
> < 	if(ok)
> < 	{ 
> <  		if((getpGoal()->getRace()==ZERG) &&
> < //		  ((*pStats)[build_unit].facility[0]==LARVA)&&
> < 			(build_unit!=LARVA) &&
> < 		// Larva wird benoetigt zum Bau? Fein, dann bauen wir eine neue Larva falls nicht schon alle hatcheries etc. belegt sidn
> < 				// Gesamtzahl der Larven < 3 * HATCHERY?
> < 		   ((getLocationTotal(current_location_window, HATCHERY)+
> < 			 getLocationTotal(current_location_window, LAIR)+
> < 			 getLocationTotal(current_location_window, HIVE)) *3 > 
> < 			 (larvaInProduction[current_location_window]+getLocationTotal(current_location_window, LARVA)))  &&
> < // max 1 larva pro Gebaeude produzieren
> <  		   ((getLocationTotal(current_location_window, HATCHERY)+
> < 			 getLocationTotal(current_location_window, LAIR)+
> < 			 getLocationTotal(current_location_window, HIVE) > 
> < 			  larvaInProduction[current_location_window]))) // => zuwenig Larven da!
> < 			{
> < 				addLarvaToQueue(current_location_window);
> < 				if(!buildIt(LARVA));
> < //					removeLarvaFromQueue(current_location_window);
> < 			}
> < 
> < 																												  
> < 		Building build;
> < 		build.setOnTheRun(false);
> < 		build.setFacility(stat->facility[picked_facility]);
> < 		build.setLocation(current_location_window);
> < 		if(build_unit == FROM_GAS_TO_MINERALS)
> < 			build.setUnitCount(getLocationAvailible(current_location_window, GAS_SCV));
> < 		else
> < 			build.setUnitCount(1+(stat->create == build_unit));
> < 		build.setBuildFinishedTime(getTimer()-stat->BT);
> < 		build.setTotalBuildTime(stat->BT);
> < 		build.setType(build_unit);
> < 		buildingQueue.push(build);
> < 
> < 		PROGRAM program;
> < //		for(unsigned int i = UNIT_TYPE_COUNT; i--;)
> < //		{
> < //			program.setTotalCount(i, getLocationTotal(GLOBAL, i));
> < //			program.setAvailibleCount(i, getLocationAvailible(GLOBAL, i));
> < //		}
> < 		program.setUnit(build_unit);
> < 		program.setTime(getTimer());
> < 		program.setFacility(build.getFacility());
> < 		program.setLocation(build.getLocation());
> < 		program.setBT(build.getTotalBuildTime());
> < 	/*	if(successType>0)
> < 		{
> < 			program.setSuccessType(successType);
> < 			program.setSuccessUnit(successUnit);
> < 		}*/ //?
> < 	
> < 		program.before.setNeedSupply(getNeedSupply());
> < 		program.before.setHaveSupply(getHaveSupply());
> < 		program.before.setHaveMinerals(getMinerals());
> < 		program.before.setHaveGas(getGas());
> < 
> < // upgrade_cost is 0 if it's no upgrade
> < 		setMinerals(getMinerals()-(stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> < 		setGas(getGas()-(stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> < 		setNeedSupply(getNeedSupply()+stat->needSupply);
> < //		if((stat->needSupply>0)||(((*pStats)[stat->facility[0]].needSupply<0)&&(stat->facilityType==IS_LOST)))  TODO!!!!
> < //		setNeedSupply(getNeedSupply()-stat->needSupply); //? Beschreibung!
> < 		adjustAvailibility(current_location_window, picked_facility, stat);
> < 		
> < 		program.after.setNeedSupply(getNeedSupply());
> < 		program.after.setHaveSupply(getHaveSupply());
> < 		program.after.setHaveMinerals(getMinerals());
> < 		program.after.setHaveGas(getGas());
> < 
> < 		program.setUsedFacilityCount(getLocationTotal(GLOBAL, stat->facility[picked_facility]) - getLocationAvailible(GLOBAL, stat->facility[picked_facility])); // TODO evtl nach Ort
> < 
> <                	programList.push_back(program);
> < 
> < 	} //end if(ok)
> < 	return(ok);
> < }
> 838a778,783
> > 
> > 
> > 
> > 
> > 
> > 
> diff ./anarace.hpp /home/claw/work/sc1063b/sc/core/anarace.hpp
> 5,6c5,37
> < #include "program.hpp"
> < #include "statistics.hpp"
> ---
> > 
> > class STATISTICS
215,221c627,636
< >                                 case BUILD_PARALLEL_2:pcommand->count = 2;break;
< >                                 case BUILD_PARALLEL_4:pcommand->count = 4;break;
< >                                 case BUILD_PARALLEL_8:pcommand->count = 8;break;
< >                                 case BUILD_PARALLEL_16:pcommand->count = 16;break;
< >                                 default:break; // ~~
< >                         }
< >                         pcommand->unit = getpGoal()->toPhaeno(getCurrentCode());
---
> > 	public:
> > 		STATISTICS();
> > 		~STATISTICS();
> > 		void resetData();
> > 		unsigned int needSupply;		// supply that is used up by all units
> > 		unsigned int haveSupply;		// total supply of supply buildings (overlord, supply depot, command center, ...)
> > 		unsigned int minerals;			// minerals at that time
> > 		unsigned int gas;			// gas at that time
> > 		unsigned int fitness;	//fitness at that time
> > };
223,227c638
< >                         if(getIP()) 
< > 				setIP(getIP()-1);
< >                         parallelCommandQueues.push_back(pcommand);
< >                         ok = true;
< >                 } else
---
> > struct PROGRAM
229,240c640,703
< 329,333d239
< < 		setIPStatisticsNeedSupply(getIP()*2+1, getNeedSupply());
< < 		setIPStatisticsHaveSupply(getIP()*2+1, getHaveSupply());
< < 		setIPStatisticsHaveMinerals(getIP()*2+1, getMinerals());
< < 		setIPStatisticsHaveGas(getIP()*2+1, getGas());
< < 		setIPStatisticsFitness(getIP()*2+1, calculatePrimaryFitness(ready));
< 337,348d242
< < 		setIPStatisticsNeedSupply(getIP()*2, getNeedSupply());
< < 		setIPStatisticsHaveSupply(getIP()*2, getHaveSupply());
< < 		setIPStatisticsHaveMinerals(getIP()*2, getMinerals());
< < 		setIPStatisticsHaveGas(getIP()*2, getGas());
< < 		setIPStatisticsFitness(getIP()*2, calculatePrimaryFitness(ready));
---
> > 	public:
> > 		PROGRAM();
> > 		~PROGRAM();
> > 		void resetData();		
> > 		bool built;			// was this order successfully built?
> > 		unsigned int time;			// at which time this order was started
> > 		unsigned int location;		// at which location was this unit built
> > 		unsigned int successType;	// type of error
> > 		unsigned int successUnit;	// unit number
> > 	//	int isGoal;			// is this unit part of the goal list? DOES NOT WORK YET :)
> > 		unsigned int forceCount[UNIT_TYPE_COUNT];
> > 		unsigned int availibleCount[UNIT_TYPE_COUNT];
> > 		unsigned int facility; 	// where it was produced
> > 		unsigned int BT;		//real buildtime, incl. moving scv etc.
> > //		int isConstant; //this build order may not be moved. In addition no order may be inserted before the order, if the previous order is also constant.
> > // TODO: Zeitfenster machen!
> > };
> 9a41,83
> > 	private:
> > 		unsigned int unitsTotal; // total number of all unit types at the end
> > 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
> > 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
> > 		unsigned int unchangedGenerations;
> > 		unsigned int currentRun;
> > 		bool optimizing;
> > 		bool active;
> > 		unsigned int totalGeneration;
> > 		unsigned int maxpFitness;
> > 		unsigned int maxsFitness;
> > 		unsigned int maxtFitness;
> > 		unsigned int timePercentage;
> > 		unsigned int goalPercentage;
> > 		unsigned int currentpFitness;
> > 		unsigned int averageLength;
> > 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
> > 
> > 		PROGRAM program[MAX_LENGTH];
> > 		STATISTICS ipStatistics[2*MAX_LENGTH]; // before and after command!
> > 		STATISTICS timeStatistics[MAX_TIME];
> > 	
> > //		const bool* fixed;
> > 		
> > 		static unsigned int successType; //type of error
> > 		static unsigned int successUnit; //unit number
> > 
> > 		void setCurrentpFitness(unsigned int current_pfitness);
> > 		
> > 		const bool buildGene(const unsigned int build_unit);
> > 
> > 		void setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply);
> > 		void setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply);
> > 		void setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness);
> > 		void setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals);
> > 		void setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas);
> > 
> > 		void setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply);
> > 		void setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply);
> > 		void setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness);
> > 		void setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals);
> > 		void setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas);
> > 		
> 38,40d111
> < 		std::list<PROGRAM>& getProgramList();
> < 		STATISTICS* getTimeStatistics();
242,246c705,707
< < 		if(successType>0)
< < 		{
< < 			setProgramSuccessType(getIP(), successType);
< < 			setProgramSuccessUnit(getIP(), successUnit);
< < 		}
---
> 52a124
> > //		const bool getProgramIsConstant(const unsigned int ip) const;
> 56c128,153
248,256c709,789
< 352,365c246,247
< < 		if((ok)||(!getTimeOut())) {
< < 			if(ok) {
< < 				setProgramTime(getIP(), getTimer());
< < 			} else {
< < 				setProgramTime(getIP(),configuration.getMaxTime());
< < 				setProgramSuccessType(getIP(), TIMEOUT_ERROR);
< < 				setProgramSuccessUnit(getIP(), 0);
< < //				setProgramSuccessLocation(0);
---
> ---
> > 		const unsigned int getProgramSuccessType(const unsigned int ip) const;	// determines the type of the last error before the item was built at that IP
> > 		const unsigned int getProgramSuccessUnit(const unsigned int ip) const;	// what unit was missing? (connected to successtype)
> > 		
> > 		const unsigned int getIPStatisticsNeedSupply(const unsigned int ip) const;	// supply that is used up by all units
> > 		const unsigned int getIPStatisticsHaveSupply(const unsigned int ip) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
> > 		const unsigned int getIPStatisticsFitness(const unsigned int ip) const;
> > 		const unsigned int getIPStatisticsHaveMinerals(const unsigned int ip) const; // minerals at that time
> > 		const unsigned int getIPStatisticsHaveGas(const unsigned int ip) const;		// gas at that time
> > 
> > 		const unsigned int getTimeStatisticsNeedSupply(const unsigned int time) const;	// supply that is used up by all units
> > 		const unsigned int getTimeStatisticsHaveSupply(const unsigned int time) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
> > 		const unsigned int getTimeStatisticsFitness(const unsigned int time) const;
> > 		const unsigned int getTimeStatisticsHaveMinerals(const unsigned int time) const; // minerals at that time
> > 		const unsigned int getTimeStatisticsHaveGas(const unsigned int time) const;		// gas at that time
> > 
> > 		const bool getProgramIsBuilt(const unsigned int ip) const;		// was this order successfully built?
> > 
> > 		const unsigned int getProgramTime(const unsigned int ip) const;			// at which time this order was started
> > 		const unsigned int getRealProgramTime(const unsigned int ip) const;			// at which time this order was started
> > 		const unsigned int getProgramLocation(const unsigned int ip) const;		// at which location was this unit built
> > //		const bool getProgramIsGoal(const unsigned int ip) const;		// is this unit part of the goal list? NOT YET WORKING!
> > 		const unsigned int getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const;	// how many units of the type at phaenoCode[s] do exist at that time?
> > 		const unsigned int getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const;	 // how many units of the type at phaenoCode[s] do exist at that time?
> > 
> > 		const unsigned int getProgramFacility(const unsigned int ip) const;
> > 		const unsigned int getProgramBT(const unsigned int ip) const;
> 63,64c160,161
> < 		const unsigned int getMaxtFitness() const;
> < 		
> ---
> > 		const unsigned int getMaxtFitness() const;			// gets tertiary fitness (build order appearance, some heuristics)
> > 
> 76a174,185
> > //		void setProgramIsConstant(const unsigned int ip, const bool isConstant);
> > 		void setProgramFacility(const unsigned int ip, const unsigned int program_facility);
> > 		void setProgramBT(const unsigned int ip, const unsigned int program_bt);
> > 		void setProgramSuccessType(const unsigned int ip, const unsigned int program_success_type);
> > 		void setProgramSuccessUnit(const unsigned int ip, const unsigned int program_success_unit);
> > 		void setProgramIsBuilt(const unsigned int ip, const bool program_is_built);
> > 		void setProgramLocation(const unsigned int ip, const unsigned int program_location);
> > 		void setProgramTime(const unsigned int ip, const unsigned int program_time);
> > //		void setProgramIsGoal(const unsigned int ip, const bool isGoal);	
> > 		void setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);	
> > 		void setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);
> > 
> 83,110d191
> < 	
> < 		std::list<PROGRAM> programList; // TODO private machen
> < 	private:
> < 		unsigned int unitsTotal; // total number of all unit types at the end
> < 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
> < 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
> < 		unsigned int unchangedGenerations;
> < 		unsigned int currentRun;
> < 		bool optimizing;
> < 		bool active;
> < 		unsigned int totalGeneration;
> < 		unsigned int maxpFitness;
> < 		unsigned int maxsFitness;
> < 		unsigned int maxtFitness;
> < 		unsigned int timePercentage;
> < 		unsigned int goalPercentage;
> < 		unsigned int currentpFitness;
> < 		unsigned int averageLength;
> < 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
> < 
> < 		STATISTICS timeStatistics[MAX_TIME];
> < 
> < //		const bool* fixed;
> < 		
> < 		static unsigned int successType; //type of error
> < 		static unsigned int successUnit; //unit number
> < 
> < 		void setCurrentpFitness(unsigned int current_pfitness);
> 112,113d192
> < 		const bool buildGene(const unsigned int build_unit);
> < 		const bool buildIt(const unsigned int build_unit);
> 130,138c209,210
> < inline std::list<PROGRAM>& ANARACE::getProgramList() {
> < 	return(programList);
258,260c791,793
< < 			for(int i=UNIT_TYPE_COUNT;i--;)	{
< < 				setProgramTotalCount(getIP(), i, getLocationTotal(GLOBAL, i));
< < 				setProgramAvailibleCount(getIP(),i,getLocationAvailible(GLOBAL, i));
---
> < 
> < inline STATISTICS* ANARACE::getTimeStatistics() {
> < 	return(timeStatistics);
262a796
> < inline const unsigned int ANARACE::getAverageLength() const {
264c798
< > 			if((ok) || (!getTimeOut())) 
---
> > inline const unsigned int ANARACE::getAverageLength() const
266,267c800,815
< 368a251,266
< >                 	else if(!ok)
---
> 145c217
> < 	if(unitsTotalMax > MAX_TOTAL_UNITS*UNIT_TYPE_COUNT * MAX_LOCATIONS) {
> ---
> > 	if(unitsTotalMax>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT*MAX_LOCATIONS) {
> 155c227
> < 	if(nonGoalsUnitsTotalMax>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT * MAX_LOCATIONS) {
> ---
> > 	if(nonGoalsUnitsTotalMax>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT*MAX_LOCATIONS) {
> 165c237
> < 	if(unitsTotal>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT * MAX_LOCATIONS) {
> ---
> > 	if(unitsTotal>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT*MAX_LOCATIONS) {
> 172c244,245
> < inline const bool ANARACE::isActive() const {
> ---
> > inline const bool ANARACE::isActive() const
269,271c817,821
< > // TEST FOR PARALLEL COMMANDQUEUES
< >         	                std::list<PARALLEL_COMMAND*>::iterator command = parallelCommandQueues.begin(); 
< >                 	        while(command != parallelCommandQueues.end())
---
> 176,177c249,251
> < inline void ANARACE::setActive(const bool set_active) {
> < 	active = set_active;
> ---
> > inline void ANARACE::setActive(const bool set_active)
273,274c823,827
< >                                 	ok = buildGene((*command)->unit);
< > 	                                if(ok)  
---
> > 	active=set_active;
> 180c254,255
> < inline const bool ANARACE::isOptimizing() const {
> ---
> > inline const bool ANARACE::isOptimizing() const
276,279c829,841
< >                 	                        (*command)->count--;
< >                         	                if(!(*command)->count)
< >                                 	                command = parallelCommandQueues.erase(command);
< >                 	                } else command++;
---
> 184,185c259,261
> < inline void ANARACE::setOptimizing(const bool set_optimizing) {
> < 	optimizing = set_optimizing;
> ---
> > inline void ANARACE::setOptimizing(const bool set_optimizing)
> > {
> > 	optimizing=set_optimizing;
> 187a264,278
> > inline const unsigned int ANARACE::getProgramFacility(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(ip >= MAX_LENGTH) {
> > 		toLog("DEBUG: (ANARACE::getProgramFacility): Value ip out of range.");return(0);
280a843,844
> > 	if(program[ip].facility >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::getProgramFacility): Variable not initialized.");return(0);
281a846,863
> > #endif
> > //	if((getRace()==PROTOSS)&&(program[ip].facility==PROBE))
> > //		while(true);
> > 
> > 	return(program[ip].facility);
> > }
> 188a280,739
> > inline const unsigned int ANARACE::getProgramBT(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramBT): Value ip out of range.");return(0);
> > 	}
> > 	if(program[ip].BT >= MAX_TIME) {
> > 		toLog("DEBUG: (ANARACE::getProgramBT): Variable not initialized.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].BT);
283,295d864
< 372c270
< < 	int t=calculateIdleTime();
< ---
< > 	unsigned int t = calculateIdleTime();
< 376c274,281
< < 	for(int i=0;i<t;i++)
< ---
< > //	if(t>0)
< > //	{
< > //		setProgramSuccessType(getIP(), TIMEOUT_ERROR);
< > //		setProgramSuccessUnit(getIP(), 0); TODO
< > //		setProgramSuccessLocation(0);
< > //	}
297,325c866
< > 	for(unsigned int i = t; i--;)
< 378,382c283,287
< <  		setTimeStatisticsNeedSupply(getTimer()-i, getNeedSupply());
< < 		setTimeStatisticsHaveSupply(getTimer()-i, getHaveSupply());
< < 		setTimeStatisticsHaveMinerals(getTimer()-i, getMinerals()+harvestMinerals()*i);
< < 		setTimeStatisticsHaveGas(getTimer()-i, getGas()+harvestGas()*i);
< < 		setTimeStatisticsFitness(getTimer()-i, calculatePrimaryFitness(ready)); // ~~
< ---
< >  		timeStatistics[getTimer()-i].setNeedSupply(getNeedSupply());
< > 		timeStatistics[getTimer()-i].setHaveSupply(getHaveSupply());
< > 		timeStatistics[getTimer()-i].setHaveMinerals(getMinerals()+harvestMinerals()*i);
< > 		timeStatistics[getTimer()-i].setHaveGas(getGas()+harvestGas()*i);
< > 		timeStatistics[getTimer()-i].setFitness(calculatePrimaryFitness(ready)); // ~~
< 408c313
< < 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2);			
< ---
< > 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2, build.getUnitCount());
< 457,460c362,365
< < 			setProgramFacility(build.getIP(), build.getFacility());
< < 			setProgramIsBuilt(build.getIP(),true);
< < 			setProgramLocation(build.getIP(),build.getLocation());
< < 			setProgramBT(build.getIP(),build.getTotalBuildTime()); //~~~
< ---
< > //			setProgramFacility(build.getIP(), build.getFacility());
< > //			setProgramIsBuilt(build.getIP(), true);
< > //			setProgramLocation(build.getIP(), build.getLocation());
< > //			setProgramBT(build.getIP(), build.getTotalBuildTime()); //~~~
< 666a572,588
< > const bool ANARACE::buildIt(const unsigned int build_unit)
---
> > inline const unsigned int ANARACE::getProgramSuccessType(const unsigned int ip) const
327,328c868,877
< > 	//Zuerst: availible pruefen ob am Ort gebaut werden kann
< > 	//Wenn nicht => +/- absteigen bis alle locations durch sind
---
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Value ip out of range.");return(0);
> > 	}
> > 	if(program[ip].successType >= ERROR_MESSAGES) {
> > 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Variable not initialized.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].successType);
> > }
330,335c879,890
< > 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
< > 	bool ok = false;
< > 	unsigned int picked_facility = 0;
< > 	unsigned int current_location_window = 1; // TODO
< > //	unsigned int ttloc=0;
< > //	unsigned int j=0;
---
> > inline const unsigned int ANARACE::getProgramSuccessUnit(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Value ip out of range.");return(0);
> > 	}
> > 	if(program[ip].successUnit >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Variable not initialized.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].successUnit);
> > }
337c892
< > /*	if(lastcounter>0)
---
> > /*inline void ANARACE::setProgramIsConstant(const unsigned int ip, const bool isConstant)
339,347c894,900
< > 		lastcounter--;
< > 		tloc=last[lastcounter].location;
< > 	}*/
< 667a590,732
< > 	if(stat->facility[0]==0)
< > 		ok=true;
< > 	else
< > 	// special rule for morphing units of protoss
< > 	if((stat->facility2>0) && ((stat->facilityType == IS_LOST) || (stat->facilityType == IS_MORPHING)) && (stat->facility[0] == stat->facility2))
---
> > 		if((ip >= MAX_LENGTH)) {
> > 				toLog("DEBUG: (ANARACE::setProgramIsConstant): Value ip out of range.");return(0);
> > 		}
> > 		program[ip].isConstant = isConstant;
> > };*/
> > 
> > inline void ANARACE::setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
349c902,916
< > 		if(getLocationAvailible(current_location_window, stat->facility2) >=2)
---
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value ip out of range.");return;
> > 	}
> > 	if(unit_type >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_type out of range.");return;
> > 	}
> > 	if(unit_count >= MAX_TOTAL_UNITS) {
> > 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_count out of range.");return;
> > 	}
> > #endif
> > 	program[ip].availibleCount[unit_type] = unit_count;
> > }
> > 
> > inline void ANARACE::setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
351,352c918,920
< > 			ok = true;
< > 			picked_facility = 0;
---
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value ip out of range.");return;
354c922,933
< > 	} else
---
> > 	if(unit_type >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_type out of range.");return;
> > 	}
> > 	if(unit_count >= MAX_TOTAL_UNITS) {
> > 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_count out of range.");return;
> > 	}
> > #endif
> > 	program[ip].forceCount[unit_type] = unit_count;
> > }
> > 
> > // first time is 0!
> > inline void ANARACE::setProgramTime(const unsigned int ip, const unsigned int program_time)
356,357c935,946
< > 		// research/upgrade:
< > 		if((stat->facility2==0) || (getLocationAvailible(current_location_window, stat->facility2)>=1))
---
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramTime): Value ip out of range.");return;
> > 	}
> > 	if(program_time > configuration.getMaxTime()) {
> > 		toLog("DEBUG: (ANARACE::setProgramTime): Value program_time out of range.");return;
> > 	}
> > #endif
> > 	program[ip].time = program_time;
> > }
> > 
> > inline void ANARACE::setProgramBT(const unsigned int ip, const unsigned int program_bt)
359,361c948,959
< > 		// pick one availible facility: 
< > 			for(picked_facility = 0; picked_facility<3; picked_facility++)
< > 				if((stat->facility[picked_facility]>0)&&(getLocationAvailible(current_location_window, stat->facility[picked_facility])>0))
---
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramBT): Value ip out of range.");return;
> > 	}
> > 	if(program_bt >= MAX_TIME) {
> > 		toLog("DEBUG: (ANARACE::setProgramBT): Value program_bt out of range.");return;
> > 	}
> > #endif
> > 	program[ip].BT = program_bt;
> > }
> > 
> > inline void ANARACE::setProgramIsBuilt(const unsigned int ip, const bool program_is_built)
363,364c961,979
< > 					ok=true;
< > 					break;
---
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramIsBuilt): Value ip out of range.");return;
> > 	}
> > #endif
> > 	program[ip].built = program_is_built;
> > }
> > 
> > inline void ANARACE::setProgramLocation(const unsigned int ip, const unsigned int program_location)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramLocation): Value ip out of range.");return;
> > 	}
> > 	if(program_location >= MAX_LOCATIONS) {
> > 		toLog("DEBUG: (ANARACE::setProgramLocation): Value program_location out of range.");return;
> > 	}
> > #endif
> > 	program[ip].location = program_location;
365a981,989
> > // ------ STATISTICS SET FUNCTIONS ------
> > inline void ANARACE::setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply)
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value ip out of range.");return;
> >     }
> > 	if(need_supply > 10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value need_supply out of range.");return;
366a991,992
> > #endif
> > 	ipStatistics[ip].needSupply = need_supply;
369,372c995
< > //				j=1;
< > 				// none found? search other parts of the map... TODO
< > /*				if(!ok)
< > 					while(j<MAX_LOCATIONS)
---
> > inline void ANARACE::setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply)
374,383c997,1006
< > 						ttloc=(*pMap)->getLocation(tloc)->getNearest(j);
< > //						if((stat->facility2==0)||(getLocationAvailible(ttloc,stat->facility2)>0)) TODO
< > //						{
< > //						for(fac=3;fac--;)
< > 						for(fac=0;fac<3; fac++)
< > 						if(
< > 						// special rules for morphing units of protoss
< > 						((stat->facilityType != IS_LOST) || (stat->facility[fac] != stat->facility2) || (getLocationAvailible(ttloc, stat->facility[fac]) >= 2)) &&
< > 						((stat->facility[fac] > 0) && (getLocationAvailible(ttloc, stat->facility[fac])))
< > 						|| ((stat->facility[fac]==0)&&(fac==0))) //~~
---
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value ip out of range.");return;
> >     }
> > 	if(have_supply > 10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value have_supply out of range.");return;
> > 	}
> > #endif
> > 	ipStatistics[ip].haveSupply = have_supply;
> > }
385,386c1008
< > //					  for(fac=3;fac--;)
< > //						  if( ((stat->facility[fac]>0)&&(getLocationAvailible(ttloc,stat->facility[fac])>((stat->facilityType==IS_LOST)&&(stat->facility[fac]==stat->facility2)))) || ((stat->facility[fac]==0)&&(fac==0)))
---
> > inline void ANARACE::setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals)
388,390c1010,1018
< > 								tloc=ttloc;
< > 								ok=true;
< > 								break;
---
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value ip out of range.");return;
> >     }
> > 	if(have_minerals >= MAX_MINERALS) {
> > 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value have_minerals out of range.");return;
> > 	}
> > #endif
> > 	ipStatistics[ip].minerals = have_minerals;
392,395d1019
< > //						  break;
< > //					  }
< > 						j++;
< > 					}*/
397,401c1021,1025
< > 	if((ok)&&(build_unit==REFINERY)) {
< > 		if(getMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR) <=0)
< > 			ok=false;
< > 		else
< > 			removeOneMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR);
---
> > inline void ANARACE::setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas)
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value ip out of range.");return;
403,408c1027,1034
< > //TODO: Wenn verschiedene facilities moeglich sind, dann das letzte nehmen
< > //			  bewegliche Sachen ueberdenken...
< > //				  evtl zusaetzliche Eigenschaft 'speed' einbauen (muss sowieso noch...)... bei speed>0 ... mmmh... trifft aber auch nur auf scvs zu ... weil bringt ja wenig erst mit der hydra rumzulaufen und dann zum lurker... mmmh... aber waere trotzdem zu ueberlegen...
< > //				  auch noch ueberlegen, wenn z.B. mit scv ohne kommandozentrale woanders gesammelt wird...
< > //	  Phagen ueber Phagen...
< > 	if(ok)
---
> > 	if(have_gas >= MAX_GAS) {
> > 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value have_gas out of range.");return;
> > 	}
> > #endif
> > 	ipStatistics[ip].gas = have_gas;
> > }
> > 
> > inline void ANARACE::setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness)
410,423c1036,1048
< >  		if((getpGoal()->getRace()==ZERG) &&
< > //		  ((*pStats)[build_unit].facility[0]==LARVA)&&
< > 			(build_unit!=LARVA) &&
< > 		// Larva wird benoetigt zum Bau? Fein, dann bauen wir eine neue Larva falls nicht schon alle hatcheries etc. belegt sidn
< > 				// Gesamtzahl der Larven < 3 * HATCHERY?
< > 		   ((getLocationTotal(current_location_window, HATCHERY)+
< > 			 getLocationTotal(current_location_window, LAIR)+
< > 			 getLocationTotal(current_location_window, HIVE)) *3 > 
< > 			 (larvaInProduction[current_location_window]+getLocationTotal(current_location_window, LARVA)))  &&
< > // max 1 larva pro Gebaeude produzieren
< >  		   ((getLocationTotal(current_location_window, HATCHERY)+
< > 			 getLocationTotal(current_location_window, LAIR)+
< > 			 getLocationTotal(current_location_window, HIVE) > 
< > 			  larvaInProduction[current_location_window]))) // => zuwenig Larven da!
---
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value ip out of range.");return;
> >     }
> > 	if(fitness > MAX_PFITNESS) {
> > 		toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value fitness out of range.");return;
> > 	}
> > #endif
> > 	ipStatistics[ip].fitness = fitness;
> > }
> > 
> > 
> > inline void ANARACE::setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply)
425,427c1050,1058
< > 				addLarvaToQueue(current_location_window);
< > 				if(!buildIt(LARVA));
< > //					removeLarvaFromQueue(current_location_window);
---
> > #ifdef _SCC_DEBUG
> >     if((time>=MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value time out of range.");return;
> >     }
> > 	if(need_supply>10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value need_supply out of range.");return;
> > 	}
> > #endif
> > 	timeStatistics[time].needSupply = need_supply;
429a1061,1072
> > inline void ANARACE::setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply)
> > {
> > #ifdef _SCC_DEBUG
> >     if((time>=MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value time out of range.");return;
> >     }
> > 	if(have_supply>10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value have_supply out of range.");return;
> > 	}
> > #endif
> > 	timeStatistics[time].haveSupply = have_supply;
> > }
431,442c1074,1085
< > 		Building build;
< > 		build.setOnTheRun(false);
< > 		build.setFacility(stat->facility[picked_facility]);
< > 		build.setLocation(current_location_window);
< > 		if(build_unit == FROM_GAS_TO_MINERALS)
< > 			build.setUnitCount(getLocationAvailible(current_location_window, GAS_SCV));
< > 		else
< > 			build.setUnitCount(1+(stat->create == build_unit));
< > 		build.setBuildFinishedTime(getTimer()-stat->BT);
< > 		build.setTotalBuildTime(stat->BT);
< > 		build.setType(build_unit);
< > 		buildingQueue.push(build);
---
> > inline void ANARACE::setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals)
> > {
> > #ifdef _SCC_DEBUG
> >     if((time >= MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value time out of range.");return;
> >     }
> > 	if(have_minerals >= MAX_MINERALS) {
> > 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value have_minerals out of range.");return;
> > 	}
> > #endif
> > 	timeStatistics[time].minerals = have_minerals;
> > }
444,455c1087
< > 		PROGRAM program;
< > //		for(unsigned int i = UNIT_TYPE_COUNT; i--;)
< > //		{
< > //			program.setTotalCount(i, getLocationTotal(GLOBAL, i));
< > //			program.setAvailibleCount(i, getLocationAvailible(GLOBAL, i));
< > //		}
< > 		program.setUnit(build_unit);
< > 		program.setTime(getTimer());
< > 		program.setFacility(build.getFacility());
< > 		program.setLocation(build.getLocation());
< > 		program.setBT(build.getTotalBuildTime());
< > 	/*	if(successType>0)
---
> > inline void ANARACE::setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas)
457,459c1089,1098
< > 			program.setSuccessType(successType);
< > 			program.setSuccessUnit(successUnit);
< > 		}*/ //?
---
> > #ifdef _SCC_DEBUG
> >     if((time >= MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value time out of range.");return;
> >     }
> > 	if(have_gas >= MAX_GAS) {
> > 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value have_gas out of range.");return;
> > 	}
> > #endif
> > 	timeStatistics[time].gas = have_gas;
> > }
461,464c1100,1112
< > 		program.before.setNeedSupply(getNeedSupply());
< > 		program.before.setHaveSupply(getHaveSupply());
< > 		program.before.setHaveMinerals(getMinerals());
< > 		program.before.setHaveGas(getGas());
---
> > inline void ANARACE::setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness)
> > {
> > #ifdef _SCC_DEBUG
> >     if((time>=MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value time out of range.");return;
> >     }
> > 	if(fitness>MAX_PFITNESS) {
> > 		toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value fitness out of range.");return;
> > 	}
> > #endif
> > 	timeStatistics[time].fitness=fitness;
> > }
> > // ------ END OF STATISTICS SET FUNCTIONS ------
466,472d1113
< > // upgrade_cost is 0 if it's no upgrade
< > 		setMinerals(getMinerals()-(stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
< > 		setGas(getGas()-(stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
< > 		setNeedSupply(getNeedSupply()+stat->needSupply);
< > //		if((stat->needSupply>0)||(((*pStats)[stat->facility[0]].needSupply<0)&&(stat->facilityType==IS_LOST)))  TODO!!!!
< > //		setNeedSupply(getNeedSupply()-stat->needSupply); //? Beschreibung!
< > 		adjustAvailibility(current_location_window, picked_facility, stat);
474,477c1115,1126
< > 		program.after.setNeedSupply(getNeedSupply());
< > 		program.after.setHaveSupply(getHaveSupply());
< > 		program.after.setHaveMinerals(getMinerals());
< > 		program.after.setHaveGas(getGas());
---
> > inline const unsigned int ANARACE::getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const	   // how many units of the type at phaenoCode[s] do exist at that time?
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value ip out of range.");return(0);
> > 	}
> > 	if(unit_type >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value unit_type out of range.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].forceCount[unit_type]);
> > }
479c1128,1140
< > 		program.setUsedFacilityCount(getLocationTotal(GLOBAL, stat->facility[picked_facility]) - getLocationAvailible(GLOBAL, stat->facility[picked_facility])); // TODO evtl nach Ort
---
> > // how many units of the type at phaenoCode[s] do exist at that time?
> > inline const unsigned int ANARACE::getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const	   
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value ip out of range.");return(0);
> > 	}
> > 	if(unit_type >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value unit_type out of range.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].availibleCount[unit_type]);
> > }
481c1142,1153
< >                	programList.push_back(program);
---
> > inline void ANARACE::setProgramFacility(const unsigned int ip, const unsigned int facility)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramFacility): Value ip out of range.");return;
> > 	}
> > 	if(facility>=UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::setProgramFacility): Value facility out of range.");return;
> > 	}
> > #endif
> > 	program[ip].facility = facility;
> > }
483,484c1155,1159
< > 	} //end if(ok)
< > 	return(ok);
---
> > inline void ANARACE::setProgramSuccessType(const unsigned int ip, const unsigned int type)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value ip out of range.");return;
486c1161,1380
< 778,783d842
---
> > 	if(type >= ERROR_MESSAGES) {
> > 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value type out of range.");return;
> > 	}
> > #endif
> > 	program[ip].successType = type;
> > }
> > 
> > inline void ANARACE::setProgramSuccessUnit(const unsigned int ip, const unsigned int unit_type)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value ip out of range.");return;
> > 	}
> > 	if(unit_type >= UNIT_TYPE_COUNT) {
> > 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value unit_type out of range.");return;
> > 	}
> > #endif
> > 	program[ip].successUnit = unit_type;
> > }
> > 
> > // ------ STATISTICS GET FUNCTIONS ------
> > inline const unsigned int ANARACE::getIPStatisticsNeedSupply(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Value ip out of range.");return(0);
> >     }
> > 	if(ipStatistics[ip].needSupply > 10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Variable ipStatistics.needSupply not initialized.");	return(0);
> > 	}
> > #endif
> > 	return(ipStatistics[ip].needSupply);
> > }
> > 
> > inline const unsigned int ANARACE::getIPStatisticsHaveSupply(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Value ip out of range.");return(0);
> >     }
> > 	if(ipStatistics[ip].haveSupply > 10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Variable ipStatistics.haveSupply not initialized.");return(0);
> > 	}
> > #endif
> > 	return(ipStatistics[ip].haveSupply);
> > }
> > 
> > inline const unsigned int ANARACE::getIPStatisticsHaveMinerals(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> > 	        toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Value ip out of range.");return(0);
> > 	}
> > 	if(ipStatistics[ip].minerals > MAX_MINERALS) {
> > 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Variable ipStatistics.minerals not initialized.");return(0);
> > 	}
> > #endif
> > 	return(ipStatistics[ip].minerals);
> > }
> > 
> > inline const unsigned int ANARACE::getIPStatisticsHaveGas(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Value ip out of range.");return(0);
> >     }
> > 	if(ipStatistics[ip].gas > MAX_GAS) {
> > 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Variable ipStatistics.gas not initialized.");return(0);
> > 	}
> > #endif
> > 	return(ipStatistics[ip].gas);
> > }
> > 
> > inline const unsigned int ANARACE::getIPStatisticsFitness(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((ip >= 2*MAX_LENGTH)) {
> >         toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Value ip out of range.");return(0);
> >     }
> > 	// TODO max pfitness 
> > 	if(ipStatistics[ip].fitness>MAX_PFITNESS) {
> > 		toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Variable ipStatistics.fitness not initialized.");return(0);
> > 	}
> > #endif
> > 	return(ipStatistics[ip].fitness);
> > }
> > 
> > 
> > inline const unsigned int ANARACE::getTimeStatisticsNeedSupply(const unsigned int time) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((time>=MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Value time out of range.");return(0);
> >     }
> > 	if(timeStatistics[time].needSupply>10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Variable timeStatistics.needSupply not initialized.");return(0);
> > 	}
> > #endif
> > 	return(timeStatistics[time].needSupply);
> > }
> > 
> > inline const unsigned int ANARACE::getTimeStatisticsHaveSupply(const unsigned int time) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((time>=MAX_TIME)) {
> >         toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Value time out of range.");return(0);
> >     }
> > 	if(timeStatistics[time].haveSupply>10*MAX_SUPPLY) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Variable timeStatistics.haveSupply not initialized.");return(0);
> > 	}
> > #endif
> > 	return(timeStatistics[time].haveSupply);
> > }
> > 
> > inline const unsigned int ANARACE::getTimeStatisticsHaveMinerals(const unsigned int time) const
> > {
> > #ifdef _SCC_DEBUG
> >     if((time>=MAX_TIME)) {
> > 	        toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Value time out of range.");return(0);
> > 	}
> > 	if(timeStatistics[time].minerals>MAX_MINERALS) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Variable timeStatistics.minerals not initialized.");return(0);
> > 	}
> > #endif
> > 	return(timeStatistics[time].minerals);
> > }
> > inline const unsigned int ANARACE::getTimeStatisticsHaveGas(const unsigned int time) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((time>=MAX_TIME)) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Value time out of range.");return(0);
> > 	}
> > 	if(timeStatistics[time].gas>MAX_GAS) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Variable timeStatistics.gas not initialized.");return(0);
> > 	}
> > #endif
> > 	return(timeStatistics[time].gas);
> > }
> > 
> > inline const unsigned int ANARACE::getTimeStatisticsFitness(const unsigned int time) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((time>=MAX_TIME)) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Value time out of range.");return(0);
> > 	}
> > 	// TODO max pfitness 
> > 	if(timeStatistics[time].fitness>MAX_PFITNESS) {
> > 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Variable timeStatistics.fitness not initialized.");return(0);
> > 	}
> > #endif
> > 	return(timeStatistics[time].fitness);
> > }
> 191c742,800
> < inline const unsigned int ANARACE::getTimePercentage() const {
> ---
> > inline const bool ANARACE::getProgramIsBuilt(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramIsBuilt): Value ip out of range.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].built);
> > }
> > 
> > 
> > /*const bool ANARACE::getProgramIsConstant(const unsigned int ip)
> > {
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramIsConstant): Value ip [%i] out of range.",IP);return(false);
> > 	}
> > 	return(program[ip].isConstant);
> > };*/
> > 
> > // first program time is
> > inline const unsigned int ANARACE::getProgramTime(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramTime): Value ip out of range.");return(0);
> > 	}
> > 	if(program[ip].time > configuration.getMaxTime()) {
> > 		toLog("DEBUG: (ANARACE::getProgramTime): Variable not initialized.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].time);
> > }
> > 
> > inline const unsigned int ANARACE::getRealProgramTime(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
> > 	}
> > #endif
> > 	return(configuration.getMaxTime() - getProgramTime(ip));
> > }
> > 
> > 
> > inline const unsigned int ANARACE::getProgramLocation(const unsigned int ip) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if((ip >= MAX_LENGTH)) {
> > 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
> > 	}
> > 	if(program[ip].location > MAX_LOCATIONS) {
> > 		toLog("DEBUG: (ANARACE::getProgramLocation): Variable program.location not initialized.");return(0);
> > 	}
> > #endif
> > 	return(program[ip].location);
> > }
> > 
> > inline const unsigned int ANARACE::getTimePercentage() const
> > {
> 195c804,805
> < inline const unsigned int ANARACE::getFastestGoalTime() const {
> ---
> > inline const unsigned int ANARACE::getFastestGoalTime() const
> > {
> 198,199c808,809
487a1382,1400
> < inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const {
> ---
> > inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const
> > {
> 296,299c906,909
> < #ifdef _SCC_DEBUG       
> <         if(maxtFitness > MAX_TFITNESS) {
> <                 toLog("DEBUG: (ANARACE::getMaxtFitness): Variable maxtFitness not initialized.");return(0);
> <         }
> ---
> > #ifdef _SCC_DEBUG	
> > 	if(maxtFitness > MAX_TFITNESS) {
> > 		toLog("DEBUG: (ANARACE::getMaxtFitness): Variable maxtFitness not initialized.");return(0);
> > 	}
> 301c911
> <         return(maxtFitness);
> ---
> > 	return(maxtFitness);
> 304d913
488a1402,1445
> 325c934,935
> < inline void ANARACE::setTotalGeneration(const unsigned int total_generation) {
> ---
> > inline void ANARACE::setTotalGeneration(const unsigned int total_generation)
> > {
> 332c942
> < // TODO maxpitness
> ---
> > 	// TODO maxpitness
> 353,355c963,965
> <         if(max_tfitness > MAX_TFITNESS) {
> <                 toLog("DEBUG: (ANARACE::setMaxtFitness): Value out of range.");return;
> <         }
> ---
> > 	if(max_tfitness > MAX_TFITNESS) {
> > 		toLog("DEBUG: (ANARACE::setMaxtFitness): Value out of range.");return;
> > 	}
> 357c967
> <         maxtFitness = max_tfitness;
> ---
> > 	maxtFitness = max_tfitness;
> 358a969
> > //int getProgramSuccessType(int IP);
> Files ./anarace.o and /home/claw/work/sc1063b/sc/core/anarace.o differ
> diff ./basicmap.cpp /home/claw/work/sc1063b/sc/core/basicmap.cpp
> 2d1
> < #include <iostream>
> 26,43d24
> < unsigned int BASIC_MAP::calculateDistance(unsigned int i, unsigned int j)
> < {
> < 	if(i==j)
> < 		return(0);
> < 	if(location[i].getDistance(j) < 9999)
> < 		return(location[i].getDistance(j));
> < 	unsigned int min = 9999;
> < 	for(unsigned int k=1;k<getMaxLocations();k++)
> < 		if(location[i].getDistance(k) < 9999)
> < 		{
> < 			unsigned int temp = location[i].getDistance(k) + calculateDistance(j, k);
> < 			if(temp < min)
> < 				min = temp;
> < 		}
> < 	return(min);	
> < }
490a1448,1452
> 46,71c27
> < 	for(unsigned int i=1;i<getMaxLocations();i++)
> < 		for(unsigned int j=1;j<getMaxLocations();j++)
> < 			if(location[i].getDistance(j) < 9999)
> < 				location[j].setDistance(i, location[i].getDistance(j));
491a1454,1460
> < 	for(unsigned int i = 1; i < getMaxLocations(); i++)
> < 	{
> < 		std::cout << "Location " << i << " ";
> < 		for(unsigned int j = 1; j < getMaxLocations(); j++)
> < 			std::cout << getLocation(i)->getDistance(j) << " ";
> < 		std::cout << std::endl;
> < 	}
493,494c1462,1464
< diff -b -w -d ./anarace.hpp /home/claw/work/sc1064/sc/core/anarace.hpp
< 5,37c5,6
---
> < 	for(unsigned int i=1;i<getMaxLocations();i++)
> < 		for(unsigned int j=1;j<getMaxLocations();j++)
> < 			location[i].setDistance(j, calculateDistance(i, j));
496c1466
< < class STATISTICS
---
> < 	for(unsigned int i = 1; i < getMaxLocations(); i++)
497a1468,1579
> < 		std::cout << "Location " << i << " ";
> < 		for(unsigned int j = 1; j < getMaxLocations(); j++)
> < 			std::cout << getLocation(i)->getDistance(j) << " ";
> < 		std::cout << std::endl;
> < 	}
> < 
> < 	for(unsigned int i=1;i<getMaxLocations();i++)
> ---
> > 	for(int i=1;i<MAX_LOCATIONS;i++)
> diff ./basicmap.hpp /home/claw/work/sc1063b/sc/core/basicmap.hpp
> 17d16
> < 		unsigned int calculateDistance(unsigned int i, unsigned int j);
> 36c35
> < 		void setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance);
> ---
> > 		void setLocationDistance(const unsigned int location_number, std::list<std::string> distances);// needs never be changed so a list is fine
> 75c74
> < 	if((location_number >= maxLocations)) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 85c84
> < 	if((location_number >= maxLocations)) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 95c94
> < 	if((location_number >= maxLocations)) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 105c104
> < 	if((location_number >= maxLocations)) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 115c114
> < 	if((location_number >= maxLocations)) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 125c124
> < 	if((location_number >= maxLocations)) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 132c131
> < inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance)
> ---
> > inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const std::list<std::string> distances)
> 135,136c134,135
> < 	if((location_number >= maxLocations)) {
> < 		toLog("DEBUG: (MAP::setLocationDistance): Value location_number out of range.");return;
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> > 		toLog("DEBUG: (MAP::setLocationDistance): Value out of range.");return;
> 138,139c137,138
> < 	if((target >= maxLocations)) {
> < 		toLog("DEBUG: (MAP::setLocationDistance): Value target out of range.");return;
> ---
> > 	if(location_number >= distances.size()) {
> > 		toLog("DEBUG: (MAP::setLocationDistance): Too many locations.");return;
> 141,144d139
> < //	if(distance >= 1000) {
> < //		toLog("DEBUG: (MAP::setLocationDistance): Value distance out of range.");return;
> < //	}
> < 	
> 146c141,153
> < 	location[location_number].setDistance(target, distance);
> ---
> > 	std::list<std::string>::const_iterator i=distances.begin();
> > 	unsigned int j=0;
> > 	while(i!=distances.end())
> > 	{
> > 		location[location_number].setDistance(j, atoi(i->c_str()));
> > 		i++;
> > 		j++;
> > 	}
> > #ifdef _SCC_DEBUG
> > 	if( j < location_number ) {
> > 		toLog("DEBUG: (MAP::setLocationDistance): Not enough locations.");return;
> > 	}
> > #endif		
> 157d163
> < 	MAP_LOCATION::setMaxLocations(max_locations);
> 173c179
> < 	if(location_number >= maxLocations) {
> ---
> > 	if(location_number >= MAX_LOCATIONS) {
> 179a186,187
> > 
> > 
> Files ./basicmap.o and /home/claw/work/sc1063b/sc/core/basicmap.o differ
> diff ./building.cpp /home/claw/work/sc1063b/sc/core/building.cpp
> 9c9
> < //	IP(0),
> ---
> > 	IP(0),
> 21c21
> < //	IP(object.IP),
> ---
> > 	IP(object.IP),
> 34c34
> < //	IP = object.IP;
> ---
> > 	IP = object.IP;
> diff ./building.hpp /home/claw/work/sc1063b/sc/core/building.hpp
> 8,30c8,30
> < 	private:
> < 		unsigned int totalBuildTime;
> < 		signed int buildFinishedTime; // timestamp when item is finnished (3600 = beginning)
> < 		unsigned int type;			  // Type of Building
> < 		unsigned int unitCount;  // number of units which are moving... currently ONLY for movements...
> < 		unsigned int facility;   // in what facility it was produced
> < //		unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
> < 		unsigned int location;   // where the building was finished
> < 		unsigned int goal;			  // For movement, where the units will move to, not yet fully implemented
> < 		bool onTheRun;   // is this building/unit moving around or is it under construction at some place?
499,507d1580
< < 		STATISTICS();
< < 		~STATISTICS();
< < 		void resetData();
< < 		unsigned int needSupply;		// supply that is used up by all units
< < 		unsigned int haveSupply;		// total supply of supply buildings (overlord, supply depot, command center, ...)
< < 		unsigned int minerals;			// minerals at that time
< < 		unsigned int gas;			// gas at that time
< < 		unsigned int fitness;	//fitness at that time
< < };
509c1582,1585
< < struct PROGRAM
---
> < 		Building();
> < 		Building(const Building& object);
> < 		Building& operator=(const Building& object);
> < 		friend bool operator<(const Building& x, const Building& y)
511,526c1587,1589
< < 	public:
< < 		PROGRAM();
< < 		~PROGRAM();
< < 		void resetData();		
< < 		bool built;			// was this order successfully built?
< < 		unsigned int time;			// at which time this order was started
< < 		unsigned int location;		// at which location was this unit built
< < 		unsigned int successType;	// type of error
< < 		unsigned int successUnit;	// unit number
< < 	//	int isGoal;			// is this unit part of the goal list? DOES NOT WORK YET :)
< < 		unsigned int forceCount[UNIT_TYPE_COUNT];
< < 		unsigned int availibleCount[UNIT_TYPE_COUNT];
< < 		unsigned int facility; 	// where it was produced
< < 		unsigned int BT;		//real buildtime, incl. moving scv etc.
< < //		int isConstant; //this build order may not be moved. In addition no order may be inserted before the order, if the previous order is also constant.
< < // TODO: Zeitfenster machen!
---
> < 			if(x.getBuildFinishedTime() < y.getBuildFinishedTime())
> < 				return(true);
> < 			return(false);
527a1591,1592
> < 		const unsigned int getTotalBuildTime() const;
> < 		const unsigned int getBuildFinishedTime() const;
529,548c1594,1734
< > #include "program.hpp"
< > #include "statistics.hpp"
< 41,83d9
< < 	private:
< < 		unsigned int unitsTotal; // total number of all unit types at the end
< < 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
< < 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
< < 		unsigned int unchangedGenerations;
< < 		unsigned int currentRun;
< < 		bool optimizing;
< < 		bool active;
< < 		unsigned int totalGeneration;
< < 		unsigned int maxpFitness;
< < 		unsigned int maxsFitness;
< < 		unsigned int maxtFitness;
< < 		unsigned int timePercentage;
< < 		unsigned int goalPercentage;
< < 		unsigned int currentpFitness;
< < 		unsigned int averageLength;
< < 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
---
> > private:
> > 	unsigned int totalBuildTime;
> > 	signed int buildFinishedTime; // timestamp when item is finnished (3600 = beginning)
> > 	unsigned int type;			  // Type of Building
> > 	unsigned int unitCount;  // number of units which are moving... currently ONLY for movements...
> > 	unsigned int facility;   // in what facility it was produced
> > 	unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
> > 	unsigned int location;   // where the building was finished
> > 	unsigned int goal;			  // For movement, where the units will move to, not yet fully implemented
> > 	bool onTheRun;   // is this building/unit moving around or is it under construction at some place?
> > public:
> > 	friend bool operator<(const Building& x, const Building& y)
> > 	{
> > 		if(x.getBuildFinishedTime() < y.getBuildFinishedTime())
> > 			return(true);
> > 		return(false);
> > 	}
> > 	Building();
> > 	Building(const Building& object);
> > 	Building& operator=(const Building& object);
> > 	
> > 	const unsigned int getTotalBuildTime() const;
> > 	const unsigned int getBuildFinishedTime() const;
> 33c33
> < 		const bool canBeCompleted() const;
> ---
> > 	const bool canBeCompleted() const;
> 35,41c35,41
> < 		const unsigned int getType() const;
> < 		const unsigned int getUnitCount() const;
> < 		const unsigned int getFacility() const;
> < //		const unsigned int getIP() const;
> < 		const unsigned int getLocation() const;
> < 		const unsigned int getGoal() const;
> < 		const bool getOnTheRun() const;
> ---
> > 	const unsigned int getType() const;
> > 	const unsigned int getUnitCount() const;
> > 	const unsigned int getFacility() const;
> > 	const unsigned int getIP() const;
> > 	const unsigned int getLocation() const;
> > 	const unsigned int getGoal() const;
> > 	const bool getOnTheRun() const;
> 43,44c43,44
> < 		void setTotalBuildTime(const unsigned int total_build_time);
> < 		void setBuildFinishedTime(const signed int build_finished_time);
> ---
> > 	void setTotalBuildTime(const unsigned int total_build_time);
> > 	void setBuildFinishedTime(const signed int build_finished_time);
> 46,52c46,52
> < 		void setType(const unsigned int building_type);
> < 		void setUnitCount(const unsigned int building_count);
> < 		void setFacility(const unsigned int building_facility);
> < //		void setIP(const unsigned int building_IP);
> < 		void setLocation(const unsigned int building_location);
> < 		void setGoal(const unsigned int building_goal);
> < 		void setOnTheRun(const bool building_on_the_run);
> ---
> > 	void setType(const unsigned int building_type);
> > 	void setUnitCount(const unsigned int building_count);
> > 	void setFacility(const unsigned int building_facility);
> > 	void setIP(const unsigned int building_IP);
> > 	void setLocation(const unsigned int building_location);
> > 	void setGoal(const unsigned int building_goal);
> > 	void setOnTheRun(const bool building_on_the_run);
> 107c107
> < /*inline const unsigned int Building::getIP() const
> ---
> > inline const unsigned int Building::getIP() const
> 115c115
> < }*/
> ---
> > }
> 120c120
> < 	if(location >= MAX_LOCATIONS) { // TODO
> ---
> > 	if(location > MAX_LOCATIONS) {
> 197c197
> < /*inline void Building::setIP(const unsigned int building_IP)
> ---
> > inline void Building::setIP(const unsigned int building_IP)
> 205c205
> < }*/
> ---
> > }
> Files ./building.o and /home/claw/work/sc1063b/sc/core/building.o differ
> diff ./configuration.hpp /home/claw/work/sc1063b/sc/core/configuration.hpp
> 9a10
> > #include <deque>
> Files ./configuration.o and /home/claw/work/sc1063b/sc/core/configuration.o differ
> diff ./defs.cpp /home/claw/work/sc1063b/sc/core/defs.cpp
> 38c38
> < const std::string CORE_VERSION="Beta 1.63a";
> ---
> > const std::string CORE_VERSION="Beta 1.62final";
> 198,202c198,202
> < {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
> ---
> > {"Move 3 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Move 1 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Move 1 Backward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> 311,315c311,315
> < {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
> ---
> > {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> 420,424c420,424
> < {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
> ---
> > {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> > {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> diff ./defs.hpp /home/claw/work/sc1063b/sc/core/defs.hpp
> 11c11
> < #define MAX_LOCATIONS 5
> ---
> > #define MAX_LOCATIONS 3
> 200,206c200,205
> < 	BUILD_PARALLEL_2,
> < 	BUILD_PARALLEL_4,
> < 	BUILD_PARALLEL_8,
> < 	BUILD_PARALLEL_16,
550,552c1736,3794
< < 		PROGRAM program[MAX_LENGTH];
< < 		STATISTICS ipStatistics[2*MAX_LENGTH]; // before and after command!
< < 		STATISTICS timeStatistics[MAX_TIME];
---
> < 	FROM_GAS_TO_MINERALS,
> < 	LAST_UNIT,// 70
> ---
> > 	MOVE_ONE_3_FORWARD,
> > 	MOVE_ONE_1_FORWARD,
> > 	MOVE_ONE_1_BACKWARD,
> > 	ROTATE, 
> > 	FOLLOW,// 70
> > 	RESET,
> Files ./defs.o and /home/claw/work/sc1063b/sc/core/defs.o differ
> diff ./differ /home/claw/work/sc1063b/sc/core/differ
> 1,1684c1,126
> < diff ./anarace.cpp /home/claw/work/sc1063b/sc/core/anarace.cpp
> < 13a14,66
> < > STATISTICS::STATISTICS():
> < > 	needSupply(0),
> < > 	haveSupply(0),
> < > 	minerals(0),
> < > 	gas(0),
> < > 	fitness(0)
> < > { }
> < > 
> < > STATISTICS::~STATISTICS() {}
> < > 
> < > void STATISTICS::resetData()
> < > {
> < > 	needSupply=0;
> < > 	haveSupply=0;
> < > 	minerals=0;
> < > 	gas=0;
> < > 	fitness=0;
> < > }
> < > 
> < > PROGRAM::PROGRAM():
> < > 	built(false),
> < > 	time(0),
> < > 	location(0),
> < > 	successType(0),
> < > 	successUnit(0),
> < > 	facility(0),
> < > 	BT(0)
> < > {
> < > 	for(int i=UNIT_TYPE_COUNT;i--;)
> < > 	{
> < > 		forceCount[i]=0;
> < > 		availibleCount[i]=0;
> < > 	}
> < > }
> < > 
> < > PROGRAM::~PROGRAM() {}
> < > 
> < > void PROGRAM::resetData()
> < > {
> < > 	built=false;
> < > 	time=0;
> < > 	location=0;
> < > 	successType=0;
> < > 	successUnit=0;
> < > 	facility=0;
> < > 	BT=0;
> < > 		for(int i=UNIT_TYPE_COUNT;i--;)
> < > 		{
> < > 				forceCount[i]=0;
> < > 				availibleCount[i]=0;
> < > 		}
> < > }
> < > 
> < 16,17c69,71
> < < 	successType = 0;
> < < 	successUnit = 0;
> < ---
> < > 	PRERACE::resetStaticPrerace();
> < > 	successType=0;
> < > 	successUnit=0;
> < 23,27d76
> < < 	fitnessAverage(0),
> < < 	fitnessVariance(0),
> < < 	positiveCrossover(0),
> < < 	wayneCrossover(0),
> < < 	negativeCrossover(0),
> < 37a87
> < > 	maxtFitness(MAX_TFITNESS),
> < 41c91,96
> < < 	averageLength(0)
> < ---
> < > 	averageLength(0),
> < > 	fitnessAverage(0),
> < > 	fitnessVariance(0),
> < > 	positiveCrossover(0),
> < > 	wayneCrossover(0),
> < > 	negativeCrossover(0)
> < 43c98,105
> < < 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
> < ---
> < > 	
> < > 	for(int i = MAX_LENGTH;i--;)
> < > 	{
> < > 		phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
> < > 		ipStatistics[i].resetData();
> < > 		ipStatistics[i+1].resetData();
> < > 		program[i].resetData();
> < > 	}
> < 51,72c113,141
> < < 	unitsTotal = 4;
> < < 	unitsTotalMax = 4;
> < < 	nonGoalsUnitsTotalMax = 4;
> < < 	unchangedGenerations = 0;
> < < 	currentRun = 0;
> < < 	optimizing = false;
> < < 	active = true;
> < < 	totalGeneration = 0;
> < < 	maxpFitness = 0;
> < < 	maxsFitness = 0;
> < < 	timePercentage = 0;
> < < 	goalPercentage = 0;
> < < 	currentpFitness = 0;
> < < 	averageLength = 0;
> < < 	fitnessAverage = 0;
> < < 	fitnessVariance = 0;
> < < 	positiveCrossover = 0;
> < < 	wayneCrossover = 0;
> < < 	negativeCrossover = 0;
> < < 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));	// the final build order: an array of unit numbers (as defined in main.h)
> < < 	for(int i = MAX_TIME;i--;)
> < < 		timeStatistics[i].resetData();
> < ---
> < > 		unitsTotal=4;
> < > 		unitsTotalMax=4;
> < > 		nonGoalsUnitsTotalMax=4;
> < > 		unchangedGenerations=0;
> < > 		currentRun=0;
> < > 		optimizing=false;
> < > 		active=true;
> < > 		totalGeneration=0;
> < > 		maxpFitness=0;
> < > 		maxsFitness=0;
> < > 		maxtFitness=MAX_TFITNESS;
> < > 		timePercentage=0;
> < > 		goalPercentage=0;
> < > 		currentpFitness=0;
> < > 		averageLength=0;
> < > 		fitnessAverage=0;
> < > 		fitnessVariance=0;
> < > 		positiveCrossover=0;
> < > 		wayneCrossover=0;
> < > 		negativeCrossover=0;
> < > 		for(int i = MAX_LENGTH;i--;)
> < > 		{
> < > 				phaenoCode[i]=0;			// the final build order: an array of unit numbers (as defined in main.h)
> < > 				ipStatistics[i].resetData();
> < > 				ipStatistics[i+1].resetData();
> < > 				program[i].resetData();
> < > 		}
> < > 		for(int i = MAX_TIME;i--;)
> < > 				timeStatistics[i].resetData();
> < 80,84d148
> < < 	fitnessAverage( object.fitnessAverage ),
> < < 	fitnessVariance( object.fitnessVariance ),
> < < 	positiveCrossover( object.positiveCrossover ),
> < < 	wayneCrossover( object.wayneCrossover ), 
> < < 	negativeCrossover( object.negativeCrossover ),
> < 94a159
> < > 	maxtFitness( object.maxtFitness ),
> < 98c163,168
> < < 	averageLength( object.averageLength )
> < ---
> < > 	averageLength( object.averageLength ),
> < > 	fitnessAverage( object.fitnessAverage ),
> < > 	fitnessVariance( object.fitnessVariance ),
> < > 	positiveCrossover( object.positiveCrossover ),
> < > 	wayneCrossover( object.wayneCrossover ), 
> < > 	negativeCrossover( object.negativeCrossover )
> < 100,101c170,177
> < < 	memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
> < < 	memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
> < ---
> < > 	for(int i = MAX_LENGTH;i--;)
> < > 	{
> < > 		phaenoCode[i] = object.phaenoCode[i];
> < > 		program[i] = object.program[i];
> < > 		ipStatistics[i] = object.ipStatistics[i];
> < > 	}	
> < > 	for(int i = MAX_TIME;i--;)
> < > 		timeStatistics[i] = object.timeStatistics[i];
> < 107,111d182
> < < 	fitnessAverage = object.fitnessAverage;
> < < 	fitnessVariance = object.fitnessVariance;
> < < 	positiveCrossover = object.positiveCrossover;
> < < 	wayneCrossover = object.wayneCrossover;
> < < 	negativeCrossover = object.negativeCrossover;
> < 121a193
> < > 	maxtFitness = object.maxtFitness;
> < 126,128c198,211
> < <         memcpy(phaenoCode, object.phaenoCode, MAX_LENGTH * sizeof(int));
> < <         memcpy(timeStatistics, object.timeStatistics, MAX_TIME * sizeof(STATISTICS));
> < < 
> < ---
> < > 	fitnessAverage = object.fitnessAverage;
> < > 	fitnessVariance = object.fitnessVariance;
> < > 	positiveCrossover = object.positiveCrossover;
> < > 	wayneCrossover = object.wayneCrossover;
> < > 	negativeCrossover = object.negativeCrossover;
> < > 	for(int i = MAX_LENGTH;i--;)
> < > 	{
> < > 		phaenoCode[i] = object.phaenoCode[i];
> < > 		program[i] = object.program[i];
> < > 		ipStatistics[i] = object.ipStatistics[i];
> < > 	}
> < > 	for(int i = MAX_TIME;i--;)
> < > 		timeStatistics[i] = object.timeStatistics[i];
> < > 		
> < 139a223
> < > 	setMaxtFitness(MAX_TFITNESS);
> < 141,146c225,230
> < < 	unitsTotal = 1; // ~4 ?
> < < 	unitsTotalMax = 1;
> < < 	nonGoalsUnitsTotalMax = 1;
> < < 	timePercentage = 0;
> < < 	goalPercentage = 0;
> < < 	averageLength = 0;
> < ---
> < > 	unitsTotal=1; // ~4 ?
> < > 	unitsTotalMax=1;
> < > 	nonGoalsUnitsTotalMax=1;
> < > 	timePercentage=0;
> < > 	goalPercentage=0;
> < > 	averageLength=0;
> < 157,162c241,276
> < < 	memset(timeStatistics, 0, MAX_LENGTH * sizeof(STATISTICS));
> < < 	memset(phaenoCode, 0, MAX_LENGTH * sizeof(int));
> < < 
> < < 	std::list<PROGRAM>::iterator i = programList.begin();
> < < 	while(i!=programList.end())
> < < 		i = programList.erase(i);	
> < ---
> < > 	for(int i=2*MAX_LENGTH;i--;)
> < > 	{
> < > 		setIPStatisticsHaveSupply(i, 0);
> < > 		setIPStatisticsHaveMinerals(i, 0);
> < > 		setIPStatisticsHaveGas(i, 0);
> < > 		setIPStatisticsNeedSupply(i, 0);
> < > 		setIPStatisticsFitness(i, 0);
> < > 	}
> < > 	
> < > 	for(int i=MAX_TIME;i--;)
> < > 	{
> < > 		setTimeStatisticsHaveSupply(i, 0);
> < > 		setTimeStatisticsHaveMinerals(i, 0);
> < > 		setTimeStatisticsHaveGas(i, 0);
> < > 		setTimeStatisticsNeedSupply(i, 0);
> < > 		setTimeStatisticsFitness(i, 0);
> < > 	}
> < > 	
> < > 	for(int i=MAX_LENGTH;i--;)//ANA~
> < > 	{
> < > 		setProgramSuccessType(i, 0);
> < > 		setProgramSuccessUnit(i, 0);
> < > 		setProgramIsBuilt(i, false);
> < > 		setProgramTime(i, 0);
> < > 		for(int j=UNIT_TYPE_COUNT;j--;)
> < > 		{
> < > 			setProgramAvailibleCount(i, j, 0);
> < > 			setProgramTotalCount(i, j, 0);
> < > 		}
> < > 		//program[i].temp=0;
> < > 		setProgramLocation(i,0);
> < > //		setProgramIsGoal(i,false);
> < > 		setProgramFacility(i,0);
> < > 		setProgramBT(i,0);
> < > 		phaenoCode[i]=0;
> < > 	}
> < 196,200c310,315
> < < //		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
> < < //		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
> < < //		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
> < < //		setTimeStatisticsHaveGas(getTimer(), getGas());
> < < //		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
> < ---
> < > 		setTimeStatisticsNeedSupply(getTimer(), getNeedSupply());
> < > 		setTimeStatisticsHaveSupply(getTimer(), getHaveSupply());
> < > 		setTimeStatisticsHaveMinerals(getTimer(), getMinerals());
> < > 		setTimeStatisticsHaveGas(getTimer(), getGas());
> < > 		setTimeStatisticsFitness(getTimer(), calculatePrimaryFitness(ready)); // ~~
> < > 
> < 203a319
> < > 
> < 210,232d325
> < < 		unsigned int code = getpGoal()->toPhaeno(getCurrentCode());
> < < 		if((code >= BUILD_PARALLEL_2) && (code <= BUILD_PARALLEL_16))
> < <                 {
> < <                         setIP(getIP()-1);
> < <                         while((getpGoal()->toPhaeno(getCurrentCode()) > GAS_SCV)&&(getIP()))
> < <                                 setIP(getIP()-1);
> < <                         PARALLEL_COMMAND* pcommand = new PARALLEL_COMMAND;
> < <                         switch(code)
> < <                         {
> < <                                 case BUILD_PARALLEL_2:pcommand->count = 2;break;
> < <                                 case BUILD_PARALLEL_4:pcommand->count = 4;break;
> < <                                 case BUILD_PARALLEL_8:pcommand->count = 8;break;
> < <                                 case BUILD_PARALLEL_16:pcommand->count = 16;break;
> < <                                 default:break; // ~~
> < <                         }
> < <                         pcommand->unit = getpGoal()->toPhaeno(getCurrentCode());
> < < 			
> < <                         if(getIP()) 
> < < 				setIP(getIP()-1);
> < <                         parallelCommandQueues.push_back(pcommand);
> < <                         ok = true;
> < <                 } else
> < < 		{
> < 234,237c327,333
> < < 			neededMinerals = MAX_MINERALS;
> < < 			neededGas = MAX_GAS;
> < < 			
> < < 			ok = buildGene(getpGoal()->toPhaeno(getCurrentCode()));
> < ---
> < > 		neededMinerals=MAX_MINERALS;
> < > 		neededGas=MAX_GAS;
> < > 		setIPStatisticsNeedSupply(getIP()*2+1, getNeedSupply());
> < > 		setIPStatisticsHaveSupply(getIP()*2+1, getHaveSupply());
> < > 		setIPStatisticsHaveMinerals(getIP()*2+1, getMinerals());
> < > 		setIPStatisticsHaveGas(getIP()*2+1, getGas());
> < > 		setIPStatisticsFitness(getIP()*2+1, calculatePrimaryFitness(ready));
> < 238a335,348
> < > 		ok=buildGene(getpGoal()->toPhaeno(getCurrentCode()));
> < > 	
> < > 		setIPStatisticsNeedSupply(getIP()*2, getNeedSupply());
> < > 		setIPStatisticsHaveSupply(getIP()*2, getHaveSupply());
> < > 		setIPStatisticsHaveMinerals(getIP()*2, getMinerals());
> < > 		setIPStatisticsHaveGas(getIP()*2, getGas());
> < > 		setIPStatisticsFitness(getIP()*2, calculatePrimaryFitness(ready));
> < > 	
> < > 		if(successType>0)
> < > 		{
> < > 			setProgramSuccessType(getIP(), successType);
> < > 			setProgramSuccessUnit(getIP(), successUnit);
> < > 		}
> < > 		
> < 242,261c352,367
> < < 			if((ok) || (!getTimeOut())) 
> < < 			{
> < < 				setTimeOut(configuration.getMaxTimeOut());
> < < 				setIP(getIP()-1);
> < < 			}		
> < <                 	else if(!ok)
> < < 	                {
> < < // TEST FOR PARALLEL COMMANDQUEUES
> < <         	                std::list<PARALLEL_COMMAND*>::iterator command = parallelCommandQueues.begin(); 
> < <                 	        while(command != parallelCommandQueues.end())
> < <                         	{
> < <                                 	ok = buildGene((*command)->unit);
> < < 	                                if(ok)  
> < <         	                        {
> < <                 	                        (*command)->count--;
> < <                         	                if(!(*command)->count)
> < <                                 	                command = parallelCommandQueues.erase(command);
> < <                 	                } else command++;
> < < 		               	}
> < <                 	}
> < ---
> < > 		if((ok)||(!getTimeOut())) {
> < > 			if(ok) {
> < > 				setProgramTime(getIP(), getTimer());
> < > 			} else {
> < > 				setProgramTime(getIP(),configuration.getMaxTime());
> < > 				setProgramSuccessType(getIP(), TIMEOUT_ERROR);
> < > 				setProgramSuccessUnit(getIP(), 0);
> < > //				setProgramSuccessLocation(0);
> < > 			}
> < > 			for(int i=UNIT_TYPE_COUNT;i--;)	{
> < > 				setProgramTotalCount(getIP(), i, getLocationTotal(GLOBAL, i));
> < > 				setProgramAvailibleCount(getIP(),i,getLocationAvailible(GLOBAL, i));
> < > 			}
> < > 	
> < > 			setTimeOut(configuration.getMaxTimeOut());
> < > 			setIP(getIP()-1);
> < 266c372
> < < 	unsigned int t = calculateIdleTime();
> < ---
> < > 	int t=calculateIdleTime();
> < 269,284c375,383
> < <   	
> < < //	if(t>0)
> < < //	{
> < < //		setProgramSuccessType(getIP(), TIMEOUT_ERROR);
> < < //		setProgramSuccessUnit(getIP(), 0); TODO
> < < //		setProgramSuccessLocation(0);
> < < //	}
> < < 
> < < 	for(unsigned int i = t; i--;)
> < < 	{
> < <  		timeStatistics[getTimer()-i].setNeedSupply(getNeedSupply());
> < < 		timeStatistics[getTimer()-i].setHaveSupply(getHaveSupply());
> < < 		timeStatistics[getTimer()-i].setHaveMinerals(getMinerals()+harvestMinerals()*i);
> < < 		timeStatistics[getTimer()-i].setHaveGas(getGas()+harvestGas()*i);
> < < 		timeStatistics[getTimer()-i].setFitness(calculatePrimaryFitness(ready)); // ~~
> < < 	}
> < ---
> < > 
> < > 	for(int i=0;i<t;i++)
> < > 	{
> < >  		setTimeStatisticsNeedSupply(getTimer()-i, getNeedSupply());
> < > 		setTimeStatisticsHaveSupply(getTimer()-i, getHaveSupply());
> < > 		setTimeStatisticsHaveMinerals(getTimer()-i, getMinerals()+harvestMinerals()*i);
> < > 		setTimeStatisticsHaveGas(getTimer()-i, getGas()+harvestGas()*i);
> < > 		setTimeStatisticsFitness(getTimer()-i, calculatePrimaryFitness(ready)); // ~~
> < > 	} 
> < 299,300c398,399
> < < 	bool foundAnother = true;
> < < 	while((!buildingQueue.empty()) && (foundAnother == true))
> < ---
> < > 	bool foundAnother=true;
> < > 	while((!buildingQueue.empty())&&(foundAnother==true))
> < 304c403
> < < 			foundAnother = true;
> < ---
> < > 			foundAnother=true;
> < 306c405
> < < 			const UNIT_STATISTICS* stat = &((*pStats)[build.getType()]);
> < ---
> < > 			const UNIT_STATISTICS* stat=&((*pStats)[build.getType()]);
> < 309c408
> < < 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2, build.getUnitCount());
> < ---
> < > 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2);			
> < 311,312c410,411
> < < 			addLocationTotal(build.getLocation(), build.getType(), build.getUnitCount());
> < < 			addLocationAvailible(build.getLocation(), build.getType(), build.getUnitCount());
> < ---
> < > 			addLocationTotal(build.getLocation(),build.getType(), build.getUnitCount());
> < > 			addLocationAvailible(build.getLocation(),build.getType(),build.getUnitCount());
> < 317c416
> < < 			if(build.getType() == REFINERY) {
> < ---
> < > 			if(build.getType()==REFINERY) {
> < 321c420
> < < 			if((build.getType() == COMMAND_CENTER)&&(!getLocationTotal(build.getLocation(), COMMAND_CENTER))) {
> < ---
> < > 			if((build.getType()==COMMAND_CENTER)&&(!getLocationTotal(build.getLocation(),COMMAND_CENTER))) {
> < 326c425
> < < 			if((build.getType() == LARVA) && (getpGoal()->getRace() == ZERG)) {
> < ---
> < > 			if((build.getType()==LARVA)&&(getpGoal()->getRace()==ZERG)) {
> < 334c433
> < < 			ready = calculateReady();
> < ---
> < > 			ready=calculateReady();
> < 358,361c457,460
> < < //			setProgramFacility(build.getIP(), build.getFacility());
> < < //			setProgramIsBuilt(build.getIP(), true);
> < < //			setProgramLocation(build.getIP(), build.getLocation());
> < < //			setProgramBT(build.getIP(), build.getTotalBuildTime()); //~~~
> < ---
> < > 			setProgramFacility(build.getIP(), build.getFacility());
> < > 			setProgramIsBuilt(build.getIP(),true);
> < > 			setProgramLocation(build.getIP(),build.getLocation());
> < > 			setProgramBT(build.getIP(),build.getTotalBuildTime()); //~~~
> < 366c465
> < < 		else foundAnother = false;
> < ---
> < > 		else foundAnother=false;
> < 568,571d666
> < < const bool ANARACE::buildIt(const unsigned int build_unit)
> < < {
> < < 	//Zuerst: availible pruefen ob am Ort gebaut werden kann
> < < 	//Wenn nicht => +/- absteigen bis alle locations durch sind
> < 573,728d667
> < < 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> < < 	bool ok = false;
> < < 	unsigned int picked_facility = 0;
> < < 	unsigned int current_location_window = 1; // TODO
> < < //	unsigned int ttloc=0;
> < < //	unsigned int j=0;
> < < 
> < < /*	if(lastcounter>0)
> < < 	{	
> < < 		lastcounter--;
> < < 		tloc=last[lastcounter].location;
> < < 	}*/
> < < 
> < < 	if(stat->facility[0]==0)
> < < 		ok=true;
> < < 	else
> < < 	// special rule for morphing units of protoss
> < < 	if((stat->facility2>0) && ((stat->facilityType == IS_LOST) || (stat->facilityType == IS_MORPHING)) && (stat->facility[0] == stat->facility2))
> < < 	{
> < < 		if(getLocationAvailible(current_location_window, stat->facility2) >=2)
> < < 		{
> < < 			ok = true;
> < < 			picked_facility = 0;
> < < 		}
> < < 	} else
> < < 	{
> < < 		// research/upgrade:
> < < 		if((stat->facility2==0) || (getLocationAvailible(current_location_window, stat->facility2)>=1))
> < < 		{
> < < 		// pick one availible facility: 
> < < 			for(picked_facility = 0; picked_facility<3; picked_facility++)
> < < 				if((stat->facility[picked_facility]>0)&&(getLocationAvailible(current_location_window, stat->facility[picked_facility])>0))
> < < 				{
> < < 					ok=true;
> < < 					break;
> < < 				}
> < < 		}						
> < < 	}
> < < 				
> < < //				j=1;
> < < 				// none found? search other parts of the map... TODO
> < < /*				if(!ok)
> < < 					while(j<MAX_LOCATIONS)
> < < 					{
> < < 						ttloc=(*pMap)->getLocation(tloc)->getNearest(j);
> < < //						if((stat->facility2==0)||(getLocationAvailible(ttloc,stat->facility2)>0)) TODO
> < < //						{
> < < //						for(fac=3;fac--;)
> < < 						for(fac=0;fac<3; fac++)
> < < 						if(
> < < 						// special rules for morphing units of protoss
> < < 						((stat->facilityType != IS_LOST) || (stat->facility[fac] != stat->facility2) || (getLocationAvailible(ttloc, stat->facility[fac]) >= 2)) &&
> < < 						((stat->facility[fac] > 0) && (getLocationAvailible(ttloc, stat->facility[fac])))
> < < 						|| ((stat->facility[fac]==0)&&(fac==0))) //~~
> < < 																													   
> < < //					  for(fac=3;fac--;)
> < < //						  if( ((stat->facility[fac]>0)&&(getLocationAvailible(ttloc,stat->facility[fac])>((stat->facilityType==IS_LOST)&&(stat->facility[fac]==stat->facility2)))) || ((stat->facility[fac]==0)&&(fac==0)))
> < < 							{
> < < 								tloc=ttloc;
> < < 								ok=true;
> < < 								break;
> < < 							}
> < < //						  break;
> < < //					  }
> < < 						j++;
> < < 					}*/
> < < 																													   
> < < 	if((ok)&&(build_unit==REFINERY)) {
> < < 		if(getMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR) <=0)
> < < 			ok=false;
> < < 		else
> < < 			removeOneMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR);
> < < 	}
> < < //TODO: Wenn verschiedene facilities moeglich sind, dann das letzte nehmen
> < < //			  bewegliche Sachen ueberdenken...
> < < //				  evtl zusaetzliche Eigenschaft 'speed' einbauen (muss sowieso noch...)... bei speed>0 ... mmmh... trifft aber auch nur auf scvs zu ... weil bringt ja wenig erst mit der hydra rumzulaufen und dann zum lurker... mmmh... aber waere trotzdem zu ueberlegen...
> < < //				  auch noch ueberlegen, wenn z.B. mit scv ohne kommandozentrale woanders gesammelt wird...
> < < //	  Phagen ueber Phagen...
> < < 	if(ok)
> < < 	{ 
> < <  		if((getpGoal()->getRace()==ZERG) &&
> < < //		  ((*pStats)[build_unit].facility[0]==LARVA)&&
> < < 			(build_unit!=LARVA) &&
> < < 		// Larva wird benoetigt zum Bau? Fein, dann bauen wir eine neue Larva falls nicht schon alle hatcheries etc. belegt sidn
> < < 				// Gesamtzahl der Larven < 3 * HATCHERY?
> < < 		   ((getLocationTotal(current_location_window, HATCHERY)+
> < < 			 getLocationTotal(current_location_window, LAIR)+
> < < 			 getLocationTotal(current_location_window, HIVE)) *3 > 
> < < 			 (larvaInProduction[current_location_window]+getLocationTotal(current_location_window, LARVA)))  &&
> < < // max 1 larva pro Gebaeude produzieren
> < <  		   ((getLocationTotal(current_location_window, HATCHERY)+
> < < 			 getLocationTotal(current_location_window, LAIR)+
> < < 			 getLocationTotal(current_location_window, HIVE) > 
> < < 			  larvaInProduction[current_location_window]))) // => zuwenig Larven da!
> < < 			{
> < < 				addLarvaToQueue(current_location_window);
> < < 				if(!buildIt(LARVA));
> < < //					removeLarvaFromQueue(current_location_window);
> < < 			}
> < < 
> < < 																												  
> < < 		Building build;
> < < 		build.setOnTheRun(false);
> < < 		build.setFacility(stat->facility[picked_facility]);
> < < 		build.setLocation(current_location_window);
> < < 		if(build_unit == FROM_GAS_TO_MINERALS)
> < < 			build.setUnitCount(getLocationAvailible(current_location_window, GAS_SCV));
> < < 		else
> < < 			build.setUnitCount(1+(stat->create == build_unit));
> < < 		build.setBuildFinishedTime(getTimer()-stat->BT);
> < < 		build.setTotalBuildTime(stat->BT);
> < < 		build.setType(build_unit);
> < < 		buildingQueue.push(build);
> < < 
> < < 		PROGRAM program;
> < < //		for(unsigned int i = UNIT_TYPE_COUNT; i--;)
> < < //		{
> < < //			program.setTotalCount(i, getLocationTotal(GLOBAL, i));
> < < //			program.setAvailibleCount(i, getLocationAvailible(GLOBAL, i));
> < < //		}
> < < 		program.setUnit(build_unit);
> < < 		program.setTime(getTimer());
> < < 		program.setFacility(build.getFacility());
> < < 		program.setLocation(build.getLocation());
> < < 		program.setBT(build.getTotalBuildTime());
> < < 	/*	if(successType>0)
> < < 		{
> < < 			program.setSuccessType(successType);
> < < 			program.setSuccessUnit(successUnit);
> < < 		}*/ //?
> < < 	
> < < 		program.before.setNeedSupply(getNeedSupply());
> < < 		program.before.setHaveSupply(getHaveSupply());
> < < 		program.before.setHaveMinerals(getMinerals());
> < < 		program.before.setHaveGas(getGas());
> < < 
> < < // upgrade_cost is 0 if it's no upgrade
> < < 		setMinerals(getMinerals()-(stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> < < 		setGas(getGas()-(stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> < < 		setNeedSupply(getNeedSupply()+stat->needSupply);
> < < //		if((stat->needSupply>0)||(((*pStats)[stat->facility[0]].needSupply<0)&&(stat->facilityType==IS_LOST)))  TODO!!!!
> < < //		setNeedSupply(getNeedSupply()-stat->needSupply); //? Beschreibung!
> < < 		adjustAvailibility(current_location_window, picked_facility, stat);
> < < 		
> < < 		program.after.setNeedSupply(getNeedSupply());
> < < 		program.after.setHaveSupply(getHaveSupply());
> < < 		program.after.setHaveMinerals(getMinerals());
> < < 		program.after.setHaveGas(getGas());
> < < 
> < < 		program.setUsedFacilityCount(getLocationTotal(GLOBAL, stat->facility[picked_facility]) - getLocationAvailible(GLOBAL, stat->facility[picked_facility])); // TODO evtl nach Ort
> < < 
> < <                	programList.push_back(program);
> < < 
> < < 	} //end if(ok)
> < < 	return(ok);
> < < }
> < 838a778,783
> < > 
> < > 
> < > 
> < > 
> < > 
> < > 
> < diff ./anarace.hpp /home/claw/work/sc1063b/sc/core/anarace.hpp
> < 5,6c5,37
> < < #include "program.hpp"
> < < #include "statistics.hpp"
> < ---
> < > 
> < > class STATISTICS
> < > {
> < > 	public:
> < > 		STATISTICS();
> < > 		~STATISTICS();
> < > 		void resetData();
> < > 		unsigned int needSupply;		// supply that is used up by all units
> < > 		unsigned int haveSupply;		// total supply of supply buildings (overlord, supply depot, command center, ...)
> < > 		unsigned int minerals;			// minerals at that time
> < > 		unsigned int gas;			// gas at that time
> < > 		unsigned int fitness;	//fitness at that time
> < > };
> < > 
> < > struct PROGRAM
> < > {
> < > 	public:
> < > 		PROGRAM();
> < > 		~PROGRAM();
> < > 		void resetData();		
> < > 		bool built;			// was this order successfully built?
> < > 		unsigned int time;			// at which time this order was started
> < > 		unsigned int location;		// at which location was this unit built
> < > 		unsigned int successType;	// type of error
> < > 		unsigned int successUnit;	// unit number
> < > 	//	int isGoal;			// is this unit part of the goal list? DOES NOT WORK YET :)
> < > 		unsigned int forceCount[UNIT_TYPE_COUNT];
> < > 		unsigned int availibleCount[UNIT_TYPE_COUNT];
> < > 		unsigned int facility; 	// where it was produced
> < > 		unsigned int BT;		//real buildtime, incl. moving scv etc.
> < > //		int isConstant; //this build order may not be moved. In addition no order may be inserted before the order, if the previous order is also constant.
> < > // TODO: Zeitfenster machen!
> < > };
> < 9a41,83
> < > 	private:
> < > 		unsigned int unitsTotal; // total number of all unit types at the end
> < > 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
> < > 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
> < > 		unsigned int unchangedGenerations;
> < > 		unsigned int currentRun;
> < > 		bool optimizing;
> < > 		bool active;
> < > 		unsigned int totalGeneration;
> < > 		unsigned int maxpFitness;
> < > 		unsigned int maxsFitness;
> < > 		unsigned int maxtFitness;
> < > 		unsigned int timePercentage;
> < > 		unsigned int goalPercentage;
> < > 		unsigned int currentpFitness;
> < > 		unsigned int averageLength;
> < > 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
> < > 
> < > 		PROGRAM program[MAX_LENGTH];
> < > 		STATISTICS ipStatistics[2*MAX_LENGTH]; // before and after command!
> < > 		STATISTICS timeStatistics[MAX_TIME];
> < > 	
> < > //		const bool* fixed;
> < > 		
> < > 		static unsigned int successType; //type of error
> < > 		static unsigned int successUnit; //unit number
> < > 
> < > 		void setCurrentpFitness(unsigned int current_pfitness);
> < > 		
> < > 		const bool buildGene(const unsigned int build_unit);
> < > 
> < > 		void setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply);
> < > 		void setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply);
> < > 		void setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness);
> < > 		void setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals);
> < > 		void setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas);
> < > 
> < > 		void setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply);
> < > 		void setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply);
> < > 		void setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness);
> < > 		void setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals);
> < > 		void setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas);
> < > 		
> < 38,40d111
> < < 		std::list<PROGRAM>& getProgramList();
> < < 		STATISTICS* getTimeStatistics();
> < < 
> < 52a124
> < > //		const bool getProgramIsConstant(const unsigned int ip) const;
> < 56c128,153
> < < 				
> < ---
> < > 		const unsigned int getProgramSuccessType(const unsigned int ip) const;	// determines the type of the last error before the item was built at that IP
> < > 		const unsigned int getProgramSuccessUnit(const unsigned int ip) const;	// what unit was missing? (connected to successtype)
> < > 		
> < > 		const unsigned int getIPStatisticsNeedSupply(const unsigned int ip) const;	// supply that is used up by all units
> < > 		const unsigned int getIPStatisticsHaveSupply(const unsigned int ip) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
> < > 		const unsigned int getIPStatisticsFitness(const unsigned int ip) const;
> < > 		const unsigned int getIPStatisticsHaveMinerals(const unsigned int ip) const; // minerals at that time
> < > 		const unsigned int getIPStatisticsHaveGas(const unsigned int ip) const;		// gas at that time
> < > 
> < > 		const unsigned int getTimeStatisticsNeedSupply(const unsigned int time) const;	// supply that is used up by all units
> < > 		const unsigned int getTimeStatisticsHaveSupply(const unsigned int time) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
> < > 		const unsigned int getTimeStatisticsFitness(const unsigned int time) const;
> < > 		const unsigned int getTimeStatisticsHaveMinerals(const unsigned int time) const; // minerals at that time
> < > 		const unsigned int getTimeStatisticsHaveGas(const unsigned int time) const;		// gas at that time
> < > 
> < > 		const bool getProgramIsBuilt(const unsigned int ip) const;		// was this order successfully built?
> < > 
> < > 		const unsigned int getProgramTime(const unsigned int ip) const;			// at which time this order was started
> < > 		const unsigned int getRealProgramTime(const unsigned int ip) const;			// at which time this order was started
> < > 		const unsigned int getProgramLocation(const unsigned int ip) const;		// at which location was this unit built
> < > //		const bool getProgramIsGoal(const unsigned int ip) const;		// is this unit part of the goal list? NOT YET WORKING!
> < > 		const unsigned int getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const;	// how many units of the type at phaenoCode[s] do exist at that time?
> < > 		const unsigned int getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const;	 // how many units of the type at phaenoCode[s] do exist at that time?
> < > 
> < > 		const unsigned int getProgramFacility(const unsigned int ip) const;
> < > 		const unsigned int getProgramBT(const unsigned int ip) const;
> < 63,64c160,161
> < < 		const unsigned int getMaxtFitness() const;
> < < 		
> < ---
> < > 		const unsigned int getMaxtFitness() const;			// gets tertiary fitness (build order appearance, some heuristics)
> < > 
> < 76a174,185
> < > //		void setProgramIsConstant(const unsigned int ip, const bool isConstant);
> < > 		void setProgramFacility(const unsigned int ip, const unsigned int program_facility);
> < > 		void setProgramBT(const unsigned int ip, const unsigned int program_bt);
> < > 		void setProgramSuccessType(const unsigned int ip, const unsigned int program_success_type);
> < > 		void setProgramSuccessUnit(const unsigned int ip, const unsigned int program_success_unit);
> < > 		void setProgramIsBuilt(const unsigned int ip, const bool program_is_built);
> < > 		void setProgramLocation(const unsigned int ip, const unsigned int program_location);
> < > 		void setProgramTime(const unsigned int ip, const unsigned int program_time);
> < > //		void setProgramIsGoal(const unsigned int ip, const bool isGoal);	
> < > 		void setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);	
> < > 		void setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);
> < > 
> < 83,110d191
> < < 	
> < < 		std::list<PROGRAM> programList; // TODO private machen
> < < 	private:
> < < 		unsigned int unitsTotal; // total number of all unit types at the end
> < < 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
> < < 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
> < < 		unsigned int unchangedGenerations;
> < < 		unsigned int currentRun;
> < < 		bool optimizing;
> < < 		bool active;
> < < 		unsigned int totalGeneration;
> < < 		unsigned int maxpFitness;
> < < 		unsigned int maxsFitness;
> < < 		unsigned int maxtFitness;
> < < 		unsigned int timePercentage;
> < < 		unsigned int goalPercentage;
> < < 		unsigned int currentpFitness;
> < < 		unsigned int averageLength;
> < < 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
> < < 
> < < 		STATISTICS timeStatistics[MAX_TIME];
> < < 
> < < //		const bool* fixed;
> < < 		
> < < 		static unsigned int successType; //type of error
> < < 		static unsigned int successUnit; //unit number
> < < 
> < < 		void setCurrentpFitness(unsigned int current_pfitness);
> < 112,113d192
> < < 		const bool buildGene(const unsigned int build_unit);
> < < 		const bool buildIt(const unsigned int build_unit);
> < 130,138c209,210
> < < inline std::list<PROGRAM>& ANARACE::getProgramList() {
> < < 	return(programList);
> < < }
> < < 
> < < inline STATISTICS* ANARACE::getTimeStatistics() {
> < < 	return(timeStatistics);
> < < }
> < < 
> < < inline const unsigned int ANARACE::getAverageLength() const {
> < ---
> < > inline const unsigned int ANARACE::getAverageLength() const
> < > {
> < 145c217
> < < 	if(unitsTotalMax > MAX_TOTAL_UNITS*UNIT_TYPE_COUNT * MAX_LOCATIONS) {
> < ---
> < > 	if(unitsTotalMax>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT*MAX_LOCATIONS) {
> < 155c227
> < < 	if(nonGoalsUnitsTotalMax>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT * MAX_LOCATIONS) {
> < ---
> < > 	if(nonGoalsUnitsTotalMax>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT*MAX_LOCATIONS) {
> < 165c237
> < < 	if(unitsTotal>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT * MAX_LOCATIONS) {
> < ---
> < > 	if(unitsTotal>MAX_TOTAL_UNITS*UNIT_TYPE_COUNT*MAX_LOCATIONS) {
> < 172c244,245
> < < inline const bool ANARACE::isActive() const {
> < ---
> < > inline const bool ANARACE::isActive() const
> < > {
> < 176,177c249,251
> < < inline void ANARACE::setActive(const bool set_active) {
> < < 	active = set_active;
> < ---
> < > inline void ANARACE::setActive(const bool set_active)
> < > {
> < > 	active=set_active;
> < 180c254,255
> < < inline const bool ANARACE::isOptimizing() const {
> < ---
> < > inline const bool ANARACE::isOptimizing() const
> < > {
> < 184,185c259,261
> < < inline void ANARACE::setOptimizing(const bool set_optimizing) {
> < < 	optimizing = set_optimizing;
> < ---
> < > inline void ANARACE::setOptimizing(const bool set_optimizing)
> < > {
> < > 	optimizing=set_optimizing;
> < 187a264,278
> < > inline const unsigned int ANARACE::getProgramFacility(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if(ip >= MAX_LENGTH) {
> < > 		toLog("DEBUG: (ANARACE::getProgramFacility): Value ip out of range.");return(0);
> < > 	}
> < > 	if(program[ip].facility >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::getProgramFacility): Variable not initialized.");return(0);
> < > 	}
> < > #endif
> < > //	if((getRace()==PROTOSS)&&(program[ip].facility==PROBE))
> < > //		while(true);
> < > 
> < > 	return(program[ip].facility);
> < > }
> < 188a280,739
> < > inline const unsigned int ANARACE::getProgramBT(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramBT): Value ip out of range.");return(0);
> < > 	}
> < > 	if(program[ip].BT >= MAX_TIME) {
> < > 		toLog("DEBUG: (ANARACE::getProgramBT): Variable not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].BT);
> < > }																	  
> < > 
> < > inline const unsigned int ANARACE::getProgramSuccessType(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Value ip out of range.");return(0);
> < > 	}
> < > 	if(program[ip].successType >= ERROR_MESSAGES) {
> < > 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Variable not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].successType);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getProgramSuccessUnit(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Value ip out of range.");return(0);
> < > 	}
> < > 	if(program[ip].successUnit >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Variable not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].successUnit);
> < > }
> < > 
> < > /*inline void ANARACE::setProgramIsConstant(const unsigned int ip, const bool isConstant)
> < > {
> < > 		if((ip >= MAX_LENGTH)) {
> < > 				toLog("DEBUG: (ANARACE::setProgramIsConstant): Value ip out of range.");return(0);
> < > 		}
> < > 		program[ip].isConstant = isConstant;
> < > };*/
> < > 
> < > inline void ANARACE::setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value ip out of range.");return;
> < > 	}
> < > 	if(unit_type >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_type out of range.");return;
> < > 	}
> < > 	if(unit_count >= MAX_TOTAL_UNITS) {
> < > 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_count out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].availibleCount[unit_type] = unit_count;
> < > }
> < > 
> < > inline void ANARACE::setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value ip out of range.");return;
> < > 	}
> < > 	if(unit_type >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_type out of range.");return;
> < > 	}
> < > 	if(unit_count >= MAX_TOTAL_UNITS) {
> < > 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_count out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].forceCount[unit_type] = unit_count;
> < > }
> < > 
> < > // first time is 0!
> < > inline void ANARACE::setProgramTime(const unsigned int ip, const unsigned int program_time)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramTime): Value ip out of range.");return;
> < > 	}
> < > 	if(program_time > configuration.getMaxTime()) {
> < > 		toLog("DEBUG: (ANARACE::setProgramTime): Value program_time out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].time = program_time;
> < > }
> < > 
> < > inline void ANARACE::setProgramBT(const unsigned int ip, const unsigned int program_bt)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramBT): Value ip out of range.");return;
> < > 	}
> < > 	if(program_bt >= MAX_TIME) {
> < > 		toLog("DEBUG: (ANARACE::setProgramBT): Value program_bt out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].BT = program_bt;
> < > }
> < > 
> < > inline void ANARACE::setProgramIsBuilt(const unsigned int ip, const bool program_is_built)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramIsBuilt): Value ip out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].built = program_is_built;
> < > }
> < > 
> < > inline void ANARACE::setProgramLocation(const unsigned int ip, const unsigned int program_location)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramLocation): Value ip out of range.");return;
> < > 	}
> < > 	if(program_location >= MAX_LOCATIONS) {
> < > 		toLog("DEBUG: (ANARACE::setProgramLocation): Value program_location out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].location = program_location;
> < > }
> < > // ------ STATISTICS SET FUNCTIONS ------
> < > inline void ANARACE::setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value ip out of range.");return;
> < >     }
> < > 	if(need_supply > 10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value need_supply out of range.");return;
> < > 	}
> < > #endif
> < > 	ipStatistics[ip].needSupply = need_supply;
> < > }
> < > 
> < > inline void ANARACE::setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value ip out of range.");return;
> < >     }
> < > 	if(have_supply > 10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value have_supply out of range.");return;
> < > 	}
> < > #endif
> < > 	ipStatistics[ip].haveSupply = have_supply;
> < > }
> < > 
> < > inline void ANARACE::setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value ip out of range.");return;
> < >     }
> < > 	if(have_minerals >= MAX_MINERALS) {
> < > 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value have_minerals out of range.");return;
> < > 	}
> < > #endif
> < > 	ipStatistics[ip].minerals = have_minerals;
> < > }
> < > 																				
> < > inline void ANARACE::setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value ip out of range.");return;
> < >     }
> < > 	if(have_gas >= MAX_GAS) {
> < > 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value have_gas out of range.");return;
> < > 	}
> < > #endif
> < > 	ipStatistics[ip].gas = have_gas;
> < > }
> < > 
> < > inline void ANARACE::setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value ip out of range.");return;
> < >     }
> < > 	if(fitness > MAX_PFITNESS) {
> < > 		toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value fitness out of range.");return;
> < > 	}
> < > #endif
> < > 	ipStatistics[ip].fitness = fitness;
> < > }
> < > 
> < > 
> < > inline void ANARACE::setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time>=MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value time out of range.");return;
> < >     }
> < > 	if(need_supply>10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value need_supply out of range.");return;
> < > 	}
> < > #endif
> < > 	timeStatistics[time].needSupply = need_supply;
> < > }
> < > 
> < > inline void ANARACE::setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time>=MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value time out of range.");return;
> < >     }
> < > 	if(have_supply>10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value have_supply out of range.");return;
> < > 	}
> < > #endif
> < > 	timeStatistics[time].haveSupply = have_supply;
> < > }
> < > 
> < > inline void ANARACE::setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time >= MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value time out of range.");return;
> < >     }
> < > 	if(have_minerals >= MAX_MINERALS) {
> < > 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value have_minerals out of range.");return;
> < > 	}
> < > #endif
> < > 	timeStatistics[time].minerals = have_minerals;
> < > }
> < > 																				
> < > inline void ANARACE::setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time >= MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value time out of range.");return;
> < >     }
> < > 	if(have_gas >= MAX_GAS) {
> < > 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value have_gas out of range.");return;
> < > 	}
> < > #endif
> < > 	timeStatistics[time].gas = have_gas;
> < > }
> < > 
> < > inline void ANARACE::setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness)
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time>=MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value time out of range.");return;
> < >     }
> < > 	if(fitness>MAX_PFITNESS) {
> < > 		toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value fitness out of range.");return;
> < > 	}
> < > #endif
> < > 	timeStatistics[time].fitness=fitness;
> < > }
> < > // ------ END OF STATISTICS SET FUNCTIONS ------
> < > 
> < > 
> < > inline const unsigned int ANARACE::getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const	   // how many units of the type at phaenoCode[s] do exist at that time?
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value ip out of range.");return(0);
> < > 	}
> < > 	if(unit_type >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value unit_type out of range.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].forceCount[unit_type]);
> < > }
> < > 
> < > // how many units of the type at phaenoCode[s] do exist at that time?
> < > inline const unsigned int ANARACE::getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const	   
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value ip out of range.");return(0);
> < > 	}
> < > 	if(unit_type >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value unit_type out of range.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].availibleCount[unit_type]);
> < > }
> < > 
> < > inline void ANARACE::setProgramFacility(const unsigned int ip, const unsigned int facility)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramFacility): Value ip out of range.");return;
> < > 	}
> < > 	if(facility>=UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::setProgramFacility): Value facility out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].facility = facility;
> < > }
> < > 
> < > inline void ANARACE::setProgramSuccessType(const unsigned int ip, const unsigned int type)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value ip out of range.");return;
> < > 	}
> < > 	if(type >= ERROR_MESSAGES) {
> < > 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value type out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].successType = type;
> < > }
> < > 
> < > inline void ANARACE::setProgramSuccessUnit(const unsigned int ip, const unsigned int unit_type)
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value ip out of range.");return;
> < > 	}
> < > 	if(unit_type >= UNIT_TYPE_COUNT) {
> < > 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value unit_type out of range.");return;
> < > 	}
> < > #endif
> < > 	program[ip].successUnit = unit_type;
> < > }
> < > 
> < > // ------ STATISTICS GET FUNCTIONS ------
> < > inline const unsigned int ANARACE::getIPStatisticsNeedSupply(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Value ip out of range.");return(0);
> < >     }
> < > 	if(ipStatistics[ip].needSupply > 10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Variable ipStatistics.needSupply not initialized.");	return(0);
> < > 	}
> < > #endif
> < > 	return(ipStatistics[ip].needSupply);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getIPStatisticsHaveSupply(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Value ip out of range.");return(0);
> < >     }
> < > 	if(ipStatistics[ip].haveSupply > 10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Variable ipStatistics.haveSupply not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(ipStatistics[ip].haveSupply);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getIPStatisticsHaveMinerals(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < > 	        toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Value ip out of range.");return(0);
> < > 	}
> < > 	if(ipStatistics[ip].minerals > MAX_MINERALS) {
> < > 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Variable ipStatistics.minerals not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(ipStatistics[ip].minerals);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getIPStatisticsHaveGas(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Value ip out of range.");return(0);
> < >     }
> < > 	if(ipStatistics[ip].gas > MAX_GAS) {
> < > 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Variable ipStatistics.gas not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(ipStatistics[ip].gas);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getIPStatisticsFitness(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((ip >= 2*MAX_LENGTH)) {
> < >         toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Value ip out of range.");return(0);
> < >     }
> < > 	// TODO max pfitness 
> < > 	if(ipStatistics[ip].fitness>MAX_PFITNESS) {
> < > 		toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Variable ipStatistics.fitness not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(ipStatistics[ip].fitness);
> < > }
> < > 
> < > 
> < > inline const unsigned int ANARACE::getTimeStatisticsNeedSupply(const unsigned int time) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time>=MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Value time out of range.");return(0);
> < >     }
> < > 	if(timeStatistics[time].needSupply>10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Variable timeStatistics.needSupply not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(timeStatistics[time].needSupply);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getTimeStatisticsHaveSupply(const unsigned int time) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time>=MAX_TIME)) {
> < >         toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Value time out of range.");return(0);
> < >     }
> < > 	if(timeStatistics[time].haveSupply>10*MAX_SUPPLY) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Variable timeStatistics.haveSupply not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(timeStatistics[time].haveSupply);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getTimeStatisticsHaveMinerals(const unsigned int time) const
> < > {
> < > #ifdef _SCC_DEBUG
> < >     if((time>=MAX_TIME)) {
> < > 	        toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Value time out of range.");return(0);
> < > 	}
> < > 	if(timeStatistics[time].minerals>MAX_MINERALS) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Variable timeStatistics.minerals not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(timeStatistics[time].minerals);
> < > }
> < > inline const unsigned int ANARACE::getTimeStatisticsHaveGas(const unsigned int time) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((time>=MAX_TIME)) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Value time out of range.");return(0);
> < > 	}
> < > 	if(timeStatistics[time].gas>MAX_GAS) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Variable timeStatistics.gas not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(timeStatistics[time].gas);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getTimeStatisticsFitness(const unsigned int time) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((time>=MAX_TIME)) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Value time out of range.");return(0);
> < > 	}
> < > 	// TODO max pfitness 
> < > 	if(timeStatistics[time].fitness>MAX_PFITNESS) {
> < > 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Variable timeStatistics.fitness not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(timeStatistics[time].fitness);
> < > }
> < 191c742,800
> < < inline const unsigned int ANARACE::getTimePercentage() const {
> < ---
> < > inline const bool ANARACE::getProgramIsBuilt(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramIsBuilt): Value ip out of range.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].built);
> < > }
> < > 
> < > 
> < > /*const bool ANARACE::getProgramIsConstant(const unsigned int ip)
> < > {
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramIsConstant): Value ip [%i] out of range.",IP);return(false);
> < > 	}
> < > 	return(program[ip].isConstant);
> < > };*/
> < > 
> < > // first program time is
> < > inline const unsigned int ANARACE::getProgramTime(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramTime): Value ip out of range.");return(0);
> < > 	}
> < > 	if(program[ip].time > configuration.getMaxTime()) {
> < > 		toLog("DEBUG: (ANARACE::getProgramTime): Variable not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].time);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getRealProgramTime(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
> < > 	}
> < > #endif
> < > 	return(configuration.getMaxTime() - getProgramTime(ip));
> < > }
> < > 
> < > 
> < > inline const unsigned int ANARACE::getProgramLocation(const unsigned int ip) const
> < > {
> < > #ifdef _SCC_DEBUG
> < > 	if((ip >= MAX_LENGTH)) {
> < > 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
> < > 	}
> < > 	if(program[ip].location > MAX_LOCATIONS) {
> < > 		toLog("DEBUG: (ANARACE::getProgramLocation): Variable program.location not initialized.");return(0);
> < > 	}
> < > #endif
> < > 	return(program[ip].location);
> < > }
> < > 
> < > inline const unsigned int ANARACE::getTimePercentage() const
> < > {
> < 195c804,805
> < < inline const unsigned int ANARACE::getFastestGoalTime() const {
> < ---
> < > inline const unsigned int ANARACE::getFastestGoalTime() const
> < > {
> < 198,199c808,809
> < < 
> < < inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const {
> < ---
> < > inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const
> < > {
> < 296,299c906,909
> < < #ifdef _SCC_DEBUG       
> < <         if(maxtFitness > MAX_TFITNESS) {
> < <                 toLog("DEBUG: (ANARACE::getMaxtFitness): Variable maxtFitness not initialized.");return(0);
> < <         }
> < ---
> < > #ifdef _SCC_DEBUG	
> < > 	if(maxtFitness > MAX_TFITNESS) {
> < > 		toLog("DEBUG: (ANARACE::getMaxtFitness): Variable maxtFitness not initialized.");return(0);
> < > 	}
> < 301c911
> < <         return(maxtFitness);
> < ---
> < > 	return(maxtFitness);
> < 304d913
> < < 
> < 325c934,935
> < < inline void ANARACE::setTotalGeneration(const unsigned int total_generation) {
> < ---
> < > inline void ANARACE::setTotalGeneration(const unsigned int total_generation)
> < > {
> < 332c942
> < < // TODO maxpitness
> < ---
> < > 	// TODO maxpitness
> < 353,355c963,965
> < <         if(max_tfitness > MAX_TFITNESS) {
> < <                 toLog("DEBUG: (ANARACE::setMaxtFitness): Value out of range.");return;
> < <         }
> < ---
> < > 	if(max_tfitness > MAX_TFITNESS) {
> < > 		toLog("DEBUG: (ANARACE::setMaxtFitness): Value out of range.");return;
> < > 	}
> < 357c967
> < <         maxtFitness = max_tfitness;
> < ---
> < > 	maxtFitness = max_tfitness;
> < 358a969
> < > //int getProgramSuccessType(int IP);
> < Files ./anarace.o and /home/claw/work/sc1063b/sc/core/anarace.o differ
> < diff ./basicmap.cpp /home/claw/work/sc1063b/sc/core/basicmap.cpp
> < 2d1
> < < #include <iostream>
> < 26,43d24
> < < unsigned int BASIC_MAP::calculateDistance(unsigned int i, unsigned int j)
> < < {
> < < 	if(i==j)
> < < 		return(0);
> < < 	if(location[i].getDistance(j) < 9999)
> < < 		return(location[i].getDistance(j));
> < < 	unsigned int min = 9999;
> < < 	for(unsigned int k=1;k<getMaxLocations();k++)
> < < 		if(location[i].getDistance(k) < 9999)
> < < 		{
> < < 			unsigned int temp = location[i].getDistance(k) + calculateDistance(j, k);
> < < 			if(temp < min)
> < < 				min = temp;
> < < 		}
> < < 	return(min);	
> < < }
> < < 
> < < 
> < 46,71c27
> < < 	for(unsigned int i=1;i<getMaxLocations();i++)
> < < 		for(unsigned int j=1;j<getMaxLocations();j++)
> < < 			if(location[i].getDistance(j) < 9999)
> < < 				location[j].setDistance(i, location[i].getDistance(j));
> < < 
> < < 	for(unsigned int i = 1; i < getMaxLocations(); i++)
> < < 	{
> < < 		std::cout << "Location " << i << " ";
> < < 		for(unsigned int j = 1; j < getMaxLocations(); j++)
> < < 			std::cout << getLocation(i)->getDistance(j) << " ";
> < < 		std::cout << std::endl;
> < < 	}
> < < 				
> < < 	for(unsigned int i=1;i<getMaxLocations();i++)
> < < 		for(unsigned int j=1;j<getMaxLocations();j++)
> < < 			location[i].setDistance(j, calculateDistance(i, j));
> < < 
> < < 	for(unsigned int i = 1; i < getMaxLocations(); i++)
> < < 	{
> < < 		std::cout << "Location " << i << " ";
> < < 		for(unsigned int j = 1; j < getMaxLocations(); j++)
> < < 			std::cout << getLocation(i)->getDistance(j) << " ";
> < < 		std::cout << std::endl;
> < < 	}
> < < 
> < < 	for(unsigned int i=1;i<getMaxLocations();i++)
> < ---
> < > 	for(int i=1;i<MAX_LOCATIONS;i++)
> < diff ./basicmap.hpp /home/claw/work/sc1063b/sc/core/basicmap.hpp
> < 17d16
> < < 		unsigned int calculateDistance(unsigned int i, unsigned int j);
> < 36c35
> < < 		void setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance);
> < ---
> < > 		void setLocationDistance(const unsigned int location_number, std::list<std::string> distances);// needs never be changed so a list is fine
> < 75c74
> < < 	if((location_number >= maxLocations)) {
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < 85c84
> < < 	if((location_number >= maxLocations)) {
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < 95c94
> < < 	if((location_number >= maxLocations)) {
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < 105c104
> < < 	if((location_number >= maxLocations)) {
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < 115c114
> < < 	if((location_number >= maxLocations)) {
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < 125c124
> < < 	if((location_number >= maxLocations)) {
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < 132c131
> < < inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance)
> < ---
> < > inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const std::list<std::string> distances)
> < 135,136c134,135
> < < 	if((location_number >= maxLocations)) {
> < < 		toLog("DEBUG: (MAP::setLocationDistance): Value location_number out of range.");return;
> < ---
> < > 	if((location_number >= MAX_LOCATIONS)) {
> < > 		toLog("DEBUG: (MAP::setLocationDistance): Value out of range.");return;
> < 138,139c137,138
> < < 	if((target >= maxLocations)) {
> < < 		toLog("DEBUG: (MAP::setLocationDistance): Value target out of range.");return;
> < ---
> < > 	if(location_number >= distances.size()) {
> < > 		toLog("DEBUG: (MAP::setLocationDistance): Too many locations.");return;
> < 141,144d139
> < < //	if(distance >= 1000) {
> < < //		toLog("DEBUG: (MAP::setLocationDistance): Value distance out of range.");return;
> < < //	}
> < < 	
> < 146c141,153
> < < 	location[location_number].setDistance(target, distance);
> < ---
> < > 	std::list<std::string>::const_iterator i=distances.begin();
> < > 	unsigned int j=0;
> < > 	while(i!=distances.end())
> < > 	{
> < > 		location[location_number].setDistance(j, atoi(i->c_str()));
> < > 		i++;
> < > 		j++;
> < > 	}
> < > #ifdef _SCC_DEBUG
> < > 	if( j < location_number ) {
> < > 		toLog("DEBUG: (MAP::setLocationDistance): Not enough locations.");return;
> < > 	}
> < > #endif		
> < 157d163
> < < 	MAP_LOCATION::setMaxLocations(max_locations);
> < 173c179
> < < 	if(location_number >= maxLocations) {
> < ---
> < > 	if(location_number >= MAX_LOCATIONS) {
> < 179a186,187
> < > 
> < > 
> < Files ./basicmap.o and /home/claw/work/sc1063b/sc/core/basicmap.o differ
> < diff ./building.cpp /home/claw/work/sc1063b/sc/core/building.cpp
> < 9c9
> < < //	IP(0),
> < ---
> < > 	IP(0),
> < 21c21
> < < //	IP(object.IP),
> < ---
> < > 	IP(object.IP),
> < 34c34
> < < //	IP = object.IP;
> < ---
> < > 	IP = object.IP;
> < diff ./building.hpp /home/claw/work/sc1063b/sc/core/building.hpp
> < 8,30c8,30
> < < 	private:
> < < 		unsigned int totalBuildTime;
> < < 		signed int buildFinishedTime; // timestamp when item is finnished (3600 = beginning)
> < < 		unsigned int type;			  // Type of Building
> < < 		unsigned int unitCount;  // number of units which are moving... currently ONLY for movements...
> < < 		unsigned int facility;   // in what facility it was produced
> < < //		unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
> < < 		unsigned int location;   // where the building was finished
> < < 		unsigned int goal;			  // For movement, where the units will move to, not yet fully implemented
> < < 		bool onTheRun;   // is this building/unit moving around or is it under construction at some place?
> < < 	public:
> < < 
> < < 		Building();
> < < 		Building(const Building& object);
> < < 		Building& operator=(const Building& object);
> < < 		friend bool operator<(const Building& x, const Building& y)
> < < 		{
> < < 			if(x.getBuildFinishedTime() < y.getBuildFinishedTime())
> < < 				return(true);
> < < 			return(false);
> < < 		};
> < < 		const unsigned int getTotalBuildTime() const;
> < < 		const unsigned int getBuildFinishedTime() const;
> < ---
> < > private:
> < > 	unsigned int totalBuildTime;
> < > 	signed int buildFinishedTime; // timestamp when item is finnished (3600 = beginning)
> < > 	unsigned int type;			  // Type of Building
> < > 	unsigned int unitCount;  // number of units which are moving... currently ONLY for movements...
> < > 	unsigned int facility;   // in what facility it was produced
> < > 	unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
> < > 	unsigned int location;   // where the building was finished
> < > 	unsigned int goal;			  // For movement, where the units will move to, not yet fully implemented
> < > 	bool onTheRun;   // is this building/unit moving around or is it under construction at some place?
> < > public:
> < > 	friend bool operator<(const Building& x, const Building& y)
> < > 	{
> < > 		if(x.getBuildFinishedTime() < y.getBuildFinishedTime())
> < > 			return(true);
> < > 		return(false);
> < > 	}
> < > 	Building();
> < > 	Building(const Building& object);
> < > 	Building& operator=(const Building& object);
> < > 	
> < > 	const unsigned int getTotalBuildTime() const;
> < > 	const unsigned int getBuildFinishedTime() const;
> < 33c33
> < < 		const bool canBeCompleted() const;
> < ---
> < > 	const bool canBeCompleted() const;
> < 35,41c35,41
> < < 		const unsigned int getType() const;
> < < 		const unsigned int getUnitCount() const;
> < < 		const unsigned int getFacility() const;
> < < //		const unsigned int getIP() const;
> < < 		const unsigned int getLocation() const;
> < < 		const unsigned int getGoal() const;
> < < 		const bool getOnTheRun() const;
> < ---
> < > 	const unsigned int getType() const;
> < > 	const unsigned int getUnitCount() const;
> < > 	const unsigned int getFacility() const;
> < > 	const unsigned int getIP() const;
> < > 	const unsigned int getLocation() const;
> < > 	const unsigned int getGoal() const;
> < > 	const bool getOnTheRun() const;
> < 43,44c43,44
> < < 		void setTotalBuildTime(const unsigned int total_build_time);
> < < 		void setBuildFinishedTime(const signed int build_finished_time);
> < ---
> < > 	void setTotalBuildTime(const unsigned int total_build_time);
> < > 	void setBuildFinishedTime(const signed int build_finished_time);
> < 46,52c46,52
> < < 		void setType(const unsigned int building_type);
> < < 		void setUnitCount(const unsigned int building_count);
> < < 		void setFacility(const unsigned int building_facility);
> < < //		void setIP(const unsigned int building_IP);
> < < 		void setLocation(const unsigned int building_location);
> < < 		void setGoal(const unsigned int building_goal);
> < < 		void setOnTheRun(const bool building_on_the_run);
> < ---
> < > 	void setType(const unsigned int building_type);
> < > 	void setUnitCount(const unsigned int building_count);
> < > 	void setFacility(const unsigned int building_facility);
> < > 	void setIP(const unsigned int building_IP);
> < > 	void setLocation(const unsigned int building_location);
> < > 	void setGoal(const unsigned int building_goal);
> < > 	void setOnTheRun(const bool building_on_the_run);
> < 107c107
> < < /*inline const unsigned int Building::getIP() const
> < ---
> < > inline const unsigned int Building::getIP() const
> < 115c115
> < < }*/
> < ---
> < > }
> < 120c120
> < < 	if(location >= MAX_LOCATIONS) { // TODO
> < ---
> < > 	if(location > MAX_LOCATIONS) {
> < 197c197
> < < /*inline void Building::setIP(const unsigned int building_IP)
> < ---
> < > inline void Building::setIP(const unsigned int building_IP)
> < 205c205
> < < }*/
> < ---
> < > }
> < Files ./building.o and /home/claw/work/sc1063b/sc/core/building.o differ
> < diff ./configuration.hpp /home/claw/work/sc1063b/sc/core/configuration.hpp
> < 9a10
> < > #include <deque>
> < Files ./configuration.o and /home/claw/work/sc1063b/sc/core/configuration.o differ
> < diff ./defs.cpp /home/claw/work/sc1063b/sc/core/defs.cpp
> ---
> > Files ./anarace.o and /home/claw/work/sc1061/sc/core/anarace.o differ
> > Files ./basicmap.o and /home/claw/work/sc1061/sc/core/basicmap.o differ
> > Files ./building.o and /home/claw/work/sc1061/sc/core/building.o differ
> > diff -r -b -B ./configuration.cpp /home/claw/work/sc1061/sc/core/configuration.cpp
> > 499,557c499,557
> > < 	pFile << "@SETTINGS" << endl;
> > < 	pFile << "# 1 = english, 2 = german" << endl;
> > < 	pFile << "    \"Language\" = \"" << (int)getLanguage() << "\"" << endl;
> > < 	pFile << "# max time in seconds" << endl;
> > < 	pFile << "    \"Max Time\" = \"" << getMaxTime() << "\"" << endl;
> > < 	pFile << "# Do autosave at the end of a run or ask for it?" << endl;
> > < 	pFile << "    \"Autosave runs\" = \"" << (int)isAutoSaveRuns() << "\"" << endl;
> > < 	pFile << "# Preprocessing not implemented yet" << endl;
> > < 	pFile << "    \"Preprocess Buildorder\" = \"" << (int)isPreprocessBuildOrder() << "\"" << endl;
> > < 	pFile << "    \"Max unchanged Generations\" = \"" << getMaxGenerations() << "\"" << endl;
> > < 	pFile << "    \"Max Length\" = \"" << getMaxLength() << "\"" << endl;
> > < 	pFile << "    \"Max Runs\" = \"" << getMaxRuns() << "\"" << endl;
> > < 	pFile << "# max timeout for each order in seconds" << endl;
> > < 	pFile << "    \"Max Timeout\" = \"" << getMaxTimeOut() << "\"" << endl;
> > < 	pFile << "# Allow to ignore unnecessary goals (mainly for using for example only \"lair\" instead of both \"lair\" and \"hatchery\")" << endl;
> > < 	pFile << "    \"Allow goal adaption\" = \"" << (int)isAllowGoalAdaption() << "\"" << endl;
> > < 	pFile << "# Breed Factor:" << endl;
> > < 	pFile << "# This parameter determines how many % of the players will multiply by 1:1 copy" << endl;
> > < 	pFile << "    \"Breed Factor\" = \"" << getBreedFactor() << "\"" << endl;
> > < 	pFile << "# Crossing Over:" << endl;
> > < 	pFile << "# This parameter determines how many % of the players will multiply by crossover# CURRENTLY NOT IMPLEMENTED!" << endl;
> > < 	pFile << "    \"Crossing Over\" = \"" << getCrossingOver() << "\"" << endl;
> > < 	pFile << "# 10 means that programs will be sorted into 10-program groups, the best 2 are" << endl;
> > < 	pFile << "# taken for reproduction and the worst two are replaced by their children" << endl;
> > < 	pFile << "" << endl;                                                       
> > < 	pFile << "# GUI SETTINGS:" << endl;
> > < 	pFile << "" << endl;            
> > < 	pFile << "# set this to 1 to set all details to zero, fastest output" << endl;
> > < 	pFile << "# Real minimalists should take a look at the command line options where SDL can be deactivated completely! 8-DD" << endl;
> > < 	pFile << "# CURRENTLY NOT IMPLEMENTED" << endl;
> > < 	pFile << "    \"Minimalist\" = \"0\"" << endl; // TODO
> > < 	pFile << "" << endl;
> > < 	pFile << "# how a frame update is weighted compared to a core update (e.g. 4 means that a new generation is calculated every 4 frames)" << endl;
> > < 	pFile << "    \"Allow static framerate\" = \"" << (int)isAllowStaticFramerate() << "\"" << endl;
> > < 	pFile << "# allow the program to dynamicly reduce the speed of the core to reach this frame rate. 0 = offline." << endl;
> > < 	pFile << "    \"Static framerate\" = \"" << getStaticFramerate() << "\"" << endl;
> > < 	pFile << "# Draw X frames per new generation" << endl;
> > < 	pFile << "    \"Dynamic framerate\" = \"" << getDynamicFramerate() << "\"" << endl;
> > < 	pFile << "" << endl;                                                                                
> > < 	pFile << "# Order entries in the unitmenu by area or by facility?" << endl;
> > < 	pFile << "    \"Facility mode\" = \"" << (int)isFacilityMode() << "\"" << endl;
> > < 	pFile << "# glowing effects" << endl;
> > < 	pFile << "    \"Glowing buttons\" = \"" << (int)isGlowingButtons() << "\"" << endl;
> > < 	pFile << "# Show nice DNA spiral?" << endl;
> > < 	pFile << "    \"DNA Spiral\" = \"" << (int)isDnaSpiral() << "\"" << endl;
> > < 	pFile << "# moving rectangles, 2 = all objects move smoothly, 1 = some objects move smoothly, 0 = all objects jump directly to their destination" << endl;
> > < 	pFile << "    \"Smooth movements\" = \"" << (int)isSmoothMovements() << "\"" << endl;
> > < 	pFile << "# Rounded rectangles, saves a little cpu power if deactivated (the computer loves simple object :-D" << endl;
> > < 	pFile << "# CURRENTLY NOT IMPLEMENTED" << endl;
> > < 	pFile << "    \"Rounded rectangles\" = \"1\"" << endl; // TODO
> > < 	pFile << "# use background bitmap, saves some cpu power if deactivated" << endl;
> > < 	pFile << "    \"Background bitmap\" = \"" << (int)isBackgroundBitmap() << "\"" << endl;
> > < 	pFile << "# Transparency, let's burn some cpu power" << endl;
> > < 	pFile << "    \"Transparency\" = \"" << (int)isTransparency() << "\"" << endl;
> > < 	pFile << endl;                                                                                
> > < 	pFile << "    \"Tooltips\" = \"" << (int)isTooltips() << "\"" << endl;
> > < 	pFile << "    \"Fullscreen\" = \"" << (int)isFullScreen() << "\"" << endl;
> > < 	pFile << "    \"Software mouse\" = \"" << (int)isSoftwareMouse() << "\"" << endl;
> > < 	pFile << "@END" << endl;
> > ---
> > > pFile << "@SETTINGS" << endl;
> > > pFile << "# 1 = english, 2 = german" << endl;
> > > pFile << "    \"Language\" = \"" << getLanguage() << "\"" << endl;
> > > pFile << "# max time in seconds" << endl;
> > > pFile << "    \"Max Time\" = \"" << getMaxTime() << "\"" << endl;
> > > pFile << "# Do autosave at the end of a run or ask for it?" << endl;
> > > pFile << "    \"Autosave runs\" = \"" << (int)isAutoSaveRuns() << "\"" << endl;
> > > pFile << "# Preprocessing not implemented yet" << endl;
> > > pFile << "    \"Preprocess Buildorder\" = \"" << (int)isPreprocessBuildOrder() << "\"" << endl;
> > > pFile << "    \"Max unchanged Generations\" = \"" << getMaxGenerations() << "\"" << endl;
> > > pFile << "    \"Max Length\" = \"" << getMaxLength() << "\"" << endl;
> > > pFile << "    \"Max Runs\" = \"" << getMaxRuns() << "\"" << endl;
> > > pFile << "# max timeout for each order in seconds" << endl;
> > > pFile << "    \"Max Timeout\" = \"" << getMaxTimeOut() << "\"" << endl;
> > > pFile << "# Allow to ignore unnecessary goals (mainly for using for example only \"lair\" instead of both \"lair\" and \"hatchery\")" << endl;
> > > pFile << "    \"Allow goal adaption\" = \"" << (int)isAllowGoalAdaption() << "\"" << endl;
> > > pFile << "# Breed Factor:" << endl;
> > > pFile << "# This parameter determines how many % of the players will multiply by 1:1 copy" << endl;
> > > pFile << "    \"Breed Factor\" = \"" << getBreedFactor() << "\"" << endl;
> > > pFile << "# Crossing Over:" << endl;
> > > pFile << "# This parameter determines how many % of the players will multiply by crossover# CURRENTLY NOT IMPLEMENTED!" << endl;
> > > pFile << "    \"Crossing Over\" = \"" << getCrossingOver() << "\"" << endl;
> > > pFile << "# 10 means that programs will be sorted into 10-program groups, the best 2 are" << endl;
> > > pFile << "# taken for reproduction and the worst two are replaced by their children" << endl;
> > > pFile << "" << endl;                                                       
> > > pFile << "# GUI SETTINGS:" << endl;
> > > pFile << "" << endl;            
> > > pFile << "# set this to 1 to set all details to zero, fastest output" << endl;
> > > pFile << "# Real minimalists should take a look at the command line options where SDL can be deactivated completely! 8-DD" << endl;
> > > pFile << "# CURRENTLY NOT IMPLEMENTED" << endl;
> > > pFile << "    \"Minimalist\" = \"0\"" << endl; // TODO
> > > pFile << "" << endl;
> > > pFile << "# how a frame update is weighted compared to a core update (e.g. 4 means that a new generation is calculated every 4 frames)" << endl;
> > > pFile << "    \"Allow static framerate\" = \"" << (int)isAllowStaticFramerate() << "\"" << endl;
> > > pFile << "# allow the program to dynamicly reduce the speed of the core to reach this frame rate. 0 = offline." << endl;
> > > pFile << "    \"Static framerate\" = \"" << getStaticFramerate() << "\"" << endl;
> > > pFile << "# Draw X frames per new generation" << endl;
> > > pFile << "    \"Dynamic framerate\" = \"" << getDynamicFramerate() << "\"" << endl;
> > > pFile << "" << endl;                                                                                
> > > pFile << "# Order entries in the unitmenu by area or by facility?" << endl;
> > > pFile << "    \"Facility mode\" = \"" << (int)isFacilityMode() << "\"" << endl;
> > > pFile << "# glowing effects" << endl;
> > > pFile << "    \"Glowing buttons\" = \"" << (int)isGlowingButtons() << "\"" << endl;
> > > pFile << "# Show nice DNA spiral?" << endl;
> > > pFile << "    \"DNA Spiral\" = \"" << (int)isDnaSpiral() << "\"" << endl;
> > > pFile << "# moving rectangles, 2 = all objects move smoothly, 1 = some objects move smoothly, 0 = all objects jump directly to their destination" << endl;
> > > pFile << "    \"Smooth movements\" = \"" << (int)isSmoothMovements() << "\"" << endl;
> > > pFile << "# Rounded rectangles, saves a little cpu power if deactivated (the computer loves simple object :-D" << endl;
> > > pFile << "# CURRENTLY NOT IMPLEMENTED" << endl;
> > > pFile << "    \"Rounded rectangles\" = \"1\"" << endl; // TODO
> > > pFile << "# use background bitmap, saves some cpu power if deactivated" << endl;
> > > pFile << "    \"Background bitmap\" = \"" << (int)isBackgroundBitmap() << "\"" << endl;
> > > pFile << "# Transparency, let's burn some cpu power" << endl;
> > > pFile << "    \"Transparency\" = \"" << (int)isTransparency() << "\"" << endl;
> > > pFile << endl;                                                                                
> > > pFile << "    \"Tooltips\" = \"" << (int)isTooltips() << "\"" << endl;
> > > pFile << "    \"Fullscreen\" = \"" << (int)isFullScreen() << "\"" << endl;
> > > pFile << "    \"Software mouse\" = \"" << (int)isSoftwareMouse() << "\"" << endl;
> > > pFile << "@END" << endl;
> > Files ./configuration.o and /home/claw/work/sc1061/sc/core/configuration.o differ
> > diff -r -b -B ./defs.cpp /home/claw/work/sc1061/sc/core/defs.cpp
> 1686,1694c128
> < < const std::string CORE_VERSION="Beta 1.63a";
> < ---
> < > const std::string CORE_VERSION="Beta 1.62final";
> < 198,202c198,202
> < < {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
> ---
> > < //const unsigned int UNIT_TYPE_COUNT = 105;
> 1696,1734c130,233
> < > {"Move 3 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Move 1 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Move 1 Backward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < 311,315c311,315
> < < {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
> < ---
> < > {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < 420,424c420,424
> < < {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < < {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
> < ---
> < > {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < > {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
> < diff ./defs.hpp /home/claw/work/sc1063b/sc/core/defs.hpp
> < 11c11
> < < #define MAX_LOCATIONS 5
> < ---
> < > #define MAX_LOCATIONS 3
> < 200,206c200,205
> < < 	BUILD_PARALLEL_2,
> < < 	BUILD_PARALLEL_4,
> < < 	BUILD_PARALLEL_8,
> < < 	BUILD_PARALLEL_16,
> ---
> > > //const unsigned int UNIT_TYPE_COUNT = 101;
> > 112c112
> > < // BUILD FREE ADDON PLACE FOR FACTORY, STARPORT ETC. WIE BEI RESEARCHES
> > ---
> > > 
> > 117,118c117,118
> > < {"SCV"	,					 20, 5000,    0,  1, 0, 0, {0, 0}, {0 ,0, 0}, {COMMAND_CENTER, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, WORKER_UNIT_TYPE},
> > < {"Space Marine", 		 		 24, 5000,    0,  1, 0, 0, {0, 0}, {0 ,0, 0}, {BARRACKS, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > ---
> > > {"SCV"	,					 20, 5000,    0,  1, 0, 0, {0, 0}, {0 ,0, 0}, {COMMAND_CENTER, COMMAND_CENTER_CS, COMMAND_CENTER_NS}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, WORKER_UNIT_TYPE},
> > > {"Marine", 			 		 24, 5000,    0,  1, 0, 0, {0, 0}, {0 ,0, 0}, {BARRACKS, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > 120,122c120,122
> > < {"Vulture",					 30, 7500,    0,  2, 0, 0, {0, 0}, {0, 0, 0}, {FACTORY, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > < {"Goliath",					 40,10000, 5000,  2, 0, 0, {0, 0}, {ARMORY, 0, 0}, {FACTORY, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > < {"Siege Tank", 				 50,15000,10000,  2, 0, 0, {0, 0}, {0 ,0, 0}, {FACTORY_MS, 0, 0}, FACTORY, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > ---
> > > {"Vulture",					 30, 7500,    0,  2, 0, 0, {0, 0}, {0, 0, 0}, {FACTORY, FACTORY_MS, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > > {"Goliath",					 40,10000, 5000,  2, 0, 0, {0, 0}, {ARMORY, 0, 0}, {FACTORY, FACTORY_MS, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > > {"Siege Tank", 				 50,15000,10000,  2, 0, 0, {0, 0}, {0 ,0, 0}, {FACTORY_MS, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > 125,129c125,129
> > < {"Wraith", 					 60,15000,10000,  2, 0, 0, {0, 0}, {0 ,0, 0}, {STARPORT, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > < {"Science Vessel", 			 80,10000,22500,  2, 0, 0, {0, 0}, {SCIENCE_FACILITY, 0, 0}, {STARPORT_CT, 0, 0}, STARPORT, NEEDED_UNTIL_COMPLETE, 0, 100, SUPPORT_UNIT_TYPE},
> > < {"Dropship", 				 50,10000,10000,  2, 0, 0, {0, 0}, {0, 0, 0}, {STARPORT_CT, 0, 0}, STARPORT, NEEDED_UNTIL_COMPLETE, 0, 100, SUPPORT_UNIT_TYPE},
> > < {"Battle Cruiser",			133,40000,30000,  6, 0, 0, {0, 0}, {SCIENCE_FACILITY_PL, 0, 0}, {STARPORT_CT, 0, 0}, STARPORT, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > < {"Valkyrie", 				 50,25000,12500,  3, 0, 0, {0, 0}, {ARMORY, 0, 0}, {STARPORT_CT, 0, 0}, STARPORT, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > ---
> > > {"Wraith", 					 60,15000,10000,  2, 0, 0, {0, 0}, {0 ,0, 0}, {STARPORT, STARPORT_CT, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > > {"Science Vessel", 			 80,10000,22500,  2, 0, 0, {0, 0}, {SCIENCE_FACILITY, 0, 0}, {STARPORT_CT, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, SUPPORT_UNIT_TYPE},
> > > {"Dropship", 				 50,10000,10000,  2, 0, 0, {0, 0}, {0, 0, 0}, {STARPORT_CT, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, SUPPORT_UNIT_TYPE},
> > > {"Battle Cruiser",			133,40000,30000,  6, 0, 0, {0, 0}, {SCIENCE_FACILITY_PL, 0, 0}, {STARPORT_CT, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > > {"Valkyrie", 				 50,25000,12500,  3, 0, 0, {0, 0}, {ARMORY, 0, 0}, {STARPORT_CT, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 100, COMBAT_UNIT_TYPE},
> > 134,137c134,137
> > < {"Factory", 				 80,20000,10000,  0, 0, 0, {0, 0}, {BARRACKS ,0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, F_FACTORY_ADDON, 10, PRODUCE_UNIT_TYPE},
> > < {"Command Center",			120,40000,    0,  0,10, 0, {0, 0}, {0, 0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, F_COMMAND_CENTER_ADDON, 10, SUPPLY_UNIT_TYPE},
> > < {"Starport", 				 70,15000,10000,  0, 0, 0, {0, 0}, {FACTORY ,0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, F_STARPORT_ADDON, 10, PRODUCE_UNIT_TYPE},
> > < {"Science Facility", 		 60,10000,15000,  0, 0, 0, {0, 0}, {STARPORT ,0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, F_SCIENCE_FACILITY_ADDON, 10, RESEARCH_FACILITY_UNIT_TYPE},
> > ---
> > > {"Factory", 				 80,20000,10000,  0, 0, 0, {0, 0}, {BARRACKS ,0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 10, PRODUCE_UNIT_TYPE},
> > > {"Command Center",			120,40000,    0,  0,10, 0, {0, 0}, {0, 0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 10, SUPPLY_UNIT_TYPE},
> > > {"Starport", 				 70,15000,10000,  0, 0, 0, {0, 0}, {FACTORY ,0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 10, PRODUCE_UNIT_TYPE},
> > > {"Science Facility", 		 60,10000,15000,  0, 0, 0, {0, 0}, {STARPORT ,0, 0}, {SCV, 0, 0}, 0, NEEDED_UNTIL_COMPLETE, 0, 10, RESEARCH_FACILITY_UNIT_TYPE},
> > 148,153c148,153
> > < {"Command Center[CS]", 		 40, 5000, 5000,  0,10, 0, {0, 0}, {ACADEMY, 0, 0}, {COMMAND_CENTER, 0, 0}, F_COMMAND_CENTER_ADDON, NEEDED_UNTIL_COMPLETE, COMSAT_STATION, 0, ADD_ON_UNIT_TYPE}, //TODO: Beim Abheben zerstoeren...
> > < {"Command Center[NS]", 		 40,10000,10000,  0,10, 0, {0, 0}, {SCIENCE_FACILITY_CO, 0, 0}, {COMMAND_CENTER, 0, 0}, F_COMMAND_CENTER_ADDON, NEEDED_UNTIL_COMPLETE, NUCLEAR_SILO, 0, ADD_ON_UNIT_TYPE},
> > < {"Starport[CT]", 			 80, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {STARPORT, 0, 0}, F_STARPORT_ADDON, NEEDED_UNTIL_COMPLETE, CONTROL_TOWER, 0, ADD_ON_UNIT_TYPE},
> > < {"Science Facility[CO]", 	 40, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, F_SCIENCE_FACILITY_ADDON, NEEDED_UNTIL_COMPLETE, COVERT_OPS, 0, ADD_ON_UNIT_TYPE},
> > < {"Science Facility[PL]", 	 40, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, F_SCIENCE_FACILITY_ADDON, NEEDED_UNTIL_COMPLETE, PHYSICS_LAB, 0, ADD_ON_UNIT_TYPE},
> > < {"Factory[MS]", 			 40, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {FACTORY, 0, 0}, F_FACTORY_ADDON, NEEDED_UNTIL_COMPLETE, MACHINE_SHOP, 0, ADD_ON_UNIT_TYPE},
> > ---
> > > {"Command Center[CS]", 		 40, 5000, 5000,  0,10, 0, {0, 0}, {ACADEMY, 0, 0}, {COMMAND_CENTER, 0, 0}, 0, IS_LOST, COMSAT_STATION, 0, ADD_ON_UNIT_TYPE}, //TODO: Beim Abheben zerstoeren...
> > > {"Command Center[NS]", 		 40,10000,10000,  0,10, 0, {0, 0}, {SCIENCE_FACILITY_CO, 0, 0}, {COMMAND_CENTER, 0, 0}, 0, IS_LOST, NUCLEAR_SILO, 0, ADD_ON_UNIT_TYPE},
> > > {"Starport[CT]", 			 80, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {STARPORT, 0, 0}, 0, IS_LOST, CONTROL_TOWER, 0, ADD_ON_UNIT_TYPE},
> > > {"Science Facility[CO]", 	 40, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, 0, IS_LOST, COVERT_OPS, 0, ADD_ON_UNIT_TYPE},
> > > {"Science Facility[PL]", 	 40, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, 0, IS_LOST, PHYSICS_LAB, 0, ADD_ON_UNIT_TYPE},
> > > {"Factory[MS]", 			 40, 5000, 5000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {FACTORY, 0, 0}, 0, IS_LOST, MACHINE_SHOP, 0, ADD_ON_UNIT_TYPE},
> > 156c156
> > < {"EMP Shockwave",			120,20000,20000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, R_EMP_SHOCKWAVE, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, RESEARCH_UNIT_TYPE},
> > ---
> > > {"EMP Shockwave",			120,20000,20000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, SCIENCE_FACILITY_CO, SCIENCE_FACILITY_PL}, R_EMP_SHOCKWAVE, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, RESEARCH_UNIT_TYPE},
> > 159c159
> > < {"Irradiate", 				 80,20000,20000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, R_IRRADIATE, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, RESEARCH_UNIT_TYPE},
> > ---
> > > {"Irradiate", 				 80,20000,20000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, SCIENCE_FACILITY_CO, SCIENCE_FACILITY_PL}, R_IRRADIATE, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, RESEARCH_UNIT_TYPE},
> > 167c167
> > < {"Titan Reactor",			166,15000,15000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, 0, 0}, R_TITAN_REACTOR, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, RESEARCH_UNIT_TYPE},
> > ---
> > > {"Titan Reactor",			166,15000,15000,  0, 0, 0, {0, 0}, {0 ,0, 0}, {SCIENCE_FACILITY, SCIENCE_FACILITY_CO, SCIENCE_FACILITY_PL}, R_TITAN_REACTOR, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, RESEARCH_UNIT_TYPE},
> > 217,221d216
> > < 
> > < {"F_Factory Addon",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, REMAINING_UNIT_TYPE},
> > < {"F_Starport Addon",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, REMAINING_UNIT_TYPE},
> > < {"F_Command Center Addon",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, REMAINING_UNIT_TYPE},
> > < {"F_Science Facility Addon",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, REMAINING_UNIT_TYPE},
> > 330,333d324
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > 341c332
> > < {"Zergling",				 28, 5000,    0,  1, 0, 0, {0, 0}, {SPAWNING_POOL ,0, 0}, {LARVA, 0, 0}, 0, IS_LOST, ZERGLING, 100, COMBAT_UNIT_TYPE},
> > ---
> > > {"Zergling",				 28, 5000,    0,  1, 0, 0, {0, 0}, {SPAWNING_POOL ,0, 0}, {LARVA, 0, 0}, 0, IS_LOST, 0, 100, COMBAT_UNIT_TYPE},
> > 352,353c343,344
> > < {"Lair",					100,15000,10000,  0, 1, 0, {0, 0}, {SPAWNING_POOL ,0, 0}, {HATCHERY, 0, 0}, 0, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, ADD_ON_UNIT_TYPE},
> > < {"Hive",					120,20000,15000,  0, 1, 0, {0, 0}, {QUEENS_NEST ,0, 0}, {LAIR, 0, 0}, 0, NEEDED_UNTIL_COMPLETE_IS_LOST, 0, 0, ADD_ON_UNIT_TYPE},
> > ---
> > > {"Lair",					100,15000,10000,  0, 1, 0, {0, 0}, {SPAWNING_POOL ,0, 0}, {HATCHERY, 0, 0}, 0, IS_LOST, 0, 0, ADD_ON_UNIT_TYPE},
> > > {"Hive",					120,20000,15000,  0, 1, 0, {0, 0}, {QUEENS_NEST ,0, 0}, {LAIR, 0, 0}, 0, IS_LOST, 0, 0, ADD_ON_UNIT_TYPE},
> > 439,442d429
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > < {"NULL",					  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY_BEHAVIOUR_DEFINED, 0, 0, REMAINING_UNIT_TYPE},
> > diff -r -b -B ./defs.hpp /home/claw/work/sc1061/sc/core/defs.hpp
> > 10c10
> > < #define UNIT_TYPE_COUNT 105
> > ---
> > > #define UNIT_TYPE_COUNT 101
> > 233,238d232
> > < 
> > < 	F_FACTORY_ADDON,
> > < 	F_STARPORT_ADDON,
> > < 	F_COMMAND_CENTER_ADDON,
> > < 	F_SCIENCE_FACILITY_ADDON,
> 1736,1745c235,296
> < < 	FROM_GAS_TO_MINERALS,
> < < 	LAST_UNIT,// 70
> < ---
> < > 	MOVE_ONE_3_FORWARD,
> < > 	MOVE_ONE_1_FORWARD,
> < > 	MOVE_ONE_1_BACKWARD,
> < > 	ROTATE, 
> < > 	FOLLOW,// 70
> < > 	RESET,
> < Files ./defs.o and /home/claw/work/sc1063b/sc/core/defs.o differ
> ---
> > Files ./defs.o and /home/claw/work/sc1061/sc/core/defs.o differ
> > Only in ./: differ
> > Only in ./: .differ.swp
> > diff -r -b -B ./goal.cpp /home/claw/work/sc1061/sc/core/goal.cpp
> > 34,38d33
> > < bool GOAL::operator<(const GOAL& goal)
> > < {
> > < 	return(getLocation() < goal.getLocation());
> > < }
> > < 
> > diff -r -b -B ./goalentry.cpp /home/claw/work/sc1061/sc/core/goalentry.cpp
> > 199c199
> > < 		if((allGoal[i])||(isBuildable[i]))
> > ---
> > > 		if((allGoal[i])/*||(isBuildable[i])*/)
> > 257,258d256
> > < 	if(allGoal[unitType]==0)
> > < 		prefList.push_back(unitType);
> > 299c297
> > < 	for(int j=10;j--;) // Nuclear Warhead needs 6 steps (?) ~~~~
> > ---
> > >     for(int j=12;j--;) // Nuclear Warhead needs 6 steps (?) ~~~~
> > 426,428c424,426
> > < 				  	((pStats[i].facility[0]==0)||(tree.checked[pStats[i].facility[0]])||
> > < 					((pStats[i].facility[1]>0)&&(tree.checked[pStats[i].facility[1]]))||
> > < 					((pStats[i].facility[2]>0)&&(tree.checked[pStats[i].facility[2]])))&&
> > ---
> > > 				  	((pStats[i].facility[0]==0)||(tree.checked[pStats[i].facility[0]]))&&
> > >                     ((pStats[i].facility[1]==0)||(tree.checked[pStats[i].facility[1]]))&&
> > >                     ((pStats[i].facility[2]==0)||(tree.checked[pStats[i].facility[2]]))&&
> > 536c534
> > < 						addGoal(fac, 1, 1, 0);
> > ---
> > > 						addGoal(fac,1,0,0);
> > 641,644d638
> > < 
> > < 	// sort by location:
> > < 	//goal.sort(GOAL::GoalAscendingLocationSort());
> > < //	goal.sort();
> > 682,683d675
> > < 	if(pStats[unit].unitType==REMAINING_UNIT_TYPE)
> > < 		return;
> > Files ./goalentry.o and /home/claw/work/sc1061/sc/core/goalentry.o differ
> > diff -r -b -B ./goal.hpp /home/claw/work/sc1061/sc/core/goal.hpp
> > 13d12
> > < 		bool operator<(const GOAL& goal);
> > Files ./goal.o and /home/claw/work/sc1061/sc/core/goal.o differ
> > Files ./harvest.o and /home/claw/work/sc1061/sc/core/harvest.o differ
> > Files ./location.o and /home/claw/work/sc1061/sc/core/location.o differ
> > Files ./prerace.o and /home/claw/work/sc1061/sc/core/prerace.o differ
> > Files ./race.o and /home/claw/work/sc1061/sc/core/race.o differ
> > diff -r -b -B ./settings.cpp /home/claw/work/sc1061/sc/core/settings.cpp
> > 581d580
> > < 	loadGoalFile(os.str().c_str());
> > diff -r -b -B ./settings.hpp /home/claw/work/sc1061/sc/core/settings.hpp
> > 37d36
> > < //	void clearGoalFiles();
> > Files ./settings.o and /home/claw/work/sc1061/sc/core/settings.o differ
> > Files ./soup.o and /home/claw/work/sc1061/sc/core/soup.o differ
> > Files ./startcondition.o and /home/claw/work/sc1061/sc/core/startcondition.o differ
> > Files ./start.o and /home/claw/work/sc1061/sc/core/start.o differ
> > Files ./unit.o and /home/claw/work/sc1061/sc/core/unit.o differ
> diff ./goalentry.cpp /home/claw/work/sc1063b/sc/core/goalentry.cpp
> 26,34c26,36
> <         memcpy(genoToPhaenotype, object.genoToPhaenotype, UNIT_TYPE_COUNT * sizeof(int));
> <         memcpy(phaenoToGenotype, object.phaenoToGenotype, UNIT_TYPE_COUNT * sizeof(int));
> <         memcpy(allGoal, object.allGoal, UNIT_TYPE_COUNT * sizeof(int));
554c3796,3798
< < //		const bool* fixed;
---
> <         memcpy(isStatic, object.isStatic, UNIT_TYPE_COUNT * sizeof(bool));
> <         memcpy(isBuildable, object.isBuildable, UNIT_TYPE_COUNT * sizeof(bool));
> <         memcpy(isHaveable, object.isHaveable, UNIT_TYPE_COUNT * sizeof(bool));
556,557c3800,3816
< < 		static unsigned int successType; //type of error
< < 		static unsigned int successUnit; //unit number
---
> <         memcpy(globalGoal, object.globalGoal, UNIT_TYPE_COUNT * MAX_LOCATIONS * sizeof(int));
> ---
> > 	for(int i=UNIT_TYPE_COUNT;i--;)
> > 	{
> > 		genoToPhaenotype[i]=object.genoToPhaenotype[i];
> > 		phaenoToGenotype[i]=object.phaenoToGenotype[i];
> > 		allGoal[i]=object.allGoal[i];
> > 		isStatic[i]=object.isStatic[i];
> > 		isBuildable[i]=object.isBuildable[i];
> > 		isHaveable[i]=object.isHaveable[i];
> > 		for(int j=MAX_LOCATIONS;j--;)
> > 			globalGoal[j][i]=object.globalGoal[j][i];
> > 	}
> 50,59c52,62
> < 	memcpy(genoToPhaenotype, object.genoToPhaenotype, UNIT_TYPE_COUNT * sizeof(int));
> < 	memcpy(phaenoToGenotype, object.phaenoToGenotype, UNIT_TYPE_COUNT * sizeof(int));
> < 	memcpy(allGoal, object.allGoal, UNIT_TYPE_COUNT * sizeof(int));
559c3818,3820
< < 		void setCurrentpFitness(unsigned int current_pfitness);
---
> < 	memcpy(isStatic, object.isStatic, UNIT_TYPE_COUNT * sizeof(bool));
> < 	memcpy(isBuildable, object.isBuildable, UNIT_TYPE_COUNT * sizeof(bool));
> < 	memcpy(isHaveable, object.isHaveable, UNIT_TYPE_COUNT * sizeof(bool));
561c3822
< < 		const bool buildGene(const unsigned int build_unit);
---
> < 	memcpy(globalGoal, object.globalGoal, UNIT_TYPE_COUNT * MAX_LOCATIONS * sizeof(int));
563,567c3824,3860
< < 		void setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply);
< < 		void setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply);
< < 		void setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness);
< < 		void setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals);
< < 		void setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas);
---
> ---
> > 	for(int i=UNIT_TYPE_COUNT;i--;)
> > 	{
> > 		genoToPhaenotype[i]=object.genoToPhaenotype[i];
> > 		phaenoToGenotype[i]=object.phaenoToGenotype[i];
> > 		allGoal[i]=object.allGoal[i];
> > 		isStatic[i]=object.isStatic[i];
> > 		isBuildable[i]=object.isBuildable[i];
> > 		isHaveable[i]=object.isHaveable[i];
> > 		for(int j=MAX_LOCATIONS;j--;)
> > 			globalGoal[j][i]=object.globalGoal[j][i];
> > 	}
> 69,78c72,83
> < 	raceInitialized = false;
> < 	maxBuildTypes = 0;
> < 	// DO NOT MEMSET!
> < 	for(unsigned int i = UNIT_TYPE_COUNT; i--; )
> < 	{
> < 		genoToPhaenotype[i] = 999;
> < 		phaenoToGenotype[i] = 999;
> < 		isStatic[i] = true;
> < 		isBuildable[i] = false;
> < 		isHaveable[i] = false;
> ---
> > 	raceInitialized=false;
> > 	maxBuildTypes=0;
> > 	for(int i=UNIT_TYPE_COUNT;i--;)
> > 	{
> > 		genoToPhaenotype[i]=999;
> > 		phaenoToGenotype[i]=999;
> > 		allGoal[i]=0;
> > 		isStatic[i]=true;
> > 		isBuildable[i]=false;
> > 		isHaveable[i]=false;
> > 		for(int j=MAX_LOCATIONS;j--;)
> > 			globalGoal[j][i]=0;
> 80,82d84
569,573c3862,3868
< < 		void setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply);
< < 		void setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply);
< < 		void setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness);
< < 		void setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals);
< < 		void setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas);
---
> < 	memset(allGoal, 0, UNIT_TYPE_COUNT * sizeof(int));
> < 	memset(globalGoal, 0, UNIT_TYPE_COUNT * MAX_LOCATIONS * sizeof(int));
> 169c171
> < 	for(unsigned int i=UNIT_TYPE_COUNT;i--;)
> ---
> > 	for(int i=UNIT_TYPE_COUNT;i--;)
> 360,363c362,366
575,589c3870,3871
< 111a38,40
< > 		std::list<PROGRAM>& getProgramList();
< > 		STATISTICS* getTimeStatistics();
< > 
< 124d52
< < //		const bool getProgramIsConstant(const unsigned int ip) const;
< 128,129d55
< < 		const unsigned int getProgramSuccessType(const unsigned int ip) const;	// determines the type of the last error before the item was built at that IP
< < 		const unsigned int getProgramSuccessUnit(const unsigned int ip) const;	// what unit was missing? (connected to successtype)
< 131,153d56
< < 		const unsigned int getIPStatisticsNeedSupply(const unsigned int ip) const;	// supply that is used up by all units
< < 		const unsigned int getIPStatisticsHaveSupply(const unsigned int ip) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
< < 		const unsigned int getIPStatisticsFitness(const unsigned int ip) const;
< < 		const unsigned int getIPStatisticsHaveMinerals(const unsigned int ip) const; // minerals at that time
< < 		const unsigned int getIPStatisticsHaveGas(const unsigned int ip) const;		// gas at that time
---
> < 	memset(tree.level, 0, (GAS_SCV+1) * sizeof(int));
> < 	memset(tree.coloumn, 0, (GAS_SCV+1) * sizeof(int));
591,595c3873,3892
< < 		const unsigned int getTimeStatisticsNeedSupply(const unsigned int time) const;	// supply that is used up by all units
< < 		const unsigned int getTimeStatisticsHaveSupply(const unsigned int time) const;	// total supply of supply buildings (overlord, supply depot, command center, ...)
< < 		const unsigned int getTimeStatisticsFitness(const unsigned int time) const;
< < 		const unsigned int getTimeStatisticsHaveMinerals(const unsigned int time) const; // minerals at that time
< < 		const unsigned int getTimeStatisticsHaveGas(const unsigned int time) const;		// gas at that time
---
> ---
> > 	for(unsigned int i = 0; i <= GAS_SCV; i++)
> > 	{
> > 		tree.level[i]=0;
> > 		tree.coloumn[i]=0;
> > 	}
> 413c416,417
> < 		memset(tcheck, 0, (GAS_SCV+1) * sizeof(bool)); // ?
> ---
> > 		for(unsigned int i = 1; i <= GAS_SCV; i++)
> > 			tcheck[i]=false;
> 463,471c467,474
> <         for(unsigned int i = UNIT_TYPE_COUNT; i--; )
> <         {
> <                 genoToPhaenotype[i] = 999;
> <                 phaenoToGenotype[i] = 999;
> <                 isStatic[i] = true;
> <                 isBuildable[i] = false;
> <                 isHaveable[i] = false;
> <         }
597c3894,3904
< < 		const bool getProgramIsBuilt(const unsigned int ip) const;		// was this order successfully built?
---
> ---
> > 	for(int i=UNIT_TYPE_COUNT;i--;)
> > 	{
> > 		genoToPhaenotype[i]=999;
> > 		phaenoToGenotype[i]=999;
> > 		isStatic[i] = true; //?
> > 		isBuildable[i] = false;
> > 		isHaveable[i] = false;
> > 	}
> 477,478c480,482
> < 	memcpy(oldGoal, allGoal, UNIT_TYPE_COUNT * sizeof(int));
599,604c3906,3947
< < 		const unsigned int getProgramTime(const unsigned int ip) const;			// at which time this order was started
< < 		const unsigned int getRealProgramTime(const unsigned int ip) const;			// at which time this order was started
< < 		const unsigned int getProgramLocation(const unsigned int ip) const;		// at which location was this unit built
< < //		const bool getProgramIsGoal(const unsigned int ip) const;		// is this unit part of the goal list? NOT YET WORKING!
< < 		const unsigned int getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const;	// how many units of the type at phaenoCode[s] do exist at that time?
< < 		const unsigned int getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const;	 // how many units of the type at phaenoCode[s] do exist at that time?
---
> ---
> > 	for(int i=UNIT_TYPE_COUNT;i--;) {
> > 		oldGoal[i]=allGoal[i];
> > 	}
> 487c491
> < 		for(int i=LAST_UNIT; i--;)
> ---
> > 		for(int i=GAS_SCV+1;i--;)
> 497c501
> < 		for(int i=LAST_UNIT;i--;)
> ---
> > 		for(int i=GAS_SCV+1;i--;)
> 592,602c596,606
> < 	long Need_Gas = 0;
> < 	for(int i = UNIT_TYPE_COUNT; i--;)
> < 		Need_Gas+=(allGoal[i]*pStats[i].gas);
> < 	if(Need_Gas > 0)
> < 	{
> < 		isBuildable[REFINERY] = true;
> < 		if(allGoal[REFINERY] == 0)
> < 			   addGoal(REFINERY, 1, 0, 0); //ASSIMILATOR == EXTRACTOR == REFINERY
> < 		isBuildable[GAS_SCV] = true; //ONE_MINERAL_SCV... = ONE_MINERAL_PROBE... = ONE_MINERAL_DRONE...
> < 		isStatic[GAS_SCV] = false;
> < 	} 
> ---
> > 		long Need_Gas=0;
> > 		for(int i=UNIT_TYPE_COUNT;i--;)
> > 			Need_Gas+=(allGoal[i]*pStats[i].gas);
> > 		if(Need_Gas>0)
> > 		{
> > 			isBuildable[REFINERY]=true;
> > 			if(allGoal[REFINERY]==0)
> > 				   addGoal(REFINERY, 1, 0, 0); //ASSIMILATOR == EXTRACTOR == REFINERY
> > 			isBuildable[GAS_SCV]=true; //ONE_MINERAL_SCV... = ONE_MINERAL_PROBE... = ONE_MINERAL_DRONE...
> > 			isStatic[GAS_SCV]=false;
> > 		} 
> 612,617d615
> < //	isBuildable[BUILD_PARALLEL_2] = true;
> < //	isBuildable[BUILD_PARALLEL_4] = true;
> < //	isBuildable[BUILD_PARALLEL_8] = true;
> < //	isBuildable[BUILD_PARALLEL_16] = true;
> < 	isBuildable[FROM_GAS_TO_MINERALS] = true;
606,609c3949,3952
< < 		const unsigned int getProgramFacility(const unsigned int ip) const;
< < 		const unsigned int getProgramBT(const unsigned int ip) const;
< 160c63
< < 		const unsigned int getMaxtFitness() const;			// gets tertiary fitness (build order appearance, some heuristics)
---
> 634d631
> < 
> 654c651
> < 	for(int i = LAST_UNIT;i--;)
611,623c3954,3965
< > 		const unsigned int getMaxtFitness() const;
< 174,185d76
< < //		void setProgramIsConstant(const unsigned int ip, const bool isConstant);
< < 		void setProgramFacility(const unsigned int ip, const unsigned int program_facility);
< < 		void setProgramBT(const unsigned int ip, const unsigned int program_bt);
< < 		void setProgramSuccessType(const unsigned int ip, const unsigned int program_success_type);
< < 		void setProgramSuccessUnit(const unsigned int ip, const unsigned int program_success_unit);
< < 		void setProgramIsBuilt(const unsigned int ip, const bool program_is_built);
< < 		void setProgramLocation(const unsigned int ip, const unsigned int program_location);
< < 		void setProgramTime(const unsigned int ip, const unsigned int program_time);
< < //		void setProgramIsGoal(const unsigned int ip, const bool isGoal);	
< < 		void setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);	
< < 		void setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count);
---
> > 	for(int i = GAS_SCV+1;i--;)
> 667,670c664,667
> < 		allow[i].prerequisite.clear();
> < 		need[i].facility = false;
> < 		need[i].facility2 = false;
> < 		need[i].prerequisite = 0;;
> ---
> > 		allow[i].prerequisite	.clear();
> > 		need[i].facility=false;
> > 		need[i].facility2=false;
> > 		need[i].prerequisite=0;;
> 672d668
625,643c3967,4043
< 192a84,113
< > 		std::list<PROGRAM> programList; // TODO private machen
< > 	private:
< > 		unsigned int unitsTotal; // total number of all unit types at the end
< > 		unsigned int unitsTotalMax; // maximum number of one unit type at the end
< > 		unsigned int nonGoalsUnitsTotalMax; // maximum number of one NON GOAL unit type at the end
< > 		unsigned int unchangedGenerations;
< > 		unsigned int currentRun;
< > 		bool optimizing;
< > 		bool active;
< > 		unsigned int totalGeneration;
< > 		unsigned int maxpFitness;
< > 		unsigned int maxsFitness;
< > 		unsigned int maxtFitness;
< > 		unsigned int timePercentage;
< > 		unsigned int goalPercentage;
< > 		unsigned int currentpFitness;
< > 		unsigned int averageLength;
< > 		unsigned int phaenoCode[MAX_LENGTH];		// the final build order: an array of unit numbers (as defined in main.h)
---
> 674c670,672
> < 		if(isBuildable[i])
> ---
> > 	if(isBuildable[i])
> > 	{
> > 		for(int j = 3;j--;)
> 676,692c674,688
> < 			for(int j = 3;j--;)
> < 			{
> < 				if(pStats[i].facility[j]>0)
> < 					allow[pStats[i].facility[j]].facility.push_back(i);
> < 				if(pStats[i].prerequisite[j]>0)
> < 					allow[pStats[i].prerequisite[j]].prerequisite.push_back(i);
> < 			}
> < 			if(pStats[i].facility2>0)
> < 				allow[pStats[i].facility2].facility2.push_back(i);
> <                 	if((pStats[i].facility[0]>0)||(pStats[i].facility[1]>0)||(pStats[i].facility[2]>0))
> <                         	need[i].facility = true;
> < 	                for(int j=3;j--;)
> <         	                if(pStats[i].prerequisite[j])
> <                 	                need[i].prerequisite++;
> < 			if(pStats[i].facility2>0)
> < 				need[i].facility2 = true;
> < 		}	
> ---
> > 			if(pStats[i].facility[j]>0)
> > 				allow[pStats[i].facility[j]].facility.push_back(i);
> > 			if(pStats[i].prerequisite[j]>0)
> > 				allow[pStats[i].prerequisite[j]].prerequisite.push_back(i);
> > 		}
> > 		if(pStats[i].facility2>0)
> > 			allow[pStats[i].facility2].facility2.push_back(i);
> >                 if((pStats[i].facility[0]>0)||(pStats[i].facility[1]>0)||(pStats[i].facility[2]>0))
> >                         need[i].facility = true;
> >                 for(int j=3;j--;)
> >                         if(pStats[i].prerequisite[j])
> >                                 need[i].prerequisite++;
> > 		if(pStats[i].facility2>0)
> > 			need[i].facility2=true;
> > 	}	
> 700,701c696,697
> < 		facility = false;
> < 		if((!facility2)&&(prerequisite == 0))
> ---
> > 		facility=false;
> > 		if((!facility2)&&(prerequisite==0))
> 711,712c707,708
> < 		facility2 = false;
> < 		if((!facility) && (prerequisite == 0))
> ---
> > 		facility2=false;
> > 		if((!facility)&&(prerequisite==0))
> 723c719
> < 		if((!facility) && (!facility2) && (prerequisite==0))
> ---
> > 		if((!facility)&&(!facility2)&&(prerequisite==0))
> 745c741
> < 	if(unit >= UNIT_TYPE_COUNT) {
> ---
> > 	if(unit>=UNIT_TYPE_COUNT) {
> 748c744
> < 	if(globalGoal[location][unit] + count > MAX_TOTAL_UNITS) {
> ---
> > 	if(globalGoal[location][unit] + count>MAX_TOTAL_UNITS) {
> 751c747
> < 	if(time > configuration.getMaxTime()) {
> ---
> > 	if(time>configuration.getMaxTime()) {
> 754c750
> < 	if(location >= MAX_LOCATIONS) { // TODO
> ---
> > 	if(location>=MAX_LOCATIONS) {
> 760c756
> < 	if((race == ZERG)&&(unit == LARVA))
> ---
> > 	if((race==ZERG)&&(unit==LARVA))
> 799a796,797
645d4044
< > 		STATISTICS timeStatistics[MAX_TIME];
647c4046,4120
< > //		const bool* fixed;
---
> diff ./goalentry.hpp /home/claw/work/sc1063b/sc/core/goalentry.hpp
> 212c212
> < 	if(unit >= LAST_UNIT) {
> ---
> > 	if(unit>GAS_SCV) {
> 228c228
> < 	if(unit >= LAST_UNIT) {
> ---
> > 	if(unit>GAS_SCV) {
> 242c242
> < 	if(unit >= LAST_UNIT) {
> ---
> > 	if(unit>GAS_SCV) {
> 251c251
> < 	if(unit > LAST_UNIT) {
> ---
> > 	if(unit>GAS_SCV) {
> 261c261
> < 	if(unit >= LAST_UNIT) {
> ---
> > 	if(unit>GAS_SCV) {
> Files ./goalentry.o and /home/claw/work/sc1063b/sc/core/goalentry.o differ
> diff ./goal.hpp /home/claw/work/sc1063b/sc/core/goal.hpp
> 69c69
> < 	if((goal_location >= MAX_LOCATIONS)) { // TODO
> ---
> > 	if((goal_location >= MAX_LOCATIONS)) {
> 120c120
> < 	if((location >= MAX_LOCATIONS)) { // TODO
> ---
> > 	if((location >= MAX_LOCATIONS)) {
> Files ./goal.o and /home/claw/work/sc1063b/sc/core/goal.o differ
> diff ./harvest.cpp /home/claw/work/sc1063b/sc/core/harvest.cpp
> 12c12,13
> < { }
> ---
> > {
> > }
> Files ./harvest.o and /home/claw/work/sc1063b/sc/core/harvest.o differ
> diff ./location.cpp /home/claw/work/sc1063b/sc/core/location.cpp
> 11,15c11
> < 	for(unsigned int i=MAX_LOCATIONS;i--;)
> < 	{
> < 		distance[i] = 9999;
> < 		nearest[i] = 0;
> < 	}
> ---
> > 	resetData();
> 25c21
> < 	for(unsigned int i = MAX_LOCATIONS;i--;)
> ---
> > 	for(unsigned int i=MAX_LOCATIONS;i--;)
> 27,29c23,25
> < 		distance[i] = 9999;
> < 		nearest[i] = 0;
> < 	}
> ---
> > 		setDistance(i,0);
> > 		nearest[i]=0;
> > 	}		
> 64c60
> < 	for(unsigned int step = 1; step < getMaxLocations(); step++)
> ---
> > 	for(unsigned int step = 1; step < MAX_LOCATIONS; step++)
> 67c63
> < 		for(unsigned int loc = 1;loc < getMaxLocations();loc++)
> ---
> > 		for(unsigned int loc = 1;loc < MAX_LOCATIONS;loc++)
> 72c68
> < 					if(nearest[k] == loc) alreadyProcessed = true;
> ---
> > 					if(nearest[k]==loc) alreadyProcessed = true;
> 82c78
> < unsigned int MAP_LOCATION::maxLocations = 0;
> ---
649,650c4122,4266
< > 		static unsigned int successType; //type of error
< > 		static unsigned int successUnit; //unit number
---
> diff ./location.hpp /home/claw/work/sc1063b/sc/core/location.hpp
> 14,15d13
> < 		static unsigned int maxLocations;
> < 		static const unsigned int getMaxLocations();
> 38,39d35
> < 		
> < 		static void setMaxLocations(const unsigned int max_locations);
> 42,63d37
> < inline void MAP_LOCATION::setMaxLocations(const unsigned int max_locations)
> < {
> < #ifdef _SCC_DEBUG
> < // TODO constant
> <         if(max_locations > MAX_LOCATIONS) {
> <                 toLog("DEBUG: (MAP_LOCATION::setMaxLocations): Value out of range.");return;
> <         }
> < #endif
> < 	maxLocations=max_locations;
> < }
> < 
> < inline const unsigned int MAP_LOCATION::getMaxLocations()
> < {
> < #ifdef _SCC_DEBUG
> < // TODO constant
> <         if(maxLocations > MAX_LOCATIONS) {
> <                 toLog("DEBUG: (MAP_LOCATION::getMaxLocations): Variable maxLocations out of range.");return(0);
> <         }
> < #endif
> < 	return(maxLocations);
> < }
> < 
> 71,76d44
> < #ifdef _SCC_DEBUG
> < // TODO constant
> < 	if(mineralPatches > 100) {
> < 		toLog("DEBUG: (MAP_LOCATION::getMineralPatches): Variable mineralPatches out of range.");return(0);
> < 	}
> < #endif			
> 82,87d49
> < #ifdef _SCC_DEBUG
> < // TODO constantv
> <         if(vespeneGeysirs > 100) {
> <                 toLog("DEBUG: (MAP_LOCATION::getVespeneGeysirs): Value vespeneGeysirs out of range.");return(0);
> <         }
> < #endif
> 126c88
> < 	if((step<=0)||(step>=maxLocations)) {
> ---
> > 	if((step<=0)||(step>=MAX_LOCATIONS)) {
> 137c99
> < 	if(target>=maxLocations) {
> ---
> > 	if(target>=MAX_LOCATIONS) {
> 140,142c102,104
> < //	if(location_distance>) {
> < //		toLog("DEBUG: (MAP_LOCATION::setDistance): Value distance out of range.");return;
> < //	}
> ---
> > 	if(location_distance>500) {
> > 		toLog("DEBUG: (MAP_LOCATION::setDistance): Value distance out of range.");return;
> > 	}
> 165c127
> < 	if(location>=maxLocations) {
> ---
> > 	if(location>=MAX_LOCATIONS) {
> 168,170c130,132
> < //	if(distance[location]>500) {
> < //		toLog("DEBUG: (MAP_LOCATION::getDistance): Value distance out of range.");return(0);
> < //	}
> ---
> > 	if(distance[location]>500) {
> > 		toLog("DEBUG: (MAP_LOCATION::getDistance): Value distance out of range.");return(0);
> > 	}
> Files ./location.o and /home/claw/work/sc1063b/sc/core/location.o differ
> diff ./prerace.cpp /home/claw/work/sc1063b/sc/core/prerace.cpp
> 38c38
> < 	memset(gasHarvestPerSecond, 0, 5 * MAX_LOCATIONS*sizeof(int));
> ---
> > 	memset(gasHarvestPerSecond, 0, 6 * MAX_LOCATIONS*sizeof(int));
> 40c40
> < //	memset(Marker, 0, MAX_LENGTH*sizeof(int));
> ---
> > 	memset(Marker, 0, MAX_LENGTH*sizeof(int));
> 46,47c46,47
> < 	location = NULL;
> < 	pStartCondition = NULL;
> ---
> > 	location=NULL;
> > 	pStartCondition=NULL;
> 50,67c50,67
> < 	pStats = NULL;
> < 	neededMinerals = 0;
> < 	neededGas = 0;
> < 	ready = false;
> < 	pGoal = NULL;
> < 	playerNum = 0;
> < 	minerals = 0;
> < 	gas = 0;
> < 	timer = 0; //? max_time-1?
> < 	IP = 0;
> < 	harvestedMinerals = 0;
> < 	harvestedGas = 0;
> < 	wastedMinerals = 0;
> < 	wastedGas = 0;
> < 	needSupply = 0;
> < 	haveSupply = 0;
> < 	length = 0;
> < 	timeout = 0;
> ---
> > 	pStats=NULL;
> > 	neededMinerals=0;
> > 	neededGas=0;
> > 	ready=false;
> > 	pGoal=NULL;
> > 	playerNum=0;
> > 	minerals=0;
> > 	gas=0;
> > 	timer=0; //? max_time-1?
> > 	IP=0;
> > 	harvestedMinerals=0;
> > 	harvestedGas=0;
> > 	wastedMinerals=0;
> > 	wastedGas=0;
> > 	needSupply=0;
> > 	haveSupply=0;
> > 	length=0;
> > 	timeout=0;
> 69c69
> < 	memset(gasHarvestPerSecond, 0, 5 * MAX_LOCATIONS*sizeof(int));
> ---
> > 	memset(gasHarvestPerSecond, 0, 6 * MAX_LOCATIONS*sizeof(int));
> 71c71
> < //	memset(Marker, 0, MAX_LENGTH*sizeof(int));
> ---
> > 	memset(Marker, 0, MAX_LENGTH*sizeof(int));
> 74a75,85
> > void PRERACE::resetStaticPrerace()
> > {
> > 	pMap=NULL;
> > 	memset(noise, 0, MAX_TIME*sizeof(int));
> > 	markerCounter=1;
> > 	for(int i = MAX_PLAYER;i--;)
> > 		for(int j = MAX_LOCATIONS;j--;)
> > 			unit[i][j].resetData();
> > 	pStart=NULL;
> > }
652c4268,4278
< > 		void setCurrentpFitness(unsigned int current_pfitness);
---
> 100,102c111,125
> < 	memcpy(Code, object.Code, MAX_LENGTH * sizeof(int));
> < //	memcpy(Marker, object.Marker, MAX_LENGTH * sizeof(int));
> < 	//memcpy(last, object.last, MAX_LENGTH * sizeof(int));
> ---
> > 	for(unsigned int i=MAX_LENGTH;i--;)
> > 	{
> > 	//	last[i] = object.last[i];
> > 		setCode(i, object.getCode(i));
> > 		setMarker(i, object.getMarker(i));
> > 	}
654,657c4280,4318
< > 		const bool buildGene(const unsigned int build_unit);
< > 		const bool buildIt(const unsigned int build_unit);
< 209,210c130,138
< < inline const unsigned int ANARACE::getAverageLength() const
---
> > 	for(int i=MAX_LOCATIONS;i--;)
> > 	{
> > 		larvaInProduction[i] = object.larvaInProduction[i];
> > 		for(unsigned int j = 0; j<45; j++)
> > 			mineralHarvestPerSecond[i][j] = object.mineralHarvestPerSecond[i][j];
> > 		for(unsigned int j = 0; j<5; j++)
> > 			gasHarvestPerSecond[i][j] = object.gasHarvestPerSecond[i][j];
> > 	}	
> 104,106d126
> < 	memcpy(larvaInProduction, object.larvaInProduction, MAX_LOCATIONS * sizeof(int));
> < 	memcpy(mineralHarvestPerSecond, mineralHarvestPerSecond, MAX_LOCATIONS * 45 * sizeof(int));
> < 	memcpy(gasHarvestPerSecond, object.gasHarvestPerSecond, MAX_LOCATIONS * 5 * sizeof(int));
> 135c155
> < //	memcpy(Marker, object.Marker, MAX_LENGTH * sizeof(int));
> ---
> > 	memcpy(Marker, object.Marker, MAX_LENGTH * sizeof(int));
> 138c158,160
> < 	memcpy(larvaInProduction, object.larvaInProduction, MAX_LOCATIONS * sizeof(int));	
> ---
> > 	for(int i=MAX_LOCATIONS;i--;)
> > 		larvaInProduction[i] = object.larvaInProduction[i];
> > 	
> 148,159d169
> < 	std::list<PARALLEL_COMMAND*>::iterator i = parallelCommandQueues.begin();
> < 	while(i!=parallelCommandQueues.end())
> < 	{
> < 		delete *i;
> < 		i = parallelCommandQueues.erase(i);
> < 	}
> < 
> < 	PARALLEL_COMMAND* gimme = new PARALLEL_COMMAND();
> < 	gimme->unit = SCV;
> < 	gimme->count = 64;
> < 	parallelCommandQueues.push_back(gimme);
> < 								
> 204,211c214
> < {
> < 	std::list<PARALLEL_COMMAND*>::iterator i = parallelCommandQueues.begin();
> < 	while(i!=parallelCommandQueues.end())
658a4320,4323
> < 		delete *i;
> < 		i = parallelCommandQueues.erase(i);
> < 	}
> < }
660,661c4325,4339
< > inline std::list<PROGRAM>& ANARACE::getProgramList() {
< > 	return(programList);
---
> > { }
> 233,234c236,237
> < //	markerCounter++;
> < //	setMarker(ip, markerCounter);
> ---
> > 	markerCounter++;
> > 	setMarker(ip, markerCounter);
> 288c291
> < void PRERACE::adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2, const unsigned int count)
> ---
> > void PRERACE::adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2)
> 289a293,299
> > #ifdef _SCC_DEBUG
> > 	if((location_number >= MAX_LOCATIONS))  {
> > 		toLog("DEBUG: (PRERACE::adjustLocationUnitsAfterCompletion): Value location_number out of range.");return;
662a4341,4342
> > // TODO andere facilities!!	
> > #endif
664,666c4344,4392
< > inline STATISTICS* ANARACE::getTimeStatistics() {
< > 	return(timeStatistics);
< > }
---
> 295,308c305,309
> < 			if(count!=1)
> < 			{
> < 				if(facility)
> < 					setLocationTotal(location_number, facility, getLocationTotal(location_number, facility) - count);
> < //				if(facility2)
> < //					removeOneLocationTotal(location_number, facility2);
> < 			} else
> < 			{
> < 				if(facility)
> < 					removeOneLocationTotal(location_number, facility);
> < 					//availible was already taken account when starting the building
> < 				if(facility2)
> < 					removeOneLocationTotal(location_number, facility2);
> < 			}
> ---
> > 			if(facility)
> > 				removeOneLocationTotal(location_number, facility);
> > 				//availible was already taken account when starting the building
> > 			if(facility2)
> > 				removeOneLocationTotal(location_number, facility2);
> 344c345
> < 			toLog("ERROR: UNDEFINED FACILITY BEHAVIOUR DETECTED!");
> ---
> > 				toLog("ERROR: UNDEFINED FACILITY BEHAVIOUR DETECTED!");
> 346c347
> < 		break;
> ---
> > 				break;
> 434,435d434
> < 
> < // STARK VON LOCATIONS ABHAENGIG!
> 474c473
> < 						while((j<(*getMap())->getMaxLocations()) && (bon>getLocationTotal(loc, i->getUnit())))
> ---
> > 						while((j<MAX_LOCATIONS) && (bon>getLocationTotal(loc, i->getUnit())))
> 479d477
> < 							loc = (*pMap)->getLocation(i->getLocation())->getNearest(j);
> 482c480
> < 						if(j<(*getMap())->getMaxLocations())
> ---
> > 						if(j<MAX_LOCATIONS)
> 521c519
> < 		std::priority_queue<Building, std::vector<Building> >  save = buildingQueue;
> ---
> > 		std::priority_queue<Building, std::deque<Building> >  save = buildingQueue;
> 563c561
> < #if 0
> ---
668,670c4394,4404
< > inline const unsigned int ANARACE::getAverageLength() const {
< 244,245c172
< < inline const bool ANARACE::isActive() const
---
> 565a564
> > 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> 568,570d566
> < 
> < 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> < 	bool ok = false;
> 581c577
> < 
> ---
> > 	bool ok = false;
> 663c659
673,675c4407,4434
< > inline const bool ANARACE::isActive() const {
< 249,250c176
< < inline void ANARACE::setActive(const bool set_active)
---
> > 			  {
> 678,679d673
> < 
> < 		TODO program!
> 691,692c685,686
> < #endif
> < const bool PRERACE::isDifferent(const unsigned int* code) const //, const unsigned int* marker) const
> ---
> > 
> > const bool PRERACE::isDifferent(const unsigned int* code, const unsigned int* marker) const
> 695c689
> < 		if((getCode(i)!=code[i]))//||(getMarker(i)!=marker[i]))
> ---
> > 		if((getCode(i)!=code[i])||(getMarker(i)!=marker[i]))
> 705a700,704
> > #ifdef _SCC_DEBUG
> > 	if((location_number >= MAX_LOCATIONS)) {
> > 		toLog("DEBUG: (PRERACE::adjustMineralHarvest): Value location_number out of range.");return;
> > 	}
> > #endif
> 740a740,744
> > #ifdef _SCC_DEBUG
> > 	if((location_number >= MAX_LOCATIONS))	{
> > 		toLog("DEBUG: (PRERACE::adjustGasHarvest): Value location_number out of range.");return;
> > 	}
> > #endif
> 772,773c776
> < 	for(int i = (*getMap())->getMaxLocations();i--;)
678,680c4437,4507
< > inline void ANARACE::setActive(const bool set_active) {
< 254,255c180
< < inline const bool ANARACE::isOptimizing() const
---
> > 	for(int i=MAX_LOCATIONS;i--;) {
> 783c786
> < 	for(unsigned int i=1;i<(*getMap())->getMaxLocations();i++)//~~
> ---
> > 	for(int i=1;i<MAX_LOCATIONS;i++)//~~
> 813c816
> < 	for(unsigned int i=1;i<(*getMap())->getMaxLocations();i++)//~~
> ---
> > 	for(int i=1;i<MAX_LOCATIONS;i++)//~~
> 815c818
> < 		unsigned int s = location[i].getAvailible(GAS_SCV);
> ---
> > 		int s=location[i].getAvailible(GAS_SCV);
> 854,860c857,858
> < 	pStart = start;
> < 	pMap = pStart->getMap();
> < 	memset(noise, 0, MAX_TIME * sizeof(int));
> < //	markerCounter = 1;
> < 	for(int i = MAX_PLAYER;i--;)
> < 		for(int j = (*getMap())->getMaxLocations();j--;)
> < 			unit[i][j].resetData();
> ---
> > 	pStart=start;
> > 	pMap=pStart->getMap();
> 862d859
> < 
> 869a867
> > 
> 876c874
> < 	memset(noise, 0, MAX_TIME * sizeof(int));
> ---
> > 	memset(noise, 0, MAX_TIME*sizeof(int));
> 881c879,906
> < 	memset(larvaInProduction, 0, MAX_LOCATIONS * sizeof(int));
> ---
> > 	for(int i=MAX_LOCATIONS;i--;)
> > 		larvaInProduction[i]=0;
> > }
> > 
> > void PRERACE::removeLarvaFromQueue(const unsigned int location_number)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((location_number<1) || (location_number >= MAX_LOCATIONS)) {
> > 			toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Value location_number out of range.");return;
> > 	}
> > 	if((larvaInProduction[location_number]<1)||(larvaInProduction[location_number]>=MAX_SUPPLY)) {
> > 			toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
> > 	}
> > #endif
> > 	larvaInProduction[location_number]--;
> > }
> > 
> > void PRERACE::addLarvaToQueue(const unsigned int location_number)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((location_number<1) || (location_number >= MAX_LOCATIONS)) {
> > 			toLog("DEBUG: (PRERACE::addLarvaFromQueue): Value location_number out of range.");return;
> > 	}
> > 	if(larvaInProduction[location_number]>=MAX_SUPPLY) {
> > 			toLog("DEBUG: (PRERACE::addLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
> > 	}
> > #endif
> > 	larvaInProduction[location_number]++;
> 968,969c993,994
> < 	if(length<object.length)
> < 			return(true);
> ---
> >         if(length<object.length)
> > 	                return(true);
> 1089,1092c1114,1117
> < 	if(count >= UNIT_TYPE_COUNT)
681a4509,4510
> < 		toLog("DEBUG: (SITUATION::setTMaxBuildTypes): Value count out of range.");return;
> < 	}
683,685c4512,4517
< > inline const bool ANARACE::isOptimizing() const {
< 259,260c184
< < inline void ANARACE::setOptimizing(const bool set_optimizing)
---
> >         if(count >= UNIT_TYPE_COUNT)
> >         {
> >                 toLog("DEBUG: (SITUATION::setTMaxBuildTypes): Value count out of range.");return;
> >         }
> 1100,1103c1125,1128
> < 	if(tMaxBuildTypes >= UNIT_TYPE_COUNT-1)
686a4519,4520
> < 		toLog("DEBUG: (SITUATION::addTMaxBuildTypes): Value out of range.");return;
> < 	}
688,690c4522,4527
< > inline void ANARACE::setOptimizing(const bool set_optimizing) {
< 264,420d187
< < inline const unsigned int ANARACE::getProgramFacility(const unsigned int ip) const
---
> >         if(tMaxBuildTypes >= UNIT_TYPE_COUNT-1)
> >         {
> >                 toLog("DEBUG: (SITUATION::addTMaxBuildTypes): Value out of range.");return;
> >         }
> 1111,1114c1136,1139
> < 	if(tMaxBuildTypes == 0)
692,694c4529
< < #ifdef _SCC_DEBUG
< < 	if(ip >= MAX_LENGTH) {
< < 		toLog("DEBUG: (ANARACE::getProgramFacility): Value ip out of range.");return(0);
---
> < 		toLog("DEBUG: (SITUATION::subTMaxBuildTypes): Value out of range.");return;
696,697c4531,4539
< < 	if(program[ip].facility >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::getProgramFacility): Variable not initialized.");return(0);
---
> ---
> >         if(tMaxBuildTypes == 0)
> >         {
> >                 toLog("DEBUG: (SITUATION::subTMaxBuildTypes): Value out of range.");return;
> >         }
> 1122,1129c1147,1154
> < 	if(unit >= UNIT_TYPE_COUNT)
> < 	{
> < 		toLog("DEBUG: (SITUATION::setForce): Value unit out of range.");return;
699,703c4541,4543
< < #endif
< < //	if((getRace()==PROTOSS)&&(program[ip].facility==PROBE))
< < //		while(true);
< < 
< < 	return(program[ip].facility);
---
> < 	if(count > MAX_SUPPLY)
> < 	{
> < 		toLog("DEBUG: (SITUATION::setForce): Value count out of range.");return;
705,706c4545,4555
< < 
< < inline const unsigned int ANARACE::getProgramBT(const unsigned int ip) const
---
> ---
> >         if(unit >= UNIT_TYPE_COUNT)
> >         {
> >                 toLog("DEBUG: (SITUATION::setForce): Value unit out of range.");return;
> >         }
> >         if(count > MAX_SUPPLY)
> >         {
> >                 toLog("DEBUG: (SITUATION::setForce): Value count out of range.");return;
> >         }
> 1137,1144c1162,1169
> < 	if(unit >= UNIT_TYPE_COUNT)
708,710c4557
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramBT): Value ip out of range.");return(0);
---
> < 		toLog("DEBUG: (SITUATION::setBuildable): Value unit out of range.");return;
712,713c4559,4561
< < 	if(program[ip].BT >= MAX_TIME) {
< < 		toLog("DEBUG: (ANARACE::getProgramBT): Variable not initialized.");return(0);
---
> < 	if(count > 1)
> < 	{
> < 		toLog("DEBUG: (SITUATION::setBuildable): Value count out of range.");return;
715,716c4563,4575
< < #endif
< < 	return(program[ip].BT);
---
> ---
> >         if(unit >= UNIT_TYPE_COUNT)
> >         {
> >                 toLog("DEBUG: (SITUATION::setBuildable): Value unit out of range.");return;
> >         }
> >         if(count > 1)
> >         {
> >                 toLog("DEBUG: (SITUATION::setBuildable): Value count out of range.");return;
> >         }
> 1152,1159c1177,1184
> < 	if(unit >= UNIT_TYPE_COUNT)
> < 	{
> < 		toLog("DEBUG: (SITUATION::setTGeno): Value unit out of range.");return;
718,719c4577
< < 
< < inline const unsigned int ANARACE::getProgramSuccessType(const unsigned int ip) const
---
> < 	if(count >= UNIT_TYPE_COUNT)
721,723c4579
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Value ip out of range.");return(0);
---
> < 		toLog("DEBUG: (SITUATION::setTGeno): Value count out of range.");return;
725,726c4581,4593
< < 	if(program[ip].successType >= ERROR_MESSAGES) {
< < 		toLog("DEBUG: (ANARACE::getProgramSuccessType): Variable not initialized.");return(0);
---
> ---
> >         if(unit >= UNIT_TYPE_COUNT)
> >         {
> >                 toLog("DEBUG: (SITUATION::setTGeno): Value unit out of range.");return;
> >         }
> >         if(count >= UNIT_TYPE_COUNT)
> >         {
> >                 toLog("DEBUG: (SITUATION::setTGeno): Value count out of range.");return;
> >         }
> 1167,1174c1192,1199
> < 	if(unit >= UNIT_TYPE_COUNT)
> < 	{
> < 		toLog("DEBUG: (SITUATION::setTTGeno): Value unit out of range.");return;
728,729c4595,4648
< < #endif
< < 	return(program[ip].successType);
---
> < 	if(count >= 1000)
> < 	{
> < 		toLog("DEBUG: (SITUATION::setTTGeno): Value count out of range.");return;
> < 	}
> ---
> >         if(unit >= UNIT_TYPE_COUNT)
> >         {
> >                 toLog("DEBUG: (SITUATION::setTTGeno): Value unit out of range.");return;
> >         }
> >         if(count >= 1000)
> >         {
> >                 toLog("DEBUG: (SITUATION::setTTGeno): Value count out of range.");return;
> >         }
> 1185,1186c1210,1211
> < 	if(getLength()==0)
> < 		setLength(MAX_LENGTH);//configuration.getMaxLength()); // TODO
> ---
> >         if(getLength()==0)
> >                 setLength(MAX_LENGTH);//configuration.getMaxLength()); // TODO
> 1195,1196c1220,1221
> < 		for(unsigned int i=GAS_SCV+1;i--;)
> < 			if(((*pGoal)->getIsBuildable(i))&&((*pStartCondition)->getLocationTotal(GLOBAL,i)>0)) //set start force
> ---
> > 	        for(unsigned int i=GAS_SCV+1;i--;)
> > 	                if(((*pGoal)->getIsBuildable(i))&&((*pStartCondition)->getLocationTotal(GLOBAL,i)>0)) //set start force
> 1202,1213c1227,1238
> < 		for(unsigned int i = GAS_SCV+1; i--;)
> < 		{
> < 			if(situation->getForce(i))
> < 			{
> < 				bool ok=true;
> < 				for(int j=GAS_SCV+1;j--;)
> < 					if((situation->getForce(j))&&((*pStats)[j].create>0)&&((*pStats)[j].create == i)) {
> < 						ok=false;break;
> < 					}
> < 				if(ok)
> < 				{
> < 					situation->setTGeno(situation->getTMaxBuildTypes(), (*pGoal)->toGeno(i));
> ---
> >                 for(unsigned int i = GAS_SCV+1; i--;)
> >                 {
> >                         if(situation->getForce(i))
> >                         {
> >                                 bool ok=true;
> >                                 for(int j=GAS_SCV+1;j--;)
> >                                         if((situation->getForce(j))&&((*pStats)[j].create>0)&&((*pStats)[j].create == i)) {
> >                                                 ok=false;break;
> >                                         }
> >                                 if(ok)
> >                                 {
> >                                         situation->setTGeno(situation->getTMaxBuildTypes(), (*pGoal)->toGeno(i));
> 1215,1227c1240,1252
> < 					situation->addTMaxBuildTypes();
> < 					situation->setBuildable(i, 1);
730a4650
> < 			} else
732c4652,4678
< < inline const unsigned int ANARACE::getProgramSuccessUnit(const unsigned int ip) const
---
> < 			if(  ( ((*pGoal)->getIsBuildable(i) ) &&
> < 			   (((*pStats)[i].prerequisite[0]==0)||(situation->getForce((*pStats)[i].prerequisite[0])))&&
> < 			   (((*pStats)[i].prerequisite[1]==0)||(situation->getForce((*pStats)[i].prerequisite[1])))&&
> < 			   (((*pStats)[i].prerequisite[2]==0)||(situation->getForce((*pStats)[i].prerequisite[2])))&&
> < 			   ((((*pStats)[i].facility[0]>0)&&(situation->getForce((*pStats)[i].facility[0])))||
> < 			   (((*pStats)[i].facility[1]>0)&&(situation->getForce((*pStats)[i].facility[1])))||
> < 			   (((*pStats)[i].facility[2]>0)&&(situation->getForce((*pStats)[i].facility[2])))||
> < 			   (((*pStats)[i].facility[0]==(*pStats)[i].facility[1]==(*pStats)[i].facility[2]==0)))))
> ---
> >                                         situation->addTMaxBuildTypes();
> >                                         situation->setBuildable(i, 1);
> >                                 }
> >                         } else
> > 
> >                         if(  ( ((*pGoal)->getIsBuildable(i) ) &&
> >                            (((*pStats)[i].prerequisite[0]==0)||(situation->getForce((*pStats)[i].prerequisite[0])))&&
> >                            (((*pStats)[i].prerequisite[1]==0)||(situation->getForce((*pStats)[i].prerequisite[1])))&&
> >                            (((*pStats)[i].prerequisite[2]==0)||(situation->getForce((*pStats)[i].prerequisite[2])))&&
> >                            ((((*pStats)[i].facility[0]>0)&&(situation->getForce((*pStats)[i].facility[0])))||
> >                            (((*pStats)[i].facility[1]>0)&&(situation->getForce((*pStats)[i].facility[1])))||
> >                            (((*pStats)[i].facility[2]>0)&&(situation->getForce((*pStats)[i].facility[2])))||
> >                            (((*pStats)[i].facility[0]==(*pStats)[i].facility[1]==(*pStats)[i].facility[2]==0)))))
> 1248c1273
> < 		}
> ---
> >                 }
> 1262c1287
734,736c4680,4772
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Value ip out of range.");return(0);
---
> ---
> >         {
> 1267,1277c1292,1302
> < 		if(configuration.getMutationFactor()==0)
> < 			return;
> < 		if(rand() % (MAX_LENGTH*100/configuration.getMutationFactor())==0)
> < 		{
> < 			switch(rand() % 4)
> < 			{
> < 				//TODO: wenn generateBuildOrder==1 dann bleibts stehen!
> < 				case 0://delete one variabel entry and move - Mehrere Schmieden/Kasernen etc. zulassen!
> < 				{
> < //				if((((*pGoal)->isVariable[Code[0][x]]==1)&&((*pGoal)->isVariable[Code[1][x]]==1))||(!configuration.preprocessBuildOrder)) TODO
> < 						//TODO: ueberlegen, ob Code evtl struct sein sollte... mmmh
> ---
> >                 if(configuration.getMutationFactor()==0)
> >                         return;
> >                 if(rand() % (MAX_LENGTH*100/configuration.getMutationFactor())==0)
> >                 {
> >                         switch(rand() % 4)
> >                         {
> >                                 //TODO: wenn generateBuildOrder==1 dann bleibts stehen!
> >                                 case 0://delete one variabel entry and move - Mehrere Schmieden/Kasernen etc. zulassen!
> >                                 {
> > //                                if((((*pGoal)->isVariable[Code[0][x]]==1)&&((*pGoal)->isVariable[Code[1][x]]==1))||(!configuration.preprocessBuildOrder)) TODO
> >                                                 //TODO: ueberlegen, ob Code evtl struct sein sollte... mmmh
> 1284c1309
> < 					for(unsigned int i=x;i<MAX_LENGTH-1;i++)
> ---
> >                                         for(unsigned int i=x;i<MAX_LENGTH-1;i++)
> 1289,1290c1314,1315
> < 					// TODO hier auch das buildable und tMaxBuildTypes rein... irgendwie den Code als "mutier mich" markieren und spaetereinfuegen
> < //					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
> ---
> >                                         // TODO hier auch das buildable und tMaxBuildTypes rein... irgendwie den Code als "mutier mich" markieren und spaetereinfuegen
> > 					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
> 1292,1304c1317,1329
> < //				if(configuration.preprocessBuildOrder) // TODO
> < //				while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> < //				else
> < 					y = situation->getTGeno(rand()%situation->getTMaxBuildTypes());//(*pGoal)->getMaxBuildTypes();
> < 					Code[MAX_LENGTH-1]=y;
> < //				if(configuration.preprocessBuildOrder) // TODO
> < //				while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> < //				else
> < //				y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < //				Code[1][MAX_LENGTH-1]=y;
> < 				}break;
> < 				case 1://add one variable entry
> < 				{
> ---
> > //                                if(configuration.preprocessBuildOrder) // TODO
> > //                                while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> > //                                else
> >                                         y = situation->getTGeno(rand()%situation->getTMaxBuildTypes());//(*pGoal)->getMaxBuildTypes();
> >                                         Code[MAX_LENGTH-1]=y;
> > //                                if(configuration.preprocessBuildOrder) // TODO
> > //                                while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> > //                                else
> > //                                y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> > //                                Code[1][MAX_LENGTH-1]=y;
> >                                 }break;
> >                                 case 1://add one variable entry
> >                                 {
> 1308,1388c1333,1413
> < /*					for(unsigned int i=MAX_LENGTH-1;i>x;i--)
> < 					{
> < 						Code[i]=Code[i-1];
> < 						Marker[i]=Marker[i-1];
> < 					}*/
> < //					markerCounter++;Marker[x]=markerCounter;
> < 					unsigned int y;
> < //				if(configuration.preprocessBuildOrder) TODO
> < //					while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < //				else
> < 					y=situation->getTGeno(rand()%situation->getTMaxBuildTypes());//(*pGoal)->getMaxBuildTypes();
> < 					Code[x]=y;
> < //				if(configuration.preprocessBuildOrder)
> < //					while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> < //				else
> < 				}break;
> < 				case 2://change one entry
> < 				{
> < //				if((*pGoal)->isVariable[Code[k][x]]==1) TODO
> < 					{
> < 						int y;
> < 						//int y=rand()%(*pGoal)->getMaxBuildTypes();//Optimieren
> < //					if(configuration.preprocessBuildOrder) TODO
> < //						while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> < //					else
> < 						y=situation->getTGeno(rand()%situation->getTMaxBuildTypes());//(*pGoal)->getMaxBuildTypes();
> < 						Code[x]=y;
> < 						markerCounter++;Marker[x]=markerCounter;
738,739c4774,4786
< < 	if(program[ip].successUnit >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::getProgramSuccessUnit): Variable not initialized.");return(0);
---
> < 				}break;
> < 				case 3://exchange two entries
> < 					if(x < MAX_LENGTH)
> < 					{
> < 						//hier erst recht
> < 						unsigned int y=rand()%(MAX_LENGTH-x) + x;
> < //					y=rand()%MAX_LENGTH; //TODO: Aendern in bevorzugtes Ziel => Naehe
> < //					if(abs(x-y)>(MAX_LENGTH/2)) y=rand()%MAX_LENGTH;
> < 						if(situation->getBuildable((*pGoal)->toPhaeno(Code[y])))
> < 						{
> < 							unsigned int l;
> < 							l=Code[x];Code[x]=Code[y];Code[y]=l;
> < 							l=Marker[x];Marker[x]=Marker[y];Marker[y]=l;
741,742c4788,4803
< < #endif
< < 	return(program[ip].successUnit);
---
> < 					}break;
> < 					case 4://move a block of orders  [a..b..ta..tb..c..d] -> [a..ta..tb..b..c..d]
> < 					//~~~TODO bug, marker und code wird nicht richtig verschoben
> < 					if((getLength()>2)&&(x>0))
> < 					{
> < 						unsigned int block_length = rand()%(MAX_LENGTH-x);
> < 						unsigned int target_position = rand()%x;
> < 						if(block_length > 0)
> < 						{       
> < 							unsigned int tmpCode[MAX_LENGTH];
> < 							unsigned int tmpMarker[MAX_LENGTH];
> < 							
> < 							for(unsigned int i = 0; i < block_length; i++)
> < 							{
> < 								tmpCode[i] = Code[x + i];
> < 								tmpMarker[i] = Marker[x + i];
745c4806
< < /*inline void ANARACE::setProgramIsConstant(const unsigned int ip, const bool isConstant)
---
> < 							for(unsigned int i = target_position; i < x; i++)
747,748c4808,4809
< < 		if((ip >= MAX_LENGTH)) {
< < 				toLog("DEBUG: (ANARACE::setProgramIsConstant): Value ip out of range.");return(0);
---
> < 								Code[i+block_length] = Code[i];
> < 								Marker[i+block_length] = Marker[i];
750,751d4810
< < 		program[ip].isConstant = isConstant;
< < };*/
753c4812
< < inline void ANARACE::setProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
---
> < 							for(unsigned int i = 0; i<block_length; i++)
754a4814,4819
> < 								Code[target_position + i] = tmpCode[i];
> < 								Marker[target_position + i] = tmpMarker[i];
> < 							}
> < 						}
> < 					}break; 
> < 				default:
756,757c4821,4823
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value ip out of range.");return;
---
> < 				toLog("ERROR in PRERACE::mutateGeneCode: rand out of Range");
> < #endif
> < 				break; // TODO ERROR
759,760d4824
< < 	if(unit_type >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_type out of range.");return;
762,763c4826,4926
< < 	if(unit_count >= MAX_TOTAL_UNITS) {
< < 		toLog("DEBUG: (ANARACE::setProgramAvailibleCount): Value unit_count out of range.");return;
---
> ---
> > /*                                        for(unsigned int i=MAX_LENGTH-1;i>x;i--)
> >                                         {
> >                                                 Code[i]=Code[i-1];
> >                                                 Marker[i]=Marker[i-1];
> >                                         }*/
> >                                         markerCounter++;Marker[x]=markerCounter;
> >                                         unsigned int y;
> > //                                if(configuration.preprocessBuildOrder) TODO
> > //                                        while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> > //                                else
> >                                         y=situation->getTGeno(rand()%situation->getTMaxBuildTypes());//(*pGoal)->getMaxBuildTypes();
> >                                         Code[x]=y;
> > //                                if(configuration.preprocessBuildOrder)
> > //                                        while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> > //                                else
> >                                 }break;
> >                                 case 2://change one entry
> >                                 {
> > //                                if((*pGoal)->isVariable[Code[k][x]]==1) TODO
> >                                         {
> >                                                 int y;
> >                                                 //int y=rand()%(*pGoal)->getMaxBuildTypes();//Optimieren
> > //                                        if(configuration.preprocessBuildOrder) TODO
> > //                                                while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> > //                                        else
> >                                                 y=situation->getTGeno(rand()%situation->getTMaxBuildTypes());//(*pGoal)->getMaxBuildTypes();
> >                                                 Code[x]=y;
> >                                                 markerCounter++;Marker[x]=markerCounter;
> >                                         }
> >                                 }break;
> >                                 case 3://exchange two entries
> >                                         if(x < MAX_LENGTH)
> >                                         {
> >                                                 //hier erst recht
> >                                                 unsigned int y=rand()%(MAX_LENGTH-x) + x;
> > //                                        y=rand()%MAX_LENGTH; //TODO: Aendern in bevorzugtes Ziel => Naehe
> > //                                        if(abs(x-y)>(MAX_LENGTH/2)) y=rand()%MAX_LENGTH;
> >                                                 if(situation->getBuildable((*pGoal)->toPhaeno(Code[y])))
> >                                                 {
> >                                                         unsigned int l;
> >                                                         l=Code[x];Code[x]=Code[y];Code[y]=l;
> >                                                         l=Marker[x];Marker[x]=Marker[y];Marker[y]=l;
> >                                                 }
> >                                         }break;
> >                                         case 4://move a block of orders  [a..b..ta..tb..c..d] -> [a..ta..tb..b..c..d]
> >                                         //~~~TODO bug, marker und code wird nicht richtig verschoben
> >                                         if((getLength()>2)&&(x>0))
> >                                         {
> >                                                 unsigned int block_length = rand()%(MAX_LENGTH-x);
> >                                                 unsigned int target_position = rand()%x;
> >                                                 if(block_length > 0)
> >                                                 {       
> >                                                         unsigned int tmpCode[MAX_LENGTH];
> >                                                         unsigned int tmpMarker[MAX_LENGTH];
> >                                                         
> >                                                         for(unsigned int i = 0; i < block_length; i++)
> >                                                         {
> >                                                                 tmpCode[i] = Code[x + i];
> >                                                                 tmpMarker[i] = Marker[x + i];
> >                                                         }
> >                                                                 
> >                                                         for(unsigned int i = target_position; i < x; i++)
> >                                                         {
> >                                                                 Code[i+block_length] = Code[i];
> >                                                                 Marker[i+block_length] = Marker[i];
> >                                                         }
> > 
> >                                                         for(unsigned int i = 0; i<block_length; i++)
> >                                                         {
> >                                                                 Code[target_position + i] = tmpCode[i];
> >                                                                 Marker[target_position + i] = tmpMarker[i];
> >                                                         }
> >                                                 }
> >                                         }break; 
> >                                 default:
> > #ifdef _SCC_DEBUG                       
> >                                 toLog("ERROR in PRERACE::mutateGeneCode: rand out of Range");
> > #endif
> >                                 break; // TODO ERROR
> >                         }
> >                 }                       
> 1391c1416
> < 		map<CODE, SITUATION*>::iterator foundSolution = situationHashMap.find(*theCode);
> ---
> >         	map<CODE, SITUATION*>::iterator foundSolution = situationHashMap.find(*theCode);
> 1399,1400c1424,1425
> < 			if((*pStats)[(*pGoal)->toPhaeno(Code[x])].create>0)
> < 				situation->setForce((*pStats)[(*pGoal)->toPhaeno(Code[x])].create, (*pStats)[(*pGoal)->toPhaeno(Code[x])].create + 1);
> ---
> >                         if((*pStats)[(*pGoal)->toPhaeno(Code[x])].create>0)
> >                                 situation->setForce((*pStats)[(*pGoal)->toPhaeno(Code[x])].create, (*pStats)[(*pGoal)->toPhaeno(Code[x])].create + 1);
> 1403,1414c1428,1439
> < 		for(unsigned int i = GAS_SCV+1; i--;)
> < 		{
> < 			if(situation->getForce(i))
> < 			{
> < 				bool ok=true;
> < 				for(int j=GAS_SCV+1;j--;)
> < 					if((situation->getForce(j))&&((*pStats)[j].create>0)&&((*pStats)[j].create == i)) {
> < 						ok=false;break;
765,766c4928,4946
< < #endif
< < 	program[ip].availibleCount[unit_type] = unit_count;
---
> < 				if(ok)
> < 				{
> < 					situation->setTGeno(situation->getTMaxBuildTypes(), (*pGoal)->toGeno(i));
> ---
> >                 for(unsigned int i = GAS_SCV+1; i--;)
> >                 {
> >                         if(situation->getForce(i))
> >                         {
> >                                 bool ok=true;
> >                                 for(int j=GAS_SCV+1;j--;)
> >                                         if((situation->getForce(j))&&((*pStats)[j].create>0)&&((*pStats)[j].create == i)) {
> >                                                 ok=false;break;
> >                                         }
> >                                 if(ok)
> >                                 {
> >                                         situation->setTGeno(situation->getTMaxBuildTypes(), (*pGoal)->toGeno(i));
> 1416,1428c1441,1453
> < 					situation->addTMaxBuildTypes();
> < 					situation->setBuildable(i, 1);
767a4948
> < 			} else
769,773c4950,4972
< < inline void ANARACE::setProgramTotalCount(const unsigned int ip, const unsigned int unit_type, const unsigned int unit_count)
< < {
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value ip out of range.");return;
---
> < 			if(  ( ((*pGoal)->getIsBuildable(i) ) &&
> < 			   (((*pStats)[i].prerequisite[0]==0)||(situation->getForce((*pStats)[i].prerequisite[0])))&&
> < 			   (((*pStats)[i].prerequisite[1]==0)||(situation->getForce((*pStats)[i].prerequisite[1])))&&
> < 			   (((*pStats)[i].prerequisite[2]==0)||(situation->getForce((*pStats)[i].prerequisite[2])))&&
> < 			   ((((*pStats)[i].facility[0]>0)&&(situation->getForce((*pStats)[i].facility[0])))||
> < 			   (((*pStats)[i].facility[1]>0)&&(situation->getForce((*pStats)[i].facility[1])))||
> < 			   (((*pStats)[i].facility[2]>0)&&(situation->getForce((*pStats)[i].facility[2])))||
> < 			   (((*pStats)[i].facility[0]==(*pStats)[i].facility[1]==(*pStats)[i].facility[2]==0)))))
> ---
> >                                         situation->addTMaxBuildTypes();
> >                                         situation->setBuildable(i, 1);
> >                                 }
> >                         } else
> > 
> >                         if(  ( ((*pGoal)->getIsBuildable(i) ) &&
> >                            (((*pStats)[i].prerequisite[0]==0)||(situation->getForce((*pStats)[i].prerequisite[0])))&&
> >                            (((*pStats)[i].prerequisite[1]==0)||(situation->getForce((*pStats)[i].prerequisite[1])))&&
> >                            (((*pStats)[i].prerequisite[2]==0)||(situation->getForce((*pStats)[i].prerequisite[2])))&&
> >                            ((((*pStats)[i].facility[0]>0)&&(situation->getForce((*pStats)[i].facility[0])))||
> >                            (((*pStats)[i].facility[1]>0)&&(situation->getForce((*pStats)[i].facility[1])))||
> >                            (((*pStats)[i].facility[2]>0)&&(situation->getForce((*pStats)[i].facility[2])))||
> >                            (((*pStats)[i].facility[0]==(*pStats)[i].facility[1]==(*pStats)[i].facility[2]==0)))))
> 1449c1474
775,776c4974,4980
< < 	if(unit_type >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_type out of range.");return;
---
> ---
> >                 }
> 1451c1476
> < //		situationHashMap.insert(pair<CODE, SITUATION*>(*theCode, situation));
> ---
> > //                situationHashMap.insert(pair<CODE, SITUATION*>(*theCode, situation));
> 1459c1484
778,779c4982,5085
< < 	if(unit_count >= MAX_TOTAL_UNITS) {
< < 		toLog("DEBUG: (ANARACE::setProgramTotalCount): Value unit_count out of range.");return;
---
> ---
> >         }                               
> 1479a1505,1506
> > 	
> > 
> 1491c1518
> < 	for(unsigned int i = LAST_UNIT;i--;)
> ---
> > 	for(unsigned int i=GAS_SCV+1;i--;)
> 1522,1530c1549,1557
> < 		if(rand() % (MAX_LENGTH*100/configuration.getMutationFactor())==0)
> < 		{
> < 			switch(rand() % 4)
> < 			{
> < 				//TODO: wenn generateBuildOrder==1 dann bleibts stehen!
> < 				case 0://delete one variabel entry and move - Mehrere Schmieden/Kasernen etc. zulassen!
> < 				{
> < //				if((((*pGoal)->isVariable[Code[0][x]]==1)&&((*pGoal)->isVariable[Code[1][x]]==1))||(!configuration.preprocessBuildOrder)) TODO
> < 						//TODO: ueberlegen, ob Code evtl struct sein sollte... mmmh
> ---
> >                 if(rand() % (MAX_LENGTH*100/configuration.getMutationFactor())==0)
> >                 {
> >                         switch(rand() % 4)
> >                         {
> >                                 //TODO: wenn generateBuildOrder==1 dann bleibts stehen!
> >                                 case 0://delete one variabel entry and move - Mehrere Schmieden/Kasernen etc. zulassen!
> >                                 {
> > //                                if((((*pGoal)->isVariable[Code[0][x]]==1)&&((*pGoal)->isVariable[Code[1][x]]==1))||(!configuration.preprocessBuildOrder)) TODO
> >                                                 //TODO: ueberlegen, ob Code evtl struct sein sollte... mmmh
> 1537c1564
> < 					for(unsigned int i=x;i<MAX_LENGTH-1;i++)
> ---
> >                                         for(unsigned int i=x;i<MAX_LENGTH-1;i++)
> 1540c1567
> < //						Marker[i] = Marker[i+1];
> ---
> > 						Marker[i] = Marker[i+1];
> 1542,1543c1569,1570
> < 					// TODO hier auch das buildable und tMaxBuildTypes rein... irgendwie den Code als "mutier mich" markieren und spaetereinfuegen
> < //					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
> ---
> >                                         // TODO hier auch das buildable und tMaxBuildTypes rein... irgendwie den Code als "mutier mich" markieren und spaetereinfuegen
> > 					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
> 1545,1557c1572,1584
> < //				if(configuration.preprocessBuildOrder) // TODO
> < //				while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> < //				else
> < 					y = tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < 					Code[MAX_LENGTH-1]=y;
> < //				if(configuration.preprocessBuildOrder) // TODO
> < //				while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> < //				else
> < //				y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < //				Code[1][MAX_LENGTH-1]=y;
> < 				}break;
> < 				case 1://add one variable entry
> < 				{
> ---
> > //                                if(configuration.preprocessBuildOrder) // TODO
> > //                                while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> > //                                else
> >                                         y = tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> >                                         Code[MAX_LENGTH-1]=y;
> > //                                if(configuration.preprocessBuildOrder) // TODO
> > //                                while((*pGoal)->isVariable[y]==0) y=rand()%(*pGoal)->getMaxBuildTypes();
> > //                                else
> > //                                y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> > //                                Code[1][MAX_LENGTH-1]=y;
> >                                 }break;
> >                                 case 1://add one variable entry
> >                                 {
> 1559c1586
> < //					memmove(Marker+x+1, Marker+x, MAX_LENGTH-x-1);
> ---
> > 					memmove(Marker+x+1, Marker+x, MAX_LENGTH-x-1);
> 1561,1641c1588,1668
> < /*					for(unsigned int i=MAX_LENGTH-1;i>x;i--)
> < 					{
> < 						Code[i]=Code[i-1];
> < 						Marker[i]=Marker[i-1];
> < 					}*/
> < //					markerCounter++;Marker[x]=markerCounter;
> < 					unsigned int y;
> < //				if(configuration.preprocessBuildOrder) TODO
> < //					while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < //				else
> < 					y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < 					Code[x]=y;
> < //				if(configuration.preprocessBuildOrder)
> < //					while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> < //				else
> < 				}break;
> < 				case 2://change one entry
> < 				{
> < //				if((*pGoal)->isVariable[Code[k][x]]==1) TODO
> < 					{
> < 						int y;
> < 						//int y=rand()%(*pGoal)->getMaxBuildTypes();//Optimieren
> < //					if(configuration.preprocessBuildOrder) TODO
> < //						while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> < //					else
> < 						y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> < 						Code[x]=y;
> < //						markerCounter++;Marker[x]=markerCounter;
781,782c5087,5099
< < #endif
< < 	program[ip].forceCount[unit_type] = unit_count;
---
> < 				}break;
> < 				case 3://exchange two entries
> < 					if(x < MAX_LENGTH)
> < 					{
> < 						//hier erst recht
> < 						unsigned int y=rand()%(MAX_LENGTH-x) + x;
> < //					y=rand()%MAX_LENGTH; //TODO: Aendern in bevorzugtes Ziel => Naehe
> < //					if(abs(x-y)>(MAX_LENGTH/2)) y=rand()%MAX_LENGTH;
> < 						if(buildable[(*pGoal)->toPhaeno(Code[y])])
> < 						{
> < 							unsigned int l;
> < 							l=Code[x];Code[x]=Code[y];Code[y]=l;
> < //							l=Marker[x];Marker[x]=Marker[y];Marker[y]=l;
783a5101,5111
> < 					}break;
> < 				case 4://move a block of orders  [a..b..ta..tb..c..d] -> [a..ta..tb..b..c..d]
> < 					//~~~TODO bug, marker und code wird nicht richtig verschoben
> < 					if((getLength()>2)&&(x>0))
> < 					{
> < 						unsigned int block_length = rand()%(MAX_LENGTH-x);
> < 						unsigned int target_position = rand()%x;
> < 						if(block_length > 0)
> < 						{       
> < 							unsigned int tmpCode[MAX_LENGTH];
> < //							unsigned int tmpMarker[MAX_LENGTH];
785,786c5113
< < // first time is 0!
< < inline void ANARACE::setProgramTime(const unsigned int ip, const unsigned int program_time)
---
> < 							for(unsigned int i = 0; i < block_length; i++)
788,793c5115,5116
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramTime): Value ip out of range.");return;
< < 	}
< < 	if(program_time > configuration.getMaxTime()) {
< < 		toLog("DEBUG: (ANARACE::setProgramTime): Value program_time out of range.");return;
---
> < 								tmpCode[i] = Code[x + i];
> < //								tmpMarker[i] = Marker[x + i];
795,796c5118,5122
< < #endif
< < 	program[ip].time = program_time;
---
> < 								
> < 							for(unsigned int i = target_position; i < x; i++)
> < 							{
> < 								Code[i+block_length] = Code[i];
> < //								Marker[i+block_length] = Marker[i];
799c5125
< < inline void ANARACE::setProgramBT(const unsigned int ip, const unsigned int program_bt)
---
> < 							for(unsigned int i = 0; i<block_length; i++)
801,803c5127,5128
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramBT): Value ip out of range.");return;
---
> < 								Code[target_position + i] = tmpCode[i];
> < //								Marker[target_position + i] = tmpMarker[i];
805,806d5129
< < 	if(program_bt >= MAX_TIME) {
< < 		toLog("DEBUG: (ANARACE::setProgramBT): Value program_bt out of range.");return;
807a5131,5134
> < 					}break; 
> < 				default:
> < #ifdef _SCC_DEBUG		       
> < 				toLog("ERROR in PRERACE::mutateGeneCode: rand out of Range");
809c5136
< < 	program[ip].BT = program_bt;
---
> < 				break; // TODO ERROR
811,812c5138,5226
< < 
< < inline void ANARACE::setProgramIsBuilt(const unsigned int ip, const bool program_is_built)
---
> < 		}
> ---
> > /*                                        for(unsigned int i=MAX_LENGTH-1;i>x;i--)
> >                                         {
> >                                                 Code[i]=Code[i-1];
> >                                                 Marker[i]=Marker[i-1];
> >                                         }*/
> >                                         markerCounter++;Marker[x]=markerCounter;
> >                                         unsigned int y;
> > //                                if(configuration.preprocessBuildOrder) TODO
> > //                                        while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> > //                                else
> >                                         y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> >                                         Code[x]=y;
> > //                                if(configuration.preprocessBuildOrder)
> > //                                        while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> > //                                else
> >                                 }break;
> >                                 case 2://change one entry
> >                                 {
> > //                                if((*pGoal)->isVariable[Code[k][x]]==1) TODO
> >                                         {
> >                                                 int y;
> >                                                 //int y=rand()%(*pGoal)->getMaxBuildTypes();//Optimieren
> > //                                        if(configuration.preprocessBuildOrder) TODO
> > //                                                while((*pGoal)->isVariable[y]==0) y=tGeno[rand()%tMaxBuildTypes];//rand()%(*pGoal)->getMaxBuildTypes();
> > //                                        else
> >                                                 y=tGeno[rand()%tMaxBuildTypes];//(*pGoal)->getMaxBuildTypes();
> >                                                 Code[x]=y;
> >                                                 markerCounter++;Marker[x]=markerCounter;
> >                                         }
> >                                 }break;
> >                                 case 3://exchange two entries
> >                                         if(x < MAX_LENGTH)
> >                                         {
> >                                                 //hier erst recht
> >                                                 unsigned int y=rand()%(MAX_LENGTH-x) + x;
> > //                                        y=rand()%MAX_LENGTH; //TODO: Aendern in bevorzugtes Ziel => Naehe
> > //                                        if(abs(x-y)>(MAX_LENGTH/2)) y=rand()%MAX_LENGTH;
> >                                                 if(buildable[(*pGoal)->toPhaeno(Code[y])])
> >                                                 {
> >                                                         unsigned int l;
> >                                                         l=Code[x];Code[x]=Code[y];Code[y]=l;
> >                                                         l=Marker[x];Marker[x]=Marker[y];Marker[y]=l;
> >                                                 }
> >                                         }break;
> >                                         case 4://move a block of orders  [a..b..ta..tb..c..d] -> [a..ta..tb..b..c..d]
> >                                         //~~~TODO bug, marker und code wird nicht richtig verschoben
> >                                         if((getLength()>2)&&(x>0))
> >                                         {
> >                                                 unsigned int block_length = rand()%(MAX_LENGTH-x);
> >                                                 unsigned int target_position = rand()%x;
> >                                                 if(block_length > 0)
> >                                                 {       
> >                                                         unsigned int tmpCode[MAX_LENGTH];
> >                                                         unsigned int tmpMarker[MAX_LENGTH];
> >                                                         
> >                                                         for(unsigned int i = 0; i < block_length; i++)
> >                                                         {
> >                                                                 tmpCode[i] = Code[x + i];
> >                                                                 tmpMarker[i] = Marker[x + i];
> >                                                         }
> >                                                                 
> >                                                         for(unsigned int i = target_position; i < x; i++)
> >                                                         {
> >                                                                 Code[i+block_length] = Code[i];
> >                                                                 Marker[i+block_length] = Marker[i];
> >                                                         }
> > 
> >                                                         for(unsigned int i = 0; i<block_length; i++)
> >                                                         {
> >                                                                 Code[target_position + i] = tmpCode[i];
> >                                                                 Marker[target_position + i] = tmpMarker[i];
> >                                                         }
> >                                                 }
> >                                         }break; 
> >                                 default:
> > #ifdef _SCC_DEBUG                       
> >                                 toLog("ERROR in PRERACE::mutateGeneCode: rand out of Range");
> > #endif
> >                                 break; // TODO ERROR
> >                         }
> >                 }
> 1656c1683
> < 					checked[i]=true;
> ---
> >                         	        checked[i]=true;
> 1667,1672c1694,1699
> < 					for(list<unsigned int>::iterator j = newBuildable.begin();j!=newBuildable.end();j++) 
814,816c5228,5230
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramIsBuilt): Value ip out of range.");return;
---
> < 						buildable[*j]=true;
> < 						tGeno[tMaxBuildTypes]=(*pGoal)->toGeno(*j);
> < 						tMaxBuildTypes++;
818,819c5232,5257
< < #endif
< < 	program[ip].built = program_is_built;
---
> ---
> > 	                                for(list<unsigned int>::iterator j = newBuildable.begin();j!=newBuildable.end();j++) 
> >                                 	{
> >                         	                buildable[*j]=true;
> >                 	                        tGeno[tMaxBuildTypes]=(*pGoal)->toGeno(*j);
> >         	                                tMaxBuildTypes++;
> > 	                                }
> 1677,1695c1704,1722
> < 					if(!checked[i])
> < 					{
> < 						list<unsigned int> newBuildable;
> < 			       			for(list<unsigned int>::iterator j = allow[i].facility.begin();j!=allow[i].facility.end();j++)
> < 							if(need[*j].facilityIsDone())
> < 								newBuildable.push_back(*j);
> < 						for(list<unsigned int>::iterator j = allow[i].facility2.begin();j!=allow[i].facility2.end();j++)
> < 							if(need[*j].facility2IsDone())
> < 								newBuildable.push_back(*j);
> < 						for(list<unsigned int>::iterator j = allow[i].prerequisite.begin();j!=allow[i].prerequisite.end();j++)
> < 							if(need[*j].prerequisiteIsDone())
> < 								newBuildable.push_back(*j);
> < 				       		checked[i]=true;
> < 						for(list<unsigned int>::iterator j = newBuildable.begin();j!=newBuildable.end();j++)
> < 						{
> < 							buildable[*j]=true;
> < 							tGeno[tMaxBuildTypes]=(*pGoal)->toGeno(*j);
> < 							tMaxBuildTypes++;
820a5259,5302
> ---
> > 	        	                if(!checked[i])
> >         	        	        {
> >                 	        	        list<unsigned int> newBuildable;
> > 	                       	        	for(list<unsigned int>::iterator j = allow[i].facility.begin();j!=allow[i].facility.end();j++)
> >         	                	        	if(need[*j].facilityIsDone())
> > 	        	                	                newBuildable.push_back(*j);
> >         	        	                for(list<unsigned int>::iterator j = allow[i].facility2.begin();j!=allow[i].facility2.end();j++)
> > 		                	                if(need[*j].facility2IsDone())
> >                 		        	                newBuildable.push_back(*j);
> > 	        				for(list<unsigned int>::iterator j = allow[i].prerequisite.begin();j!=allow[i].prerequisite.end();j++)
> > 		        	                        if(need[*j].prerequisiteIsDone())
> > 		                	                        newBuildable.push_back(*j);
> >                 		       	        checked[i]=true;
> >                                 		for(list<unsigned int>::iterator j = newBuildable.begin();j!=newBuildable.end();j++)
> > 	                                	{
> >         	                                	buildable[*j]=true;
> > 	                	                        tGeno[tMaxBuildTypes]=(*pGoal)->toGeno(*j);
> >         	                	                tMaxBuildTypes++;
> >                 	                	}
> 1886c1913
> < //			markerCounter++;setMarker(i, markerCounter);
> ---
> > 			markerCounter++;setMarker(i, markerCounter);
> 1945c1972,1977
> < //	memcpy(Marker, player.Marker, sizeof(int) * MAX_LENGTH);
> ---
> > 	memcpy(Marker, player.Marker, sizeof(int) * MAX_LENGTH);
> > /*	for(int i=MAX_LENGTH;i--;)
> > 	{
> > 		Code[i] = player.Code[i];
> > 		Marker[i] = player.Marker[i];
> > 	}*/
> 1957c1989
> < //unsigned int PRERACE::markerCounter;
> ---
> > unsigned int PRERACE::markerCounter;
> diff ./prerace.hpp /home/claw/work/sc1063b/sc/core/prerace.hpp
> 55,60d54
> < struct PARALLEL_COMMAND
> < {
> < 	unsigned int unit;
> < 	unsigned int count;
> < };
822c5304,5766
< < inline void ANARACE::setProgramLocation(const unsigned int ip, const unsigned int program_location)
---
> 63c57
> < 	protected:
> ---
> > protected:
> 66,67c60,61
> < //		UNIT* global; // non-static pointer to player's global total force (location 0.total)
> < 		UNIT* location; // non-static pointer to players total/availible units
> ---
> > //	UNIT* global; // non-static pointer to player's global total force (location 0.total)
> > 	UNIT* location; // non-static pointer to players total/availible units
> 69c63
> < 		const START_CONDITION* const* pStartCondition; //pointer to player in start
> ---
> > 	const START_CONDITION* const* pStartCondition; //pointer to player in start
> 71c65
> < 		static const BASIC_MAP* const* pMap; // MAP is all the same for all players using 'start
> ---
> > 	static const BASIC_MAP* const* pMap; // MAP is all the same for all players using 'start
> 74,75c68
> < 		priority_queue<Building, vector<Building> > buildingQueue;
> < 		list<PARALLEL_COMMAND*> parallelCommandQueues;
> ---
> > 	priority_queue<Building, deque<Building> > buildingQueue;
> 78,85c71,78
> < 		static signed int noise[MAX_TIME];
> < //		static unsigned int markerCounter;
> < 		static UNIT unit[MAX_PLAYER][MAX_LOCATIONS]; // player 0 is neutral player!
> < //		LAST last[MAX_LENGTH]; // last* is to save the last position, for movements
> < //		unsigned int lastcounter;
> < //		unsigned int lastunit;
> < 		const UNIT_STATISTICS* const* pStats;
> < 		unsigned int neededMinerals, neededGas;
> ---
> > 	static signed int noise[MAX_TIME];
> > 	static unsigned int markerCounter;
> > 	static UNIT unit[MAX_PLAYER][MAX_LOCATIONS]; // player 0 is neutral player!
> > //	LAST last[MAX_LENGTH]; // last* is to save the last position, for movements
> > //	unsigned int lastcounter;
> > //	unsigned int lastunit;
> > 	const UNIT_STATISTICS* const* pStats;
> > 	unsigned int neededMinerals, neededGas;
> 87c80
> < 		static START* pStart;
> ---
> > 	static START* pStart;
> 89,100c82,94
> < 		void createSpecial();
> < 		void resetSpecial();
> < 		void resetPrerace();
> < 
> < 		const unsigned int harvestMinerals() const;
> < 		const unsigned int harvestGas() const; 
> < 
> < 		const bool calculateReady() const;
> < 		void adjustAvailibility(const unsigned int location_number, const unsigned int fac, const UNIT_STATISTICS* stat);
> < 		void adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2, const unsigned int count);
> < 		const unsigned int calculatePrimaryFitness(const bool ready);
> < 		void replaceCode(const unsigned int ip, const unsigned int code);
> ---
> > 	void createSpecial();
> > 	void resetSpecial();
> > 	void resetPrerace();
> > 	static void resetStaticPrerace();
> > 
> > 	const unsigned int harvestMinerals() const;
> > 	const unsigned int harvestGas() const; 
> > 
> > 	const bool calculateReady() const;
> > 	void adjustAvailibility(const unsigned int location_number, const unsigned int fac, const UNIT_STATISTICS* stat);
> > 	void adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2);
> > 	const unsigned int calculatePrimaryFitness(const bool ready);
> > 	void replaceCode(const unsigned int ip, const unsigned int code);
> 102c96
> < 		unsigned int larvaInProduction[MAX_LOCATIONS]; // well... one of that ugly race-specific variables saves a lot of trouble...
> ---
> > 	unsigned int larvaInProduction[MAX_LOCATIONS]; // well... one of that ugly race-specific variables saves a lot of trouble...
> 106,109c100,105
> < 		const unsigned int calculateIdleTime() const; // calculate the next time something significant will happen
> < 		GOAL_ENTRY* getpGoal() const;
> < 	
> < 		bool ready;
> ---
> > 	const unsigned int calculateIdleTime() const; // calculate the next time something significant will happen
> > 	GOAL_ENTRY* getpGoal() const {
> > 		return(*pGoal);
> > 	}
> > 
> > 	bool ready;
> 111,135c107,124
> < 		GOAL_ENTRY** pGoal; // pStart->getGoal()
> < 	private:
> < 		unsigned int Code[MAX_LENGTH];
> < //		unsigned int Marker[MAX_LENGTH];
> < 
> < 		unsigned int playerNum;
> < 		unsigned int minerals, gas, timer;
> < 		unsigned int IP;
> < 		unsigned int mineralHarvestPerSecond[MAX_LOCATIONS][45];
> < 		unsigned int gasHarvestPerSecond[MAX_LOCATIONS][5];
> < 		unsigned int harvestedMinerals, harvestedGas;
> < 		unsigned int wastedMinerals, wastedGas;
> < 		unsigned int needSupply;		// free supply
> < 		unsigned int haveSupply; // total supply
> < 		unsigned int length;
> < 		unsigned int timeout;
> < 
> < 	public:
> < 		static void assignStart(START* start);
> < //		static map<CODE, SITUATION*> situationHashMap;
> < 
> < //		static void assignConfiguration(Configuration* pconfiguration);
> < 		static void initNoise();
> < 		static void copyMap(); //copies the startforce from map to static 'units'
> < 		static const BASIC_MAP* const* getMap(); 	
> ---
> > 	GOAL_ENTRY** pGoal; // pStart->getGoal()
> > private:
> > 	unsigned int Code[MAX_LENGTH];
> > 	unsigned int Marker[MAX_LENGTH];
> > 
> > 	unsigned int playerNum;
> > 	unsigned int minerals, gas, timer;
> > 	unsigned int IP;
> > 	unsigned int mineralHarvestPerSecond[MAX_LOCATIONS][45];
> > 	unsigned int gasHarvestPerSecond[MAX_LOCATIONS][5];
> > 	unsigned int harvestedMinerals, harvestedGas;
> > 	unsigned int wastedMinerals, wastedGas;
> > 	unsigned int needSupply;		// free supply
> > 	unsigned int haveSupply; // total supply
> > 	unsigned int length;
> > 	unsigned int timeout;
> > 
> > 
> 137,138c126,133
> < 		PRERACE();
> < 		virtual ~PRERACE();
> ---
> > public:
> > 	static void assignStart(START* start);
> > //	static map<CODE, SITUATION*> situationHashMap;
> > 
> > //	static void assignConfiguration(Configuration* pconfiguration);
> > 	static void initNoise();
> > 	static void copyMap(); //copies the startforce from map to static 'units'
> > 	static const BASIC_MAP* const* getMap(); 	
> 140,141c135,136
> < 		PRERACE& operator=(const PRERACE& object);
> < 		PRERACE(const PRERACE& object);
> ---
> > 	PRERACE();
> > 	virtual ~PRERACE();
> 143c138,141
> < 		const bool isDifferent(const unsigned int* code) const; //, const unsigned int* marker) const;
> ---
> > 	PRERACE& operator=(const PRERACE& object);
> > 	PRERACE(const PRERACE& object);
> > 
> > 	const bool isDifferent(const unsigned int* code, const unsigned int* marker) const;
> 146,156c144,154
> < 		void adjustMineralHarvest(const unsigned int location_number);
> < 		void adjustGasHarvest(const unsigned int location_number);
> < 		void adjustHarvestAllLocations();
> < 		void setMineralHarvestPerSecond(const unsigned int location_number, const unsigned int worker, const unsigned int harvest_minerals);
> < 		const unsigned int getMineralHarvestPerSecond(const unsigned int location_number, const unsigned int worker) const;
> < 		void setGasHarvestPerSecond(const unsigned int location_number, const unsigned int worker, const unsigned int harvest_gas);
> < 		const unsigned int getGasHarvestPerSecond(const unsigned int location_nubmer, const unsigned int worker) const;
> < 		const unsigned int getHarvestedMinerals() const;
> < 		const unsigned int getHarvestedGas() const;
> < 		void setHarvestedMinerals(const unsigned int harvested_minerals);
> < 		void setHarvestedGas(const unsigned int harvested_gas);
> ---
> > 	void adjustMineralHarvest(const unsigned int location_number);
> > 	void adjustGasHarvest(const unsigned int location_number);
> > 	void adjustHarvestAllLocations();
> > 	void setMineralHarvestPerSecond(const unsigned int location_number, const unsigned int worker, const unsigned int harvest_minerals);
> > 	const unsigned int getMineralHarvestPerSecond(const unsigned int location_number, const unsigned int worker) const;
> > 	void setGasHarvestPerSecond(const unsigned int location_number, const unsigned int worker, const unsigned int harvest_gas);
> > 	const unsigned int getGasHarvestPerSecond(const unsigned int location_nubmer, const unsigned int worker) const;
> > 	const unsigned int getHarvestedMinerals() const;
> > 	const unsigned int getHarvestedGas() const;
> > 	void setHarvestedMinerals(const unsigned int harvested_minerals);
> > 	void setHarvestedGas(const unsigned int harvested_gas);
> 158,161c156,159
> < 		const unsigned int getWastedMinerals() const;
> < 		const unsigned int getWastedGas() const;
> < 		void setWastedMinerals(const unsigned int wasted_minerals);
> < 		void setWastedGas(const unsigned int wasted_gas);
> ---
> > 	const unsigned int getWastedMinerals() const;
> > 	const unsigned int getWastedGas() const;
> > 	void setWastedMinerals(const unsigned int wasted_minerals);
> > 	void setWastedGas(const unsigned int wasted_gas);
> 164,172c162,170
> < 		void setPlayerNumber(const unsigned int player_number); // assigns player data from start (start minerals, supply etc.) and sets the appropriate optimized pointers (global, location, pMap etc.) CALL IT AFTER EACH MAP CHANGE AND PLAYER CHANGE!!
> < 		void initializePlayer();
> < 		void prepareForNewGeneration();
> < 
> < 		void eraseIllegalCode();
> < 		void eraseUselessCode();
> < 		void mutateGeneCode(/*const bool* fixed_list*/);
> < 		void resetGeneCode();//resets either to a pre-processed buildorder or a completely random one*/
> < //		void crossOver(PRERACE* parent2, PRERACE* child1, PRERACE* child2); TODO
> ---
> > 	void setPlayerNumber(const unsigned int player_number); // assigns player data from start (start minerals, supply etc.) and sets the appropriate optimized pointers (global, location, pMap etc.) CALL IT AFTER EACH MAP CHANGE AND PLAYER CHANGE!!
> > 	void initializePlayer();
> > 	void prepareForNewGeneration();
> > 
> > 	void eraseIllegalCode();
> > 	void eraseUselessCode();
> > 	void mutateGeneCode(/*const bool* fixed_list*/);
> > 	void resetGeneCode();//resets either to a pre-processed buildorder or a completely random one*/
> > //	void crossOver(PRERACE* parent2, PRERACE* child1, PRERACE* child2); TODO
> 174a173
> > 	const bool buildIt(const unsigned int build_unit);
> 177,189c176,188
> < //		void setMarker(const unsigned int ip, const unsigned int value);
> < 		void setCode(const unsigned int ip, const unsigned int value);
> < 		const unsigned int getCode(const unsigned int ip) const;
> < 		const unsigned int getCurrentCode() const;
> < //		const unsigned int getMarker(const unsigned int ip) const;
> < 		void copyCode(PRERACE& player);
> < 
> < 		void addLarvaToQueue(const unsigned int location_number);
> < 		void removeLarvaFromQueue(const unsigned int location_number);
> < 
> < 		const eRace getRace() const;
> < 		GOAL_ENTRY** getCurrentGoal() const;
> < 		void setCurrentGoal(GOAL_ENTRY** current_goal);
> ---
> > 	void setMarker(const unsigned int ip, const unsigned int value);
> > 	 void setCode(const unsigned int ip, const unsigned int value);
> > 	 const unsigned int getCode(const unsigned int ip) const;
> > 	 const unsigned int getCurrentCode() const;
> > 	 const unsigned int getMarker(const unsigned int ip) const;
> > 	void copyCode(PRERACE& player);
> > 
> > 	void addLarvaToQueue(const unsigned int location_number);
> > 	void removeLarvaFromQueue(const unsigned int location_number);
> > 
> > 	 const eRace getRace() const;
> > 	GOAL_ENTRY** getCurrentGoal() const;
> > 	void setCurrentGoal(GOAL_ENTRY** current_goal);
> 191c190
> < 		const START_CONDITION* const* getStartCondition(); //pointer to player in start
> ---
> > 	const START_CONDITION* const* getStartCondition(); //pointer to player in start
> 193,194c192,193
> < 		static const unsigned int getMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> < 		static const unsigned int getMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> ---
> > 	 static const unsigned int getMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> > 	 static const unsigned int getMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> 196,197c195,196
> < 		static void setMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type, const unsigned int availible);
> < 		static void setMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type, const unsigned int total);
> ---
> > 	static void setMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type, const unsigned int availible);
> > 	static void setMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type, const unsigned int total);
> 199,202c198,201
> < 		static void addOneMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> < 		static void addOneMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> < 		static void removeOneMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> < 		static void removeOneMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> ---
> > 	static void addOneMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> > 	static void addOneMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> > 	static void removeOneMapLocationAvailible(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> > 	static void removeOneMapLocationTotal(const unsigned int player, const unsigned int location_number, const unsigned int unit_type);
> 204,205c203,204
> < 		const unsigned int getLocationAvailible(const unsigned int location_number, const unsigned int unit_type) const;
> < 		const unsigned int getLocationTotal(const unsigned int location_number, const unsigned int unit_type) const;
> ---
> > 	 const unsigned int getLocationAvailible(const unsigned int location_number, const unsigned int unit_type) const;
> > 	 const unsigned int getLocationTotal(const unsigned int location_number, const unsigned int unit_type) const;
> 207,208c206,207
> < 		void setLocationAvailible(const unsigned int location_number, const unsigned int unit_type, const unsigned int availible);
> < 		void setLocationTotal(const unsigned int location_number, const unsigned int unit_type, const unsigned int total);
> ---
> > 	void setLocationAvailible(const unsigned int location_number, const unsigned int unit_type, const unsigned int availible);
> > 	void setLocationTotal(const unsigned int location_number, const unsigned int unit_type, const unsigned int total);
> 210,234c209,210
> < 		void addLocationAvailible(const unsigned int location_number, const unsigned int unit_type, const unsigned int availible);
> < 		void addLocationTotal(const unsigned int location_number, const unsigned int unit_type, const unsigned int total);
> < 
> < 		void addOneLocationAvailible(const unsigned int location_number, const unsigned int unit_type);
> < 		void addOneLocationTotal(const unsigned int location_number, const unsigned int unit_type);
> < 		void removeOneLocationAvailible(const unsigned int location_number, const unsigned int unit_type);
> < 		void removeOneLocationTotal(const unsigned int location_number, const unsigned int unit_type);
> < 
> < 		void setNeedSupply(const unsigned int need_supply);
> < 		void setHaveSupply(const unsigned int have_supply);
> < 		void setMinerals(const unsigned int have_minerals);
> < 		void setGas(const unsigned int have_gas);
> < 
> < 		void setpStats(const UNIT_STATISTICS* const* player_stats);
> < 		const UNIT_STATISTICS* const* getpStats() const;
> < 
> < 		const unsigned int getPlayerNumber() const;
> < 		const unsigned int getNeedSupply() const;
> < 		const unsigned int getHaveSupply() const;
> < 		const unsigned int getMinerals() const;
> < 		const unsigned int getGas() const;
> < 
> < 		void setTimer(const unsigned int time);
> < 		const unsigned int getTimer() const;
> < 		const unsigned int getRealTimer() const;
> ---
> > 	void addLocationAvailible(const unsigned int location_number, const unsigned int unit_type, const unsigned int availible);
> > 	void addLocationTotal(const unsigned int location_number, const unsigned int unit_type, const unsigned int total);
> 236,237c212,233
> < 		void setTimeOut(const unsigned int time);
> < 		const unsigned int getTimeOut() const;
> ---
> > 	void addOneLocationAvailible(const unsigned int location_number, const unsigned int unit_type);
> > 	void addOneLocationTotal(const unsigned int location_number, const unsigned int unit_type);
> > 	void removeOneLocationAvailible(const unsigned int location_number, const unsigned int unit_type);
> > 	void removeOneLocationTotal(const unsigned int location_number, const unsigned int unit_type);
> > 
> > 	void setNeedSupply(const unsigned int need_supply);
> > 	void setHaveSupply(const unsigned int have_supply);
> > 	void setMinerals(const unsigned int have_minerals);
> > 	void setGas(const unsigned int have_gas);
> > 
> > 	void setpStats(const UNIT_STATISTICS* const* player_stats);
> > 	const UNIT_STATISTICS* const* getpStats() const;
> > 
> > 	const unsigned int getPlayerNumber() const;
> > 	const unsigned int getNeedSupply() const;
> > 	const unsigned int getHaveSupply() const;
> > 	const unsigned int getMinerals() const;
> > 	const unsigned int getGas() const;
> > 
> > 	void setTimer(const unsigned int time);
> > 	const unsigned int getTimer() const;
> > 	const unsigned int getRealTimer() const;
> 239,240c235,236
> < 		const unsigned int getIP() const;
> < 		void setIP(const unsigned int ip);
> ---
> > 	void setTimeOut(const unsigned int time);
> > 	const unsigned int getTimeOut() const;
> 242,244c238,239
> < 		const unsigned int getLength() const;
> < 		void setLength(const unsigned int bo_length);
> < };
> ---
> > 	const unsigned int getIP() const;
> > 	void setIP(const unsigned int ip);
> 246,248c241,242
> < inline GOAL_ENTRY* PRERACE::getpGoal() const {
> < 	return(*pGoal);
> < }
> ---
> > 	const unsigned int getLength() const;
> > 	void setLength(const unsigned int bo_length);
> 249a244
> > };
> 254c249
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 261c256
> < /*inline void PRERACE::setMarker(const unsigned int ip, const unsigned int value)
> ---
> > inline void PRERACE::setMarker(const unsigned int ip, const unsigned int value)
> 269c264
> < }*/
> ---
> > }
> 308c303
> < /*inline const unsigned int PRERACE::getMarker(const unsigned int ip) const
> ---
> > inline const unsigned int PRERACE::getMarker(const unsigned int ip) const
> 316c311
> < }*/
> ---
> > }
> 327c322
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 340c335
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 353c348
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 366c361
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 379c374
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 392c387
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 405c400
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 419c414
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 429c424
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 439c434
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 449c444
> < 	if(location_number >= (*getMap())->getMaxLocations())	{
> ---
> > 	if(location_number >= MAX_LOCATIONS)	{
> 459c454
> < 	if(location_number >= (*getMap())->getMaxLocations()) {
> ---
> > 	if(location_number >= MAX_LOCATIONS) {
> 471c466
> < 	if(location_number >= (*getMap())->getMaxLocations())	{
> ---
> > 	if(location_number >= MAX_LOCATIONS)	{
> 483c478
> < 	if(location_number >= (*getMap())->getMaxLocations()) {
> ---
> > 	if(location_number >= MAX_LOCATIONS) {
> 496c491
> < 	if(location_number >= (*getMap())->getMaxLocations()) {
> ---
> > 	if(location_number >= MAX_LOCATIONS) {
> 508c503
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 521c516
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 622c617
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 635c630
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 654c649
> < 	if((location_number >= (*getMap())->getMaxLocations())) {
> ---
> > 	if((location_number >= MAX_LOCATIONS)) {
> 667c662
> < 	if((location_number >= (*getMap())->getMaxLocations()))	{
> ---
> > 	if((location_number >= MAX_LOCATIONS))	{
> 942,953d936
> < inline void PRERACE::removeLarvaFromQueue(const unsigned int location_number)
825,826c5769,5770
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramLocation): Value ip out of range.");return;
---
> < 	if((location_number<1) || (location_number >= (*getMap())->getMaxLocations())) {
> < 		toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Value location_number out of range.");return;
828,829c5772,5773
< < 	if(program_location >= MAX_LOCATIONS) {
< < 		toLog("DEBUG: (ANARACE::setProgramLocation): Value program_location out of range.");return;
---
> < 	if((larvaInProduction[location_number]<1)||(larvaInProduction[location_number]>=MAX_SUPPLY)) {
> < 		toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
832c5776
< < 	program[ip].location = program_location;
---
> < 	larvaInProduction[location_number]--;
834,835c5778,5779
< < // ------ STATISTICS SET FUNCTIONS ------
< < inline void ANARACE::setIPStatisticsNeedSupply(const unsigned int ip, const unsigned int need_supply)
---
> 955,966c938
> < inline void PRERACE::addLarvaToQueue(const unsigned int location_number)
838,839c5782,5783
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value ip out of range.");return;
---
> < 	if((location_number<1) || (location_number >= (*getMap())->getMaxLocations())) {
> < 		toLog("DEBUG: (PRERACE::addLarvaFromQueue): Value location_number out of range.");return;
841,842c5785,5786
< < 	if(need_supply > 10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::setIPStatisticsNeedSupply): Value need_supply out of range.");return;
---
> < 	if(larvaInProduction[location_number]>=MAX_SUPPLY) {
> < 		toLog("DEBUG: (PRERACE::addLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
845c5789
< < 	ipStatistics[ip].needSupply = need_supply;
---
> < 	larvaInProduction[location_number]++;
847,848c5791,5832
< 422,739d188
< < inline void ANARACE::setIPStatisticsHaveSupply(const unsigned int ip, const unsigned int have_supply)
---
> ---
> > 
> Files ./prerace.o and /home/claw/work/sc1063b/sc/core/prerace.o differ
> Only in ./: program.cpp
> Only in ./: program.hpp
> Only in ./: program.o
> diff ./race.cpp /home/claw/work/sc1063b/sc/core/race.cpp
> 33,35c33,40
> < 	mutationRate = 20;
> < 	pFitness = 0;
> < 	tFitness = 99999;
> ---
> > 	mutationRate=20;
> > 	pFitness=0;
> > 	tFitness=99999;
> > }
> > 
> > void RACE::resetStaticData()
> > {
> > 	PRERACE::resetStaticPrerace();
> 51c56
> < 	int tsF = getHarvestedMinerals() + getHarvestedGas();// - (getWastedMinerals() + getWastedGas()) / getRealTimer();
> ---
> > 	int tsF=getHarvestedMinerals() + getHarvestedGas();// - (getWastedMinerals() + getWastedGas()) / getRealTimer();
> 53c58
> < 	for(int i=GAS_SCV+1; i--;)
> ---
> > 	for(int i=GAS_SCV+1;i--;)
> 66c71
> < 	if((!getTimer()) || (ready = calculateReady()) || (!getIP())) 
> ---
> > 	if((!getTimer())||(ready=calculateReady())||(!getIP())) 
> 105c110,111
> < 	bool ok = true;
> ---
> > 	bool ok=true;
> > 	bool first=true;
> 112,137c118,121
> < 		neededMinerals = MAX_MINERALS;
> < 		neededGas = MAX_GAS;
> < 		int code = getpGoal()->toPhaeno(getCurrentCode());
> < 		if((code >= BUILD_PARALLEL_2) && (code <= BUILD_PARALLEL_16))
850,852c5834,5844
< < #ifdef _SCC_DEBUG
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value ip out of range.");return;
---
> < 			setIP(getIP()-1);
> < 			while((getpGoal()->toPhaeno(getCurrentCode()) > GAS_SCV)&&(getIP()))
> < 				setIP(getIP()-1);
> < 			PARALLEL_COMMAND* pcommand = new PARALLEL_COMMAND;
> < 			switch(code)
> < 			{
> < 				case BUILD_PARALLEL_2:pcommand->count = 2;break;
> < 				case BUILD_PARALLEL_4:pcommand->count = 4;break;
> < 				case BUILD_PARALLEL_8:pcommand->count = 8;break;
> < 				case BUILD_PARALLEL_16:pcommand->count = 16;break;
> < 				default:break; // ~~
854,855c5846,5889
< < 	if(have_supply > 10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveSupply): Value have_supply out of range.");return;
---
> < 			pcommand->unit = getpGoal()->toPhaeno(getCurrentCode());
> < 			if(getIP()) 
> < 				setIP(getIP()-1);
> < 			parallelCommandQueues.push_back(pcommand);
> < 			ok = true;
> < 		} else
> < 		{
> < 			ok = buildGene(getpGoal()->toPhaeno(getCurrentCode()));
> < 		// ~~
> ---
> > 		neededMinerals=MAX_MINERALS;
> > 		neededGas=MAX_GAS;
> > 		ok=buildGene(getpGoal()->toPhaeno(getCurrentCode()));
> > 		
> 140,142c124,126
> < //                        if(!first)
> <   //                              settFitness(gettFitness()-1);
> <     //                    first=false; TODO
> ---
> > 			if(!first)
> > 				settFitness(gettFitness()-1);
> > 			first=false;
> 144a129
> > 			
> 145a131,132
> > 
> > 
> 148,166d134
> < 		else if(!ok)
> < 		{
> < // TEST FOR PARALLEL COMMANDQUEUES
> < 			std::list<PARALLEL_COMMAND*>::iterator i = parallelCommandQueues.begin(); 
> < 			while(i != parallelCommandQueues.end())
> < 			{
> < 				ok = buildGene((*i)->unit);
> < 				if(ok)
> < 				{
> < 					(*i)->count--;
> < 					if(!(*i)->count)
> < 					{
> < 						delete *i;
> < 						i = parallelCommandQueues.erase(i);
> < 					}
> < 				} else i++;
857,858d5890
< < #endif
< < 	ipStatistics[ip].haveSupply = have_supply;
859a5892,5957
> < 		}
> 168a137
> > 
> 170c139
> < 	int t = calculateIdleTime();
> ---
> > 	int t=calculateIdleTime();
> 196c165
> < 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2, build.getUnitCount());
> ---
> > 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2);			
> 205c174
> < 			if(build.getType() == REFINERY) {
> ---
> > 			if(build.getType()==REFINERY) {
> 209c178
> < 			if((build.getType() == COMMAND_CENTER)&&(!getLocationTotal(build.getLocation(),COMMAND_CENTER))) {
> ---
> > 			if((build.getType()==COMMAND_CENTER)&&(!getLocationTotal(build.getLocation(),COMMAND_CENTER))) {
> 222c191
> < 			ready = calculateReady();
> ---
> > 			ready=calculateReady();
> 231c200
> < 			if((stat->create) && (stat->create != build.getType()) && (!build.getOnTheRun())) //one additional unit (zerglings, scourge, comsat, etc.)
> ---
> > 			if((stat->create)&&(stat->create!=build.getType())&&(!build.getOnTheRun())) //one additional unit (zerglings, scourge, comsat, etc.)
> 260,262c229,231
> < 	const UNIT_STATISTICS* stat = &(*pStats)[build_unit];
> < 	bool ok = false;
> < 	if(build_unit <= REFINERY+1)
> ---
> > 	const UNIT_STATISTICS* stat=&(*pStats)[build_unit];
> > 	bool ok=false;
> > 	if(build_unit<=REFINERY+1)
> 299,301c268,271
> <                                 if(buildIt(build_unit)==true)
> <                                 {
> <                                         ok=true;
> ---
> > 			{
> > 				if(buildIt(build_unit)==true)
> > 				{
> > 					ok=true;
> 303,308c273,281
> <                                         if(getMinerals()*3<4*stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)) settFitness(gettFitness()-2);
> <                                         if(getGas()*3<4*stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)) settFitness(gettFitness()-2);
> < //                                      if((stat->needSupply>0)&&(getNeedSupply()*4<5*stat->needSupply)) settFitness(gettFitness()-2);  TODO
> <                                         if((getMinerals()*5/4<stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit))||(getGas()*5/4<stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)))
> <                                                 settFitness(gettFitness()-1);
> <                                 } else ok = false;
> ---
> > 					if(getMinerals()*3<4*stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)) settFitness(gettFitness()-2);
> > 					if(getGas()*3<4*stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)) settFitness(gettFitness()-2);
> > //					if((stat->needSupply>0)&&(getNeedSupply()*4<5*stat->needSupply)) settFitness(gettFitness()-2);  TODO
> > 					if((getMinerals()*5/4<stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit))||
> > 					   (getGas()*5/4<stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)))
> > 						settFitness(gettFitness()-1);
> > 				}
> > // ------ END RACE SPECIFIC, tFITNESS ------
> > 			} //end minerals/gas else
> 405,531d377
> < const bool RACE::buildIt(const unsigned int build_unit)
> < {
> < 	//Zuerst: availible pruefen ob am Ort gebaut werden kann
> < 	//Wenn nicht => +/- absteigen bis alle locations durch sind
861c5959,5966
< < inline void ANARACE::setIPStatisticsHaveMinerals(const unsigned int ip, const unsigned int have_minerals)
---
> < 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> < 	bool ok = false;
> < 	unsigned int picked_facility = 0;
> < 	unsigned int current_location_window = 1; // TODO
> < //	unsigned int ttloc=0;
> < //	unsigned int j=0;
> < 
> < /*	if(lastcounter>0)
863,865c5968,5993
< < #ifdef _SCC_DEBUG
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value ip out of range.");return;
---
> < 		lastcounter--;
> < 		tloc=last[lastcounter].location;
> < 	}*/
> < 
> < 	if(stat->facility[0]==0)
> < 		ok=true;
> < 	else
> < 	// special rule for morphing units of protoss
> < 	if((stat->facility2>0) && ((stat->facilityType == IS_LOST) || (stat->facilityType == IS_MORPHING)) && (stat->facility[0] == stat->facility2))
> < 	{
> < 		if(getLocationAvailible(current_location_window, stat->facility2) >=2)
> < 		{
> < 			ok = true;
> < 			picked_facility = 0;
> < 		}
> < 	} else
> < 	{
> < 		// research/upgrade:
> < 		if((stat->facility2==0) || (getLocationAvailible(current_location_window, stat->facility2)>=1))
> < 		{
> < 		// pick one availible facility: 
> < 			for(picked_facility = 0; picked_facility<3; picked_facility++)
> < 				if((stat->facility[picked_facility]>0)&&(getLocationAvailible(current_location_window, stat->facility[picked_facility])>0))
> < 				{
> < 					ok=true;
> < 					break;
867,868d5994
< < 	if(have_minerals >= MAX_MINERALS) {
< < 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveMinerals): Value have_minerals out of range.");return;
870,871d5995
< < #endif
< < 	ipStatistics[ip].minerals = have_minerals;
874c5998,6001
< < inline void ANARACE::setIPStatisticsHaveGas(const unsigned int ip, const unsigned int have_gas)
---
> < //				j=1;
> < 				// none found? search other parts of the map... TODO
> < /*				if(!ok)
> < 					while(j<MAX_LOCATIONS)
876,878c6003,6019
< < #ifdef _SCC_DEBUG
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value ip out of range.");return;
---
> < 						ttloc=(*pMap)->getLocation(tloc)->getNearest(j);
> < //						if((stat->facility2==0)||(getLocationAvailible(ttloc,stat->facility2)>0)) TODO
> < //						{
> < //						for(fac=3;fac--;)
> < 						for(fac=0;fac<3; fac++)
> < 						if(
> < 						// special rules for morphing units of protoss
> < 						((stat->facilityType != IS_LOST) || (stat->facility[fac] != stat->facility2) || (getLocationAvailible(ttloc, stat->facility[fac]) >= 2)) &&
> < 						((stat->facility[fac] > 0) && (getLocationAvailible(ttloc, stat->facility[fac])))
> < 						|| ((stat->facility[fac]==0)&&(fac==0))) //~~
> < 																													   
> < //					  for(fac=3;fac--;)
> < //						  if( ((stat->facility[fac]>0)&&(getLocationAvailible(ttloc,stat->facility[fac])>((stat->facilityType==IS_LOST)&&(stat->facility[fac]==stat->facility2)))) || ((stat->facility[fac]==0)&&(fac==0)))
> < 							{
> < 								tloc=ttloc;
> < 								ok=true;
> < 								break;
880,881c6021,6030
< < 	if(have_gas >= MAX_GAS) {
< < 		toLog("DEBUG: (ANARACE::setIPStatisticsHaveGas): Value have_gas out of range.");return;
---
> < //						  break;
> < //					  }
> < 						j++;
> < 					}*/
> < 																													   
> < 	if((ok)&&(build_unit==REFINERY)) {
> < 		if(getMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR) <=0)
> < 			ok = false;
> < 		else
> < 			removeOneMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR);
883,884c6032,6056
< < #endif
< < 	ipStatistics[ip].gas = have_gas;
---
> < //TODO: Wenn verschiedene facilities moeglich sind, dann das letzte nehmen
> < //			  bewegliche Sachen ueberdenken...
> < //				  evtl zusaetzliche Eigenschaft 'speed' einbauen (muss sowieso noch...)... bei speed>0 ... mmmh... trifft aber auch nur auf scvs zu ... weil bringt ja wenig erst mit der hydra rumzulaufen und dann zum lurker... mmmh... aber waere trotzdem zu ueberlegen...
> < //				  auch noch ueberlegen, wenn z.B. mit scv ohne kommandozentrale woanders gesammelt wird...
> < //	  Phagen ueber Phagen...
> < 	if(ok)
> < 	{ 
> <  		if((getpGoal()->getRace()==ZERG) &&
> < //		  ((*pStats)[build_unit].facility[0]==LARVA)&&
> < 			(build_unit!=LARVA) &&
> < 		// Larva wird benoetigt zum Bau? Fein, dann bauen wir eine neue Larva falls nicht schon alle hatcheries etc. belegt sidn
> < 				// Gesamtzahl der Larven < 3 * HATCHERY?
> < 		   ((getLocationTotal(current_location_window, HATCHERY)+
> < 			 getLocationTotal(current_location_window, LAIR)+
> < 			 getLocationTotal(current_location_window, HIVE)) *3 > 
> < 			 (larvaInProduction[current_location_window]+getLocationTotal(current_location_window, LARVA)))  &&
> < // max 1 larva pro Gebaeude produzieren
> <  		   ((getLocationTotal(current_location_window, HATCHERY)+
> < 			 getLocationTotal(current_location_window, LAIR)+
> < 			 getLocationTotal(current_location_window, HIVE) > 
> < 			  larvaInProduction[current_location_window]))) // => zuwenig Larven da!
> < 			{
> < 				addLarvaToQueue(current_location_window);
> < 				if(!buildIt(LARVA));
> < //					removeLarvaFromQueue(current_location_window);
887,891c6059,6079
< < inline void ANARACE::setIPStatisticsFitness(const unsigned int ip, const unsigned int fitness)
< < {
< < #ifdef _SCC_DEBUG
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value ip out of range.");return;
---
> < 		Building build;
> < 		build.setOnTheRun(false);
> < 		build.setFacility(stat->facility[picked_facility]);
> < 		build.setLocation(current_location_window);
> < 		if(build_unit == FROM_GAS_TO_MINERALS)
> < 			build.setUnitCount(getLocationAvailible(current_location_window, GAS_SCV));
> < 		else
> < 			build.setUnitCount(1+(stat->create == build_unit));
> < 		build.setBuildFinishedTime(getTimer()-stat->BT);
> < 		build.setTotalBuildTime(stat->BT);
> < 		build.setType(build_unit);
> < // upgrade_cost is 0 if it's no upgrade
> < 		setMinerals(getMinerals()-(stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> < 		setGas(getGas()-(stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> < 		setNeedSupply(getNeedSupply()+stat->needSupply);
> < //		if((stat->needSupply>0)||(((*pStats)[stat->facility[0]].needSupply<0)&&(stat->facilityType==IS_LOST)))  TODO!!!!
> < //		setNeedSupply(getNeedSupply()-stat->needSupply); //? Beschreibung!
> < 		adjustAvailibility(current_location_window, picked_facility, stat);
> < 		buildingQueue.push(build);
> < 	} //end if(ok)
> < 	return(ok);
893,894c6081,6090
< < 	if(fitness > MAX_PFITNESS) {
< < 		toLog("DEBUG: (ANARACE::setIPStatisticsFitness): Value fitness out of range.");return;
---
> 535a382
> > 
> diff ./race.hpp /home/claw/work/sc1063b/sc/core/race.hpp
> 15d14
> < 		const bool buildIt(const unsigned int build_unit);
> 21a21
> > 		static void resetStaticData();
> 66,68c66,68
> <         if(t_fitness > MAX_TFITNESS) {
> <                 toLog("DEBUG: (RACE::settFitness): Value t_fitness out of range.");return;
896,897c6092,6104
< < #endif
< < 	ipStatistics[ip].fitness = fitness;
---
> ---
> > 	if(t_fitness > MAX_TFITNESS) {
> > 		toLog("DEBUG: (RACE::settFitness): Value t_fitness out of range.");return;
> > 	}
> 70c70
> <         tFitness = t_fitness;
> ---
> > 	tFitness = t_fitness;
> 73d72
> < 
> 97,99c96,98
> <         if(tFitness>MAX_TFITNESS) {
> <                 toLog("DEBUG: (RACE::gettFitness): Variable tFitness not initialized.");return(0);
898a6106,6114
> ---
> > 	if(tFitness>MAX_TFITNESS) {
> > 		toLog("DEBUG: (RACE::gettFitness): Variable tFitness not initialized.");return(0);
> > 	}
> 101c100
> <         return(tFitness);
> ---
> > 	return(tFitness);
> 104d102
899a6116,6133
> Files ./race.o and /home/claw/work/sc1063b/sc/core/race.o differ
> diff ./settings.cpp /home/claw/work/sc1063b/sc/core/settings.cpp
> 198,200d197
> < 						ostringstream sdf;
> < 						sdf << unit << " " << count << " " << time << " " << location;
> < 						toLog(sdf.str());
> 358c355
> < 			if((i=block.find("Distance to"))!=block.end()) 
> ---
> > 			if((i=block.find("Distances"))!=block.end()) 
> 361,364c358
> < 				int target = atoi(i->second.front().c_str());
> < 				i->second.pop_front();
> < 				basicmap->setLocationDistance(location-1, target-1, atoi(i->second.front().c_str()));
> < 				cout << location-1 << "->" << target-1 << " : " << atoi(i->second.front().c_str()) << std::endl;
> ---
> > 				basicmap->setLocationDistance(location-1, i->second);
> 379,387d372
901c6135
< < inline void ANARACE::setTimeStatisticsNeedSupply(const unsigned int time, const unsigned int need_supply)
---
> < 	for(unsigned int i = 1; i < basicmap->getMaxLocations(); i++)
903,908c6137,6140
< < #ifdef _SCC_DEBUG
< <     if((time>=MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value time out of range.");return;
< <     }
< < 	if(need_supply>10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::setTimeStatisticsNeedSupply): Value need_supply out of range.");return;
---
> < 		std::cout << "Location " << i << " ";
> < 		for(unsigned int j = 1; j < basicmap->getMaxLocations(); j++)
> < 			std::cout << basicmap->getLocation(i)->getDistance(j) << " ";
> < 		std::cout << std::endl;
910,911c6142,6150
< < #endif
< < 	timeStatistics[time].needSupply = need_supply;
---
> < 
> 389,397d373
> < 
> < 	for(unsigned int i = 1; i < basicmap->getMaxLocations(); i++)
> < 	{	
> < 		std::cout << "Location " << i << " ";
> < 		for(unsigned int j = 1; j < basicmap->getMaxLocations(); j++)
> < 			std::cout << basicmap->getLocation(i)->getDistance(j) << " ";
> < 		std::cout << std::endl;
914c6153,6164
< < inline void ANARACE::setTimeStatisticsHaveSupply(const unsigned int time, const unsigned int have_supply)
---
> 421c397
> < 			continue; // ignore line
> ---
> > 				continue; // ignore line
> 440,441c416,417
> < 			map<string, list<string> > block;
> < 			parse_block(pFile, block);
> ---
> > 				map<string, list<string> > block;
> > 				parse_block(pFile, block);
> 443,462c419,438
> < 			if((i=block.find("Name"))!=block.end()) 
916,918c6166,6167
< < #ifdef _SCC_DEBUG
< <     if((time>=MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value time out of range.");return;
---
> < 				i->second.pop_front();
> < 				startcondition->setName(i->second.front());
920,921c6169,6172
< < 	if(have_supply>10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveSupply): Value have_supply out of range.");return;
---
> < 			if((i=block.find("Minerals"))!=block.end()) 
> < 			{
> < 				i->second.pop_front();
> < 				startcondition->setMinerals(100*atoi(i->second.front().c_str()));
923,924c6174,6177
< < #endif
< < 	timeStatistics[time].haveSupply = have_supply;
---
> < 			if((i=block.find("Gas"))!=block.end()) 
> < 			{
> < 				i->second.pop_front();
> < 				startcondition->setGas(100*atoi(i->second.front().c_str()));
926,927c6179
< < 
< < inline void ANARACE::setTimeStatisticsHaveMinerals(const unsigned int time, const unsigned int have_minerals)
---
> < 			if((i=block.find("Time"))!=block.end()) 
929,931c6181,6182
< < #ifdef _SCC_DEBUG
< <     if((time >= MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value time out of range.");return;
---
> < 				i->second.pop_front();
> < 				startcondition->setStartTime(atoi(i->second.front().c_str()));
933,934c6184,6212
< < 	if(have_minerals >= MAX_MINERALS) {
< < 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveMinerals): Value have_minerals out of range.");return;
---
> ---
> > 				if((i=block.find("Name"))!=block.end()) 
> > 				{
> > 					i->second.pop_front();
> > 					startcondition->setName(i->second.front());
> > 				}
> > 				if((i=block.find("Minerals"))!=block.end()) 
> > 				{
> > 					i->second.pop_front();
> > 					startcondition->setMinerals(100*atoi(i->second.front().c_str()));
> > 				}
> > 				if((i=block.find("Gas"))!=block.end()) 
> > 				{
> > 					i->second.pop_front();
> > 					startcondition->setGas(100*atoi(i->second.front().c_str()));
> > 				}
> > 				if((i=block.find("Time"))!=block.end()) 
> > 				{
> > 					i->second.pop_front();
> > 					startcondition->setStartTime(atoi(i->second.front().c_str()));
> > 				}
> 478,485c454,461
> < 				string unit=stats[race][k].name;
> < 				if((i=block.find(unit))!=block.end())
> < 				{
> < 					i->second.pop_front();int count=atoi(i->second.front().c_str());
> < 						//TODO: values checken!
> < 					startcondition->setLocationTotal(location-1, k, count);
> < 					startcondition->setLocationAvailible(location-1, k, count);
936,937c6214,6231
< < #endif
< < 	timeStatistics[time].minerals = have_minerals;
---
> ---
> > 					string unit=stats[race][k].name;
> > 					if((i=block.find(unit))!=block.end())
> > 					{
> > 						i->second.pop_front();int count=atoi(i->second.front().c_str());
> > 							//TODO: values checken!
> > 						startcondition->setLocationTotal(location-1, k, count);
> > 						startcondition->setLocationAvailible(location-1, k, count);
> > 					}
> 504,541c480,516
> < 	ostringstream os;
> < 	os << "output/bos/";
> < 	os << raceString[anarace->getRace()] << "/" << name << ".html";
> < 	ofstream pFile(os.str().c_str(), ios_base::out | ios_base::trunc);
> < 	if(!pFile.is_open())
> < 	{
> < 		toLog("ERROR: Could not create file (write protection? disk space?)");
> < 		return;
940c6234,6641
< < inline void ANARACE::setTimeStatisticsHaveGas(const unsigned int time, const unsigned int have_gas)
---
> < 	pFile << "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">" << std::endl;
> < 	pFile << "<html>" << std::endl;
> < 	pFile << "<head>" << std::endl;
> < 	pFile << "  <meta content=\"text/html; charset=ISO-8859-1\"" << std::endl;
> < 	pFile << " http-equiv=\"content-type\">" << std::endl;
> < 	pFile << "  <title>Build order list</title>" << std::endl;
> < 	pFile << "</head>" << std::endl;
> < 	pFile << "<body alink=\"#000099\" vlink=\"#990099\" link=\"#000099\" style=\"color: rgb("<< (int)UI_Object::theme.lookUpColor(BRIGHT_TEXT_COLOR)->r() << ", " << (int)UI_Object::theme.lookUpColor(BRIGHT_TEXT_COLOR)->g() << ", " << (int)UI_Object::theme.lookUpColor(BRIGHT_TEXT_COLOR)->b() << "); background-color: rgb(" << (int)UI_Object::theme.lookUpBrush(WINDOW_BACKGROUND_BRUSH)->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_BACKGROUND_BRUSH)->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_BACKGROUND_BRUSH)->GetColor()->b() << ");\">" << std::endl;
> < 	pFile << "<div style=\"text-align: center;\"><big style=\"font-weight: bold;\"><big>Evolution Forge " << CORE_VERSION << "</big></big><br><br>" << std::endl;
> < 	pFile << "<big>Buildorder list " << name << "</big><br>" << std::endl;
> < 	pFile << "</div>" << std::endl;
> < 	pFile << "<br>" << std::endl;
> < 	pFile << "<table style=\"background-color: rgb(" << (int)UI_Object::theme.lookUpBrush(WINDOW_FOREGROUND_BRUSH)->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_FOREGROUND_BRUSH)->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_FOREGROUND_BRUSH)->GetColor()->b() << "); text-align: center; vertical-align: middle; width: 600px; margin-left: auto; margin-right: auto;\""<< std::endl;
> < 	pFile << " border=\"1\" cellspacing=\"0\" cellpadding=\"1\">" << std::endl;
> < 	pFile << "  <tbody>" << std::endl;
> < 	pFile << "	<tr>" << std::endl;
> < 	pFile << "	  <td style=\"text-align: center; vertical-align: middle; width: 200px;\">" << *UI_Object::theme.lookUpString(OUTPUT_UNITNAME_STRING) << "<br>" << std::endl;
> < 	pFile << "	  </td>" << std::endl;
> < 	pFile << "	  <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_SUPPLY_STRING) << "</td>" << std::endl;
> < 	pFile << "	  <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_MINERALS_STRING) << "<br>" << std::endl;
> < 	pFile << "	  </td>" << std::endl;
> < 	pFile << "	  <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_GAS_STRING) << "<br>" << std::endl;
> < 	pFile << "	  </td>" << std::endl;
> < 	pFile << "	  <td style=\"text-align: center; vertical-align: middle; width: 100px;\">" << *UI_Object::theme.lookUpString(OUTPUT_LOCATION_STRING) << "<br>" << std::endl;
> < 	pFile << "	  </td>" << std::endl;
> < 	pFile << "	  <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_TIME_STRING) << "<br>" << std::endl;
> < 	pFile << "	  </td>" << std::endl;
> < 	pFile << "	</tr>" << std::endl;
> ---
> >     ostringstream os;
> >     os << "output/bos/";
> >     os << raceString[anarace->getRace()] << "/" << name << ".html";
> >     ofstream pFile(os.str().c_str(), ios_base::out | ios_base::trunc);
> >     if(!pFile.is_open())
> >     {
> >         toLog("ERROR: Could not create file (write protection? disk space?)");
> >         return;
> >     }
> > pFile << "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">" << std::endl;
> > pFile << "<html>" << std::endl;
> > pFile << "<head>" << std::endl;
> > pFile << "  <meta content=\"text/html; charset=ISO-8859-1\"" << std::endl;
> > pFile << " http-equiv=\"content-type\">" << std::endl;
> > pFile << "  <title>Build order list</title>" << std::endl;
> > pFile << "</head>" << std::endl;
> > pFile << "<body alink=\"#000099\" vlink=\"#990099\" link=\"#000099\" style=\"color: rgb("<< (int)UI_Object::theme.lookUpColor(BRIGHT_TEXT_COLOR)->r() << ", " << (int)UI_Object::theme.lookUpColor(BRIGHT_TEXT_COLOR)->g() << ", " << (int)UI_Object::theme.lookUpColor(BRIGHT_TEXT_COLOR)->b() << "); background-color: rgb(" << (int)UI_Object::theme.lookUpBrush(WINDOW_BACKGROUND_BRUSH)->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_BACKGROUND_BRUSH)->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_BACKGROUND_BRUSH)->GetColor()->b() << ");\">" << std::endl;
> > pFile << "<div style=\"text-align: center;\"><big style=\"font-weight: bold;\"><big>Evolution Forge " << CORE_VERSION << "</big></big><br><br>" << std::endl;
> > pFile << "<big>Buildorder list " << name << "</big><br>" << std::endl;
> > pFile << "</div>" << std::endl;
> > pFile << "<br>" << std::endl;
> > pFile << "<table style=\"background-color: rgb(" << (int)UI_Object::theme.lookUpBrush(WINDOW_FOREGROUND_BRUSH)->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_FOREGROUND_BRUSH)->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush(WINDOW_FOREGROUND_BRUSH)->GetColor()->b() << "); text-align: center; vertical-align: middle; width: 600px; margin-left: auto; margin-right: auto;\""<< std::endl;
> > pFile << " border=\"1\" cellspacing=\"0\" cellpadding=\"1\">" << std::endl;
> > pFile << "  <tbody>" << std::endl;
> > pFile << "    <tr>" << std::endl;
> > pFile << "      <td style=\"text-align: center; vertical-align: middle; width: 200px;\">" << *UI_Object::theme.lookUpString(OUTPUT_UNITNAME_STRING) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > pFile << "      <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_SUPPLY_STRING) << "</td>" << std::endl;
> > pFile << "      <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_MINERALS_STRING) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > pFile << "      <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_GAS_STRING) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > pFile << "      <td style=\"text-align: center; vertical-align: middle; width: 100px;\">" << *UI_Object::theme.lookUpString(OUTPUT_LOCATION_STRING) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > pFile << "      <td style=\"text-align: center; vertical-align: middle; width: 75px;\">" << *UI_Object::theme.lookUpString(OUTPUT_TIME_STRING) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > pFile << "    </tr>" << std::endl;
> 543c518,519
> < 	for(std::list<PROGRAM>::const_iterator order = anarace->programList.begin(); order != anarace->programList.end(); ++order)
> ---
> > for(int i = MAX_LENGTH;i--;)
> > 	if(anarace->getProgramIsBuilt(i))
> 545,564c521,530
> < 		pFile << "	<tr style=\"text-align: center; vertical-align: middle; background-color: rgb(" << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][order->getUnit()].unitType))->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][order->getUnit()].unitType))->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][order->getUnit()].unitType))->GetColor()->b() << ");\">" << std::endl;
> < 		pFile << "	  <td style=\"\">" << *UI_Object::theme.lookUpString((eString)(UNIT_TYPE_COUNT*anarace->getRace() + order->getUnit() + UNIT_NULL_STRING)) << "<br>" << std::endl;
> < 		pFile << "	  </td>" << std::endl;
> < 		pFile << "	  <td style=\"\">" << order->getStatisticsBefore().getNeedSupply() << "/" << order->getStatisticsBefore().getHaveSupply() << "<br>" << std::endl;
> < 		pFile << "	  </td>" << std::endl;
> < 
> < 		pFile << "	  <td style=\"\">" << order->getStatisticsBefore().getHaveMinerals()/100 << "<br>" << std::endl;
> < 		pFile << "	  </td>" << std::endl;
> < 
> < 		pFile << "	  <td style=\"\">" << order->getStatisticsBefore().getHaveGas()/100 << "<br>" << std::endl;
> < 		pFile << "	  </td>" << std::endl;
> < 
> < 		pFile << "	  <td style=\"\">" << (*anarace->getMap())->getLocation(order->getLocation())->getName() << "<br>" << std::endl;
> < 		pFile << "	  </td>" << std::endl;
> < 
> < 		pFile << "	  <td style=\"\">" << formatTime(order->getRealTime()) << "<br>" << std::endl;
> < 		pFile << "	  </td>" << std::endl;
> < 																								   
> < 		pFile << "	</tr>" << std::endl;
> < 	}
> ---
> > pFile << "    <tr style=\"text-align: center; vertical-align: middle; background-color: rgb(" << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][anarace->getPhaenoCode(i)].unitType))->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][anarace->getPhaenoCode(i)].unitType))->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][anarace->getPhaenoCode(i)].unitType))->GetColor()->b() << ");\">" << std::endl;
> > 
> > pFile << "      <td style=\"\">" << *UI_Object::theme.lookUpString((eString)(UNIT_TYPE_COUNT*anarace->getRace()+anarace->getPhaenoCode(i)+UNIT_NULL_STRING)) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > 
> > pFile << "      <td style=\"\">" << anarace->getIPStatisticsNeedSupply(2*i) << "/" << anarace->getIPStatisticsHaveSupply(2*i) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > 
> > pFile << "      <td style=\"\">" << anarace->getIPStatisticsHaveMinerals(2*i)/100 << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> 566,571c532,549
> < 	pFile << "  </tbody>" << std::endl;
> < 	pFile << "</table>" << std::endl;
> < 	pFile << "<br>" << std::endl;
> < 	pFile << "<b><a href=\"http://www.clawsoftware.de\">www.clawsoftware.de</a></b>\n";
> < 	pFile << "</body>\n";
> < 	pFile << "</html>" << std::endl;
> ---
> > pFile << "      <td style=\"\">" << anarace->getIPStatisticsHaveGas(2*i)/100 << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > 
> > pFile << "      <td style=\"\">" << (*anarace->getMap())->getLocation(anarace->getProgramLocation(i))->getName() << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> > 
> > pFile << "      <td style=\"\">" << formatTime(anarace->getRealProgramTime(i)) << "<br>" << std::endl;
> > pFile << "      </td>" << std::endl;
> >                                                                                                    
> > pFile << "    </tr>" << std::endl;
> > }
> > 
> > pFile << "  </tbody>" << std::endl;
> > pFile << "</table>" << std::endl;
> > pFile << "<br>" << std::endl;
> > pFile << "<b><a href=\"http://www.clawsoftware.de\">www.clawsoftware.de</a></b>"<< std::endl;
> > pFile << "</body>" << std::endl;
> > pFile << "</html>" << std::endl;
> 587,588c565,566
> < 			toLog("ERROR: Could not create file (write protection? disk space?)");
> < 			return;
> ---
> > 	        toLog("ERROR: Could not create file (write protection? disk space?)");
> >         	return;
> 594,595c572,573
> < 	pFile << "		\"Name\" \"" << name << "\"" << std::endl; // TODO
> < 	pFile << "		\"Race\" \"" << raceString[goalentry->getRace()] << "\"" << std::endl;
> ---
> > 	pFile << "        \"Name\" \"" << name << "\"" << std::endl; // TODO
> > 	pFile << "        \"Race\" \"" << raceString[goalentry->getRace()] << "\"" << std::endl;
> 598c576
> < 		pFile << "		\"" << stats[goalentry->getRace()][i->getUnit()].name << "\" \"" << i->getCount() << "\" \"" << i->getLocation() << "\" \"" << i->getTime() << "\"" << std::endl;		
> ---
> > 		pFile << "        \"" << stats[goalentry->getRace()][i->getUnit()].name << "\" \"" << i->getCount() << "\" \"" << i->getLocation() << "\" \"" << i->getTime() << "\"" << std::endl;		
> 603a582,692
> > // -------------------------------
> > // ------ GET/SET FUNCTIONS ------
> > // -------------------------------
> > 
> > const bool SETTINGS::getIsNewRun()
> > {
> > 	return(soup.getIsNewRun());
> > }
> > 
> > const BASIC_MAP* SETTINGS::getMap(const unsigned int mapNumber) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(mapNumber>loadedMap.size()) {
> > 		toLog("WARNING: (SETTINGS::getMap): Value out of range.");return(0);
> > 	}
> > #endif
> > 	return(loadedMap[mapNumber]);
> > }
> > 
> > GOAL_ENTRY* SETTINGS::getCurrentGoal(const unsigned int player)
> > {
> > 	return(*(start.getCurrentGoal(player)));
> > }
> > 
> > //void SETTINGS::setPreprocessBuildOrder(const bool preprocess)
> > //{
> > //	configuration.setPreprocessBuildOrder(preprocess);
> > //}
> > 
> > void SETTINGS::assignMap(const unsigned int mapNumber)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(mapNumber>=loadedMap.size()) {
> > 		toLog("WARNING: (SETTINGS::assignMap): Value out of range.");return;
> > 	}
> > #endif
> > 	start.assignMap(loadedMap[mapNumber]);
> > //	soup.initializeMap(&(loadedMap[mapNumber])); //?
> > }
> > 
> > void SETTINGS::assignStartRace(const unsigned int player, const eRace race)
> > {
> > 	start.setPlayerRace(player, race);
> > }
> > 
> > void SETTINGS::assignStartcondition(const unsigned int player, const unsigned int startcondition)
> > {
> > #ifdef _SCC_DEBUG
> >     if(startcondition>=loadedStartcondition[start.getPlayerRace(player)].size()) {
> >         toLog("WARNING: (SETTINGS::setStartcondition): Value out of range.");return;
> >     }
> > #endif
> > 	start.assignStartcondition(player, loadedStartcondition[start.getPlayerRace(player)][startcondition]);
> > }
> > 
> > void SETTINGS::setHarvestSpeed(const eRace race, const unsigned int harvest)
> > {
> > 	// todo: checken ob harvest dazupasst
> > 	start.setHarvestSpeed(race, &(loadedHarvestSpeed[harvest]));
> > }
> > 
> > void SETTINGS::setStartPosition(const unsigned int player, const unsigned int startPosition)
> > {
> > 	start.setStartPosition(player, startPosition);
> > }
> > 
> > void SETTINGS::assignGoal(const unsigned int player, const unsigned int goal)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
> > 		toLog("WARNING: (SETTINGS::assignGoal): Value out of range.");return;
> > 	}
> > #endif
> > 	start.assignGoal(player, loadedGoal[start.getPlayerRace(player)][goal]);
> > }
> > 
> > const unsigned int SETTINGS::getStartconditionCount(const unsigned int player) const
> > {
> > 	return(loadedStartcondition[start.getPlayerRace(player)].size());
> > }
> > 
> > const unsigned int SETTINGS::getGoalCount(const unsigned int player) const
> > {
> > 	return(loadedGoal[start.getPlayerRace(player)].size());
> > }
> > 
> > const unsigned int SETTINGS::getMapCount() const
> > {
> > 	return(loadedMap.size());
> > }
> > 
> > const GOAL_ENTRY* SETTINGS::getGoal(const unsigned int player, const unsigned int goal) const
> > 
> > {
> > #ifdef _SCC_DEBUG
> > 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
> > 		toLog("WARNING: (SETTINGS::getGoal): Value out of range.");return(NULL);
> > 	}
> > #endif
> > 	return(loadedGoal[start.getPlayerRace(player)][goal]);
> > }
> > 
> > const START_CONDITION* SETTINGS::getStartcondition(const unsigned int player, const unsigned int startconditionNumber) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(startconditionNumber>=loadedStartcondition[start.getPlayerRace(player)].size()) {
> > 		toLog("WARNING: (SETTINGS::getStartcondition): Value out of range.");return(NULL);
> > 	}
> > #endif
> > 	return(loadedStartcondition[start.getPlayerRace(player)][startconditionNumber]);
> > }
> diff ./settings.hpp /home/claw/work/sc1063b/sc/core/settings.hpp
> 14,22c14,22
> < 	private:
> < 		vector<GOAL_ENTRY*> loadedGoal[MAX_RACES];
> < 		vector<START_CONDITION*> loadedStartcondition[MAX_RACES];
> < 		vector<BASIC_MAP*> loadedMap; //modes: 0: ignore map settings and make up a default force, 1: use map settings
> < 		HARVEST_SPEED loadedHarvestSpeed[MAX_RACES];
> < 		SOUP soup;
> < 		START start;
> < 	public:
> < 		const bool getIsNewRun();
> ---
> > private:
> > 	vector<GOAL_ENTRY*> loadedGoal[MAX_RACES];
> > 	vector<START_CONDITION*> loadedStartcondition[MAX_RACES];
> > 	vector<BASIC_MAP*> loadedMap; //modes: 0: ignore map settings and make up a default force, 1: use map settings
> > 	HARVEST_SPEED loadedHarvestSpeed[MAX_RACES];
> > 	SOUP soup;
> > 	START start;
> > public:
> > 	const bool getIsNewRun();
> 24,34c24,34
> < 		void assignMap(const unsigned int mapNumber);
> < 		void setHarvestSpeed(const eRace race, const unsigned int harvest); // copy data (pointers) from settings
> < 		void assignStartRace(const unsigned int player, const eRace race);
> < 		void assignStartcondition(const unsigned int player, const unsigned int startcondition);
> < 		void fillGroups();
> < 		void setStartPosition(const unsigned int player, const unsigned int startposition);
> < 		void assignGoal(const unsigned int player, const unsigned int goal);
> < 
> < 		void calculateAnaplayer();
> < 		const BASIC_MAP* getMap(const unsigned int mapNumber) const;
> < 		void checkForChange() const;
> ---
> > 	void assignMap(const unsigned int mapNumber);
> > 	void setHarvestSpeed(const eRace race, const unsigned int harvest); // copy data (pointers) from settings
> > 	void assignStartRace(const unsigned int player, const eRace race);
> >     void assignStartcondition(const unsigned int player, const unsigned int startcondition);
> > 	void fillGroups();
> > 	void setStartPosition(const unsigned int player, const unsigned int startposition);
> > 	void assignGoal(const unsigned int player, const unsigned int goal);
> > 
> > 	void calculateAnaplayer();
> > 	const BASIC_MAP* getMap(const unsigned int mapNumber) const;
> > 	void checkForChange() const;
> 36,37c36,37
> < 		list<string> findFiles(const string directory1, const string directory2, const string directory3) const;
> < //		void clearGoalFiles();
> ---
> > 	list<string> findFiles(const string directory1, const string directory2, const string directory3) const;
> > //	void clearGoalFiles();
> 39,57c39,57
> < /*		void setMaxTime(const unsigned int maxTime); //sets max Time in minutes
> < 		void setMaxTimeOut(const unsigned int maxTimeOut); //
> < 		void setAllowGoalAdaption(const bool allowGoalAdaption=true);
> < 		void setMaxLength(const unsigned int maxLength);
> < 		void setMaxRuns(const unsigned int maxRuns);
> < 		void setMaxGenerations(const unsigned int maxGenerations);
> < 		void setPreprocessBuildOrder(const bool preprocess);
> < 		void setBreedFactor(const unsigned int breedFactor);
> < 		void setCrossOver(const unsigned int crossOver);
> < 
> < 		const unsigned int getBreedFactor() const;
> < 		const unsigned int getCrossOver() const;
> < 		const unsigned int getMaxTime() const;
> < 		const unsigned int getMaxTimeOut() const;
> < 		const unsigned int getMaxLength() const;
> < 		const unsigned int getMaxRuns() const;
> < 		const unsigned int getMaxGenerations() const;
> < 		const unsigned int getMutationFactor() const;
> < 		const bool getPreprocessBuildOrder() const;*/
> ---
> > /*	void setMaxTime(const unsigned int maxTime); //sets max Time in minutes
> > 	void setMaxTimeOut(const unsigned int maxTimeOut); //
> > 	void setAllowGoalAdaption(const bool allowGoalAdaption=true);
> > 	void setMaxLength(const unsigned int maxLength);
> > 	void setMaxRuns(const unsigned int maxRuns);
> > 	void setMaxGenerations(const unsigned int maxGenerations);
> > 	void setPreprocessBuildOrder(const bool preprocess);
> > 	void setBreedFactor(const unsigned int breedFactor);
> > 	void setCrossOver(const unsigned int crossOver);
> > 
> > 	const unsigned int getBreedFactor() const;
> > 	const unsigned int getCrossOver() const;
> > 	const unsigned int getMaxTime() const;
> > 	const unsigned int getMaxTimeOut() const;
> > 	const unsigned int getMaxLength() const;
> > 	const unsigned int getMaxRuns() const;
> > 	const unsigned int getMaxGenerations() const;
> > 	const unsigned int getMutationFactor() const;
> > 	const bool getPreprocessBuildOrder() const;*/
> 59,62c59,62
> < 		GOAL_ENTRY* getCurrentGoal(const unsigned int player);
> < 		const unsigned int getGoalCount(const unsigned int player) const;
> < 		const unsigned int getMapCount() const;
> < 		const unsigned int getStartconditionCount(const unsigned int player) const;
> ---
> > 	GOAL_ENTRY* getCurrentGoal(const unsigned int player);
> > 	const unsigned int getGoalCount(const unsigned int player) const;
> > 	const unsigned int getMapCount() const;
> > 	const unsigned int getStartconditionCount(const unsigned int player) const;
> 64,76c64,76
> < 		void saveBuildOrder(const string& name, const ANARACE* anarace) const;
> < 		const GOAL_ENTRY* getGoal(const unsigned int player, const unsigned int goalNumber) const;
> < 		const START_CONDITION* getStartcondition(const unsigned int player, const unsigned int startconditionNumber) const;
> < 
> < //		void initDefaults(); 
> < 
> < 		void saveGoal(const string& name, GOAL_ENTRY* goalentry);
> < 
> < 		void loadStartconditionFile(const string& startconditionFile);
> < 		void loadGoalFile(const string& goalFile);
> < //		void loadSettingsFile(const string& settingsFile);
> < 		void loadMapFile(const string& mapFile);
> < 		void loadHarvestFile(const string& harvestFile);
> ---
> > 	void saveBuildOrder(const string& name, const ANARACE* anarace) const;
> > 	const GOAL_ENTRY* getGoal(const unsigned int player, const unsigned int goalNumber) const;
> > 	const START_CONDITION* getStartcondition(const unsigned int player, const unsigned int startconditionNumber) const;
> > 
> > //	void initDefaults(); 
> > 
> > 	void saveGoal(const string& name, GOAL_ENTRY* goalentry);
> > 
> > 	void loadStartconditionFile(const string& startconditionFile);
> > 	void loadGoalFile(const string& goalFile);
> > //	void loadSettingsFile(const string& settingsFile);
> > 	void loadMapFile(const string& mapFile);
> > 	void loadHarvestFile(const string& harvestFile);
> 79,80c79,80
> < 		ANARACE** newGeneration(ANARACE* oldAnarace[MAX_PLAYER]);
> < 		void assignRunParametersToSoup();
> ---
> > 	ANARACE** newGeneration(ANARACE* oldAnarace[MAX_PLAYER]);
> > 	void assignRunParametersToSoup();
> 82,83c82,83
> < 		SETTINGS();
> < 		~SETTINGS();
> ---
> > 	SETTINGS();
> > 	~SETTINGS();
> 86,189d85
> < // -------------------------------
> < // ------ GET/SET FUNCTIONS ------
> < // -------------------------------
> < 
> < inline const bool SETTINGS::getIsNewRun() {
> < 	return(soup.getIsNewRun());
> < }
> < 
> < inline const BASIC_MAP* SETTINGS::getMap(const unsigned int mapNumber) const
943,947c6644,6645
< <     if((time >= MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value time out of range.");return;
< <     }
< < 	if(have_gas >= MAX_GAS) {
< < 		toLog("DEBUG: (ANARACE::setTimeStatisticsHaveGas): Value have_gas out of range.");return;
---
> < 	if(mapNumber>loadedMap.size()) {
> < 		toLog("WARNING: (SETTINGS::getMap): Value out of range.");return(0);
950c6648
< < 	timeStatistics[time].gas = have_gas;
---
> < 	return(loadedMap[mapNumber]);
953c6651
< < inline void ANARACE::setTimeStatisticsFitness(const unsigned int time, const unsigned int fitness)
---
> < inline GOAL_ENTRY* SETTINGS::getCurrentGoal(const unsigned int player)
955,957c6653
< < #ifdef _SCC_DEBUG
< <     if((time>=MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value time out of range.");return;
---
> < 	return(*(start.getCurrentGoal(player)));
959,960c6655,6665
< < 	if(fitness>MAX_PFITNESS) {
< < 		toLog("DEBUG: (ANARACE::setTimeStatisticsFitness): Value fitness out of range.");return;
---
> < 
> < //inline void SETTINGS::setPreprocessBuildOrder(const bool preprocess)
> < //{
> < //	configuration.setPreprocessBuildOrder(preprocess);
> < //}
> < 
> < inline void SETTINGS::assignMap(const unsigned int mapNumber)
> < {
> < #ifdef _SCC_DEBUG
> < 	if(mapNumber>=loadedMap.size()) {
> < 		toLog("WARNING: (SETTINGS::assignMap): Value out of range.");return;
963c6668,6669
< < 	timeStatistics[time].fitness=fitness;
---
> < 	start.assignMap(loadedMap[mapNumber]);
> < //	soup.initializeMap(&(loadedMap[mapNumber])); //?
965d6670
< < // ------ END OF STATISTICS SET FUNCTIONS ------
966a6672,6674
> < inline void SETTINGS::assignStartRace(const unsigned int player, const eRace race) {
> < 	start.setPlayerRace(player, race);
> < }
968c6676
< < inline const unsigned int ANARACE::getProgramTotalCount(const unsigned int ip, const unsigned int unit_type) const	   // how many units of the type at phaenoCode[s] do exist at that time?
---
> < inline void SETTINGS::assignStartcondition(const unsigned int player, const unsigned int startcondition)
971,975c6679,6680
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value ip out of range.");return(0);
< < 	}
< < 	if(unit_type >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::getProgramTotalCount): Value unit_type out of range.");return(0);
---
> < 	if(startcondition>=loadedStartcondition[start.getPlayerRace(player)].size()) {
> < 		toLog("WARNING: (SETTINGS::setStartcondition): Value out of range.");return;
978c6683
< < 	return(program[ip].forceCount[unit_type]);
---
> < 	start.assignStartcondition(player, loadedStartcondition[start.getPlayerRace(player)][startcondition]);
981,982c6686,6695
< < // how many units of the type at phaenoCode[s] do exist at that time?
< < inline const unsigned int ANARACE::getProgramAvailibleCount(const unsigned int ip, const unsigned int unit_type) const	   
---
> < inline void SETTINGS::setHarvestSpeed(const eRace race, const unsigned int harvest) {
> < 	// todo: checken ob harvest dazupasst
> < 	start.setHarvestSpeed(race, &(loadedHarvestSpeed[harvest]));
> < }
> < 
> < inline void SETTINGS::setStartPosition(const unsigned int player, const unsigned int startPosition) {
> < 	start.setStartPosition(player, startPosition);
> < }
> < 
> < inline void SETTINGS::assignGoal(const unsigned int player, const unsigned int goal)
985,989c6698,6699
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value ip out of range.");return(0);
< < 	}
< < 	if(unit_type >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::getProgramAvailibleCount): Value unit_type out of range.");return(0);
---
> < 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
> < 		toLog("WARNING: (SETTINGS::assignGoal): Value out of range.");return;
992c6702
< < 	return(program[ip].availibleCount[unit_type]);
---
> < 	start.assignGoal(player, loadedGoal[start.getPlayerRace(player)][goal]);
995,999c6705,6706
< < inline void ANARACE::setProgramFacility(const unsigned int ip, const unsigned int facility)
< < {
< < #ifdef _SCC_DEBUG
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramFacility): Value ip out of range.");return;
---
> < inline const unsigned int SETTINGS::getStartconditionCount(const unsigned int player) const {
> < 	return(loadedStartcondition[start.getPlayerRace(player)].size());
1001,1002c6708,6710
< < 	if(facility>=UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::setProgramFacility): Value facility out of range.");return;
---
> < 
> < inline const unsigned int SETTINGS::getGoalCount(const unsigned int player) const {
> < 	return(loadedGoal[start.getPlayerRace(player)].size());
1004,1005c6712,6714
< < #endif
< < 	program[ip].facility = facility;
---
> < 
> < inline const unsigned int SETTINGS::getMapCount() const {
> < 	return(loadedMap.size());
1008c6717
< < inline void ANARACE::setProgramSuccessType(const unsigned int ip, const unsigned int type)
---
> < inline const GOAL_ENTRY* SETTINGS::getGoal(const unsigned int player, const unsigned int goal) const
1011,1015c6720,6721
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value ip out of range.");return;
< < 	}
< < 	if(type >= ERROR_MESSAGES) {
< < 		toLog("DEBUG: (ANARACE::setProgramSuccessType): Value type out of range.");return;
---
> < 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
> < 		toLog("WARNING: (SETTINGS::getGoal): Value out of range.");return(NULL);
1018c6724
< < 	program[ip].successType = type;
---
> < 	return(loadedGoal[start.getPlayerRace(player)][goal]);
1021c6727
< < inline void ANARACE::setProgramSuccessUnit(const unsigned int ip, const unsigned int unit_type)
---
> < inline const START_CONDITION* SETTINGS::getStartcondition(const unsigned int player, const unsigned int startconditionNumber) const
1024,1028c6730,6731
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value ip out of range.");return;
< < 	}
< < 	if(unit_type >= UNIT_TYPE_COUNT) {
< < 		toLog("DEBUG: (ANARACE::setProgramSuccessUnit): Value unit_type out of range.");return;
---
> < 	if(startconditionNumber>=loadedStartcondition[start.getPlayerRace(player)].size()) {
> < 		toLog("WARNING: (SETTINGS::getStartcondition): Value out of range.");return(NULL);
1031c6734
< < 	program[ip].successUnit = unit_type;
---
> < 	return(loadedStartcondition[start.getPlayerRace(player)][startconditionNumber]);
1034,1035c6737,6840
< < // ------ STATISTICS GET FUNCTIONS ------
< < inline const unsigned int ANARACE::getIPStatisticsNeedSupply(const unsigned int ip) const
---
> Files ./settings.o and /home/claw/work/sc1063b/sc/core/settings.o differ
> diff ./soup.cpp /home/claw/work/sc1063b/sc/core/soup.cpp
> 10,11c10,13
> < 	memset(player, 0, MAX_PROGRAMS * sizeof(RACE*));
> < 	memset(anaplayer, 0, MAX_PLAYER * sizeof(ANARACE*));
> ---
> > 	for(int i=MAX_PROGRAMS;i--;)
> > 		player[i]=NULL;
> > 	for(int i=MAX_PLAYER;i--;)
> > 		anaplayer[i]=NULL;
> 13a16
> > //	gaInitialized=0;
> 55a59,61
> > 
> > 
> > 	
> 72c78,82
> < 	*/
> ---
> > 	if(!gaInitialized)
> > 	{
> > 		toLog("ERROR: (SOUP::initSoup) GA not initialized.");
> > 		return(0);
> > 	}*/
> 85c95
> < 	int groupSize = MAX_PROGRAMS / mapPlayerNum;
> ---
> > 	int groupSize=MAX_PROGRAMS/mapPlayerNum;
> 90c100
> < 	for(k = mapPlayerNum; k--;)
> ---
> > 	for(k=mapPlayerNum;k--;)
> 92c102
> < 		for(int i = groupSize; i--;)
> ---
> > 		for(int i=groupSize;i--;)
> 109c119
> < 			anaplayer[k] = new ANARACE();
> ---
> > 			anaplayer[k]=new ANARACE();
> 113c123
> < 	for(k = mapPlayerNum; k < MAX_PLAYER; k++)
> ---
> > 	for(k=mapPlayerNum;k<MAX_PLAYER;k++)
> 116c126
> < 		anaplayer[k] = NULL;
> ---
> > 		anaplayer[k]=NULL;
> 133a144
> > 			anaplayer[k]->setMaxtFitness(0);
> 140d150
> < 
> 142,145c152,156
> <         bool operator()(RACE* const& playerStart, RACE* const& playerEnd) {
> <                 return ((playerStart->getpFitness()>playerEnd->getpFitness())||((playerStart->getpFitness()==playerEnd->getpFitness())&&(playerStart->getsFitness() > playerEnd->getsFitness()))||
> <                            ((playerStart->getpFitness()==playerEnd->getpFitness())&&(playerStart->getsFitness() == playerEnd->getsFitness())&&(playerStart->gettFitness()>playerEnd->gettFitness())) );
> <         }
> ---
> > 	bool operator()(RACE* const& playerStart, RACE* const& playerEnd) {
> > 		return ((playerStart->getpFitness()>playerEnd->getpFitness())||
> > 			   ((playerStart->getpFitness()==playerEnd->getpFitness())&&(playerStart->getsFitness() > playerEnd->getsFitness()))||
> > 			   ((playerStart->getpFitness()==playerEnd->getpFitness())&&(playerStart->getsFitness() == playerEnd->getsFitness())&&(playerStart->gettFitness()>playerEnd->gettFitness())) );
> > 	}
> 152c163
> < 	for(unsigned int k = mapPlayerNum; k--;)
> ---
> > 	for(int k=mapPlayerNum;k--;)
> 163,164c174,175
> < 		complete = true;
> < 		for(unsigned int k = mapPlayerNum; k--;)
> ---
> > 		complete=true;
> > 		for(int k=mapPlayerNum;k--;)
> 186c197,201
> < 	*/
> ---
> > 	if(!gaInitialized)
> > 	{
> > 		toLog("ERROR: (SOUP::newGeneration) GA not initialized.");
> > 		return(0);
> > 	}*/
> 215c230
> < 	for(unsigned int i=groupSize;i--;)
> ---
> > 	for(int i=groupSize;i--;)
> 221c236
> < 		for(unsigned int k = mapPlayerNum; k--;)
> ---
> > 		for(int k=mapPlayerNum;k--;)
> 257,260c272,274
> <                                 if((player[k*groupSize+l]->getpFitness()*1.1<player[k*groupSize]->getpFitness())||
> <                                           ((player[k*groupSize+l]->getpFitness()==player[k*groupSize]->getpFitness())&&(player[k*groupSize+l]->getsFitness()*1.1<player[k*groupSize]->getsFitness()))||
> <                                           ((player[k*groupSize+l]->getpFitness()==player[k*groupSize]->getpFitness())&&(player[k*groupSize+l]->getsFitness()==player[k*groupSize]->getsFitness())&&(player[k*groupSize+l]->gettFitness()*1.1<player[k*groupSize]->gettFitness())) )
> < 					player[k*groupSize+l]->copyCode(*player[k*groupSize]);
> ---
> > 				if((player[k*groupSize+l]->getpFitness()*1.1<player[k*groupSize]->getpFitness())||
> > 					  ((player[k*groupSize+l]->getpFitness()==player[k*groupSize]->getpFitness())&&(player[k*groupSize+l]->getsFitness()*1.1<player[k*groupSize]->getsFitness()))||
> > 					  ((player[k*groupSize+l]->getpFitness()==player[k*groupSize]->getpFitness())&&(player[k*groupSize+l]->getsFitness()==player[k*groupSize]->getsFitness())&&(player[k*groupSize+l]->gettFitness()*1.1<player[k*groupSize]->gettFitness())) )
> 261a276
> > 				player[k*groupSize+l]->copyCode(*player[k*groupSize]);
> 274,313c289,328
> < 		newcalc = false;
> <                 for(int k=mapPlayerNum;k--;)
> <                         if(anaplayer[k]->isActive())
1037,1039c6842,6857
< < #ifdef _SCC_DEBUG
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Value ip out of range.");return(0);
---
> <                                 if((player[k*groupSize]->getpFitness()>anaplayer[k]->getMaxpFitness())||
> < 
> <                                   ((player[k*groupSize]->getpFitness()>=anaplayer[k]->getMaxpFitness())
> <                                  &&(player[k*groupSize]->getsFitness()>anaplayer[k]->getMaxsFitness()))||
> < 
> <                                   ((player[k*groupSize]->getpFitness()>=anaplayer[k]->getMaxpFitness())
> <                                  &&(player[k*groupSize]->getsFitness()>=anaplayer[k]->getMaxsFitness())
> <                                  &&(player[k*groupSize]->gettFitness()>anaplayer[k]->getMaxtFitness())))
> <                                 {
> < 
> <                                         if(player[k*groupSize]->gettFitness()>anaplayer[k]->getMaxtFitness())
> <                                                 anaplayer[k]->setMaxtFitness(player[k*groupSize]->gettFitness());
> <                                         if(player[k*groupSize]->getsFitness()>anaplayer[k]->getMaxsFitness())
> <                                         {
> <                                                 anaplayer[k]->setMaxsFitness(player[k*groupSize]->getsFitness());
> <                                                 anaplayer[k]->setMaxtFitness(player[k*groupSize]->gettFitness());
1041,1042c6859,6863
< < 	if(ipStatistics[ip].needSupply > 10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::getIPStatisticsNeedSupply): Variable ipStatistics.needSupply not initialized.");	return(0);
---
> <                                         if(player[k*groupSize]->getpFitness()>anaplayer[k]->getMaxpFitness())
> <                                         {
> <                                                 anaplayer[k]->setMaxpFitness(player[k*groupSize]->getpFitness());
> <                                                 anaplayer[k]->setMaxsFitness(player[k*groupSize]->getsFitness());
> <                                                 anaplayer[k]->setMaxtFitness(player[k*groupSize]->gettFitness());
1044,1045c6865,6875
< < #endif
< < 	return(ipStatistics[ip].needSupply);
---
> <                                         anaplayer[k]->setUnchangedGenerations(0);
> <                                         newcalc = true;
> <                                         anaplayer[k]->copyCode(*player[k*groupSize]);
> < /*                                      for(int i=MAX_LENGTH;i--;)
> <                                         {
> <         // assign the 'best of breed' to anaplayer
> <                                                 anaplayer[k]->Code[i]=player[k*groupSize]->Code[i];
> <                                                 anaplayer[k]->Marker[i]=player[k*groupSize]->Marker[i];
> <                                         //memcpy(anaplayer[j]->Code[0],player[j*MAX_PROGRAMS/2]->Code[0],MAX_LENGTH*4);
> <                                         //memcpy(anaplayer[j]->Code[1],player[j*MAX_PROGRAMS/2]->Code[1],MAX_LENGTH*4);
> <                                         }*/
1047,1048c6877,6956
< < 
< < inline const unsigned int ANARACE::getIPStatisticsHaveSupply(const unsigned int ip) const
---
> <                         }
> ---
> > 		newcalc=0;
> > 		for(int k=mapPlayerNum;k--;)
> > 			if(anaplayer[k]->isActive())
> > 			{
> > 				if((player[k*groupSize]->getpFitness()>anaplayer[k]->getMaxpFitness())||
> > 
> > 				  ((player[k*groupSize]->getpFitness()>=anaplayer[k]->getMaxpFitness())
> > 				 &&(player[k*groupSize]->getsFitness()>anaplayer[k]->getMaxsFitness()))||
> > 
> > 				  ((player[k*groupSize]->getpFitness()>=anaplayer[k]->getMaxpFitness())
> > 				 &&(player[k*groupSize]->getsFitness()>=anaplayer[k]->getMaxsFitness())
> > 				 &&(player[k*groupSize]->gettFitness()>anaplayer[k]->getMaxtFitness())))
> > 				{
> > 
> > 					if(player[k*groupSize]->gettFitness()>anaplayer[k]->getMaxtFitness())
> > 						anaplayer[k]->setMaxtFitness(player[k*groupSize]->gettFitness());
> > 					if(player[k*groupSize]->getsFitness()>anaplayer[k]->getMaxsFitness())
> > 					{
> > 						anaplayer[k]->setMaxsFitness(player[k*groupSize]->getsFitness());
> > 						anaplayer[k]->setMaxtFitness(player[k*groupSize]->gettFitness());
> > 					}
> > 					if(player[k*groupSize]->getpFitness()>anaplayer[k]->getMaxpFitness())
> > 					{
> > 						anaplayer[k]->setMaxpFitness(player[k*groupSize]->getpFitness());
> > 						anaplayer[k]->setMaxsFitness(player[k*groupSize]->getsFitness());
> > 						anaplayer[k]->setMaxtFitness(player[k*groupSize]->gettFitness());
> > 					}
> > 					anaplayer[k]->setUnchangedGenerations(0);
> > 					newcalc=1;
> > 					anaplayer[k]->copyCode(*player[k*groupSize]);
> > /*					for(int i=MAX_LENGTH;i--;)
> > 					{
> > 	// assign the 'best of breed' to anaplayer
> > 						anaplayer[k]->Code[i]=player[k*groupSize]->Code[i];
> > 						anaplayer[k]->Marker[i]=player[k*groupSize]->Marker[i];
> > 					//memcpy(anaplayer[j]->Code[0],player[j*MAX_PROGRAMS/2]->Code[0],MAX_LENGTH*4);
> > 					//memcpy(anaplayer[j]->Code[1],player[j*MAX_PROGRAMS/2]->Code[1],MAX_LENGTH*4);
> > 					}*/
> > 				}
> > 			}
> 329c344,345
> < 						  ((player[j]->getpFitness()==player[l]->getpFitness())&&(player[j]->getsFitness()>player[l]->getsFitness()))))
> ---
> > 						  ((player[j]->getpFitness()==player[l]->getpFitness())&&(player[j]->getsFitness()>player[l]->getsFitness()))||
> > 						  ((player[j]->getpFitness()==player[l]->getpFitness())&&(player[j]->getsFitness()==player[l]->getsFitness())&&(player[j]->gettFitness()>player[l]->gettFitness())) )
> 368,369c384,385
> < 				unsigned int z = anaplayer[k]->fitnessAverage-player[i]->getpFitness();
> < 				anaplayer[k]->fitnessVariance += (z*z);
> ---
> > 				int z=anaplayer[k]->fitnessAverage-player[i]->getpFitness();
> > 				anaplayer[k]->fitnessVariance+=(z*z);
> 417a434
> > 			s[k]->setMaxtFitness(anaplayer[k]->getMaxtFitness());
> 467c484
> < 		isNewRun = false;
> ---
> > 		isNewRun=false;
> 470a488,499
> > 			
> > 
> > 
> > void SOUP::setMapPlayerNum(const unsigned int map_player_num)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((map_player_num<1)||(map_player_num>=MAX_PLAYER)) {
> > 		toLog("DEBUG: (SOUP::setMapPlayerNum): map_player_num not initialized.");return;
> > 	}
> > #endif
> > 	mapPlayerNum = map_player_num;
> > }
> 478a508,509
> > //	gaInitialized=1;
> > 	ANARACE::resetStaticData();
> 482d512
> < 	ANARACE::resetStaticData();
> diff ./soup.hpp /home/claw/work/sc1063b/sc/core/soup.hpp
> 42,51d41
> < inline void SOUP::setMapPlayerNum(const unsigned int map_player_num)
1051,1055c6959,6960
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Value ip out of range.");return(0);
< <     }
< < 	if(ipStatistics[ip].haveSupply > 10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveSupply): Variable ipStatistics.haveSupply not initialized.");return(0);
---
> < 	if((map_player_num < 1) || (map_player_num >= MAX_PLAYER)) {
> < 		toLog("DEBUG: (SOUP::setMapPlayerNum): map_player_num not initialized.");return;
1058c6963
< < 	return(ipStatistics[ip].haveSupply);
---
> < 	mapPlayerNum = map_player_num;
1061c6966,7206
< < inline const unsigned int ANARACE::getIPStatisticsHaveMinerals(const unsigned int ip) const
---
> Files ./soup.o and /home/claw/work/sc1063b/sc/core/soup.o differ
> diff ./startcondition.cpp /home/claw/work/sc1063b/sc/core/startcondition.cpp
> 18,24c18,24
> < 	race(object.race),
> < 	name(object.name),
> < 	haveSupply(object.haveSupply),
> < 	needSupply(object.needSupply),
> < 	minerals(object.minerals),
> < 	gas(object.gas),
> < 	startTime(object.startTime)
> ---
> >     race(object.race),
> >     name(object.name),
> >     haveSupply(object.haveSupply),
> >     needSupply(object.needSupply),
> >     minerals(object.minerals),
> >     gas(object.gas),
> >     startTime(object.startTime)
> 26c26
> < 	for(int i = MAX_LOCATIONS; i--;)
> ---
> > 	for(int i = MAX_LOCATIONS;i--;)
> 32,39c32,39
> < 	race = object.race;
> < 	name = object.name;
> < 	haveSupply = object.haveSupply;
> < 	needSupply = object.needSupply;
> < 	minerals = object.minerals;
> < 	gas = object.gas;
> < 	startTime = object.startTime;
> < 	for(int i = MAX_LOCATIONS; i--;)
> ---
> >     race = object.race;
> >     name = object.name;
> >     haveSupply = object.haveSupply;
> >     needSupply = object.needSupply;
> >     minerals = object.minerals;
> >     gas = object.gas;
> >     startTime = object.startTime;
> > 	for(int i = MAX_LOCATIONS;i--;)
> 46,47c46,47
> < 	unsigned int need_supply = 0;
> < 	unsigned int have_supply = 0;
> ---
> > 	unsigned int need_supply=0;
> > 	unsigned int have_supply=0;
> 61a62,244
> > void START_CONDITION::assignRace(const eRace start_race)
> > {
> > 	race = start_race;
> > }
> > 			
> > const eRace START_CONDITION::getRace() const
> > {
> > 	return(race);
> > }
> > 
> > const UNIT* START_CONDITION::getUnit(const unsigned int location) const 
> > {
> > #ifdef _SCC_DEBUG
> > 	if(location >= MAX_LOCATIONS) {
> > 		toLog("DEBUG: (START_CONDITION::getUnit): Value location out of range.");return(0);
> > 	} 
> > #endif
> > 	return(&unit[location]);
> > }
> > 
> > const std::string& START_CONDITION::getName() const
> > {
> > 	return(name);
> > }
> > 
> > void START_CONDITION::setName(const std::string& startcondition_name)
> > {
> > 	name = startcondition_name;
> > }
> > 
> > const unsigned int START_CONDITION::getHaveSupply() const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(haveSupply > MAX_SUPPLY) {
> > 		toLog("DEBUG: (START_CONDITION::getHaveSupply): Value haveSupply out of range.");return(0);
> > 	}
> > #endif
> > 	return(haveSupply);
> > }
> > 
> > void START_CONDITION::setHaveSupply(const unsigned int start_have_supply)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(start_have_supply > MAX_SUPPLY) {
> > 		toLog("DEBUG: (START_CONDITION::setHaveSupply): Value start_have_supply out of range.");return;
> > 	}
> > #endif
> > 	haveSupply = start_have_supply;
> > }
> > 		
> > const unsigned int START_CONDITION::getNeedSupply() const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(needSupply > MAX_SUPPLY) { // TODO
> > 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value needSupply out of range.");return(0);
> > 	}
> > #endif
> > 	return(needSupply);
> > }
> > 
> > void START_CONDITION::setNeedSupply(const unsigned int start_need_supply)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(start_need_supply > MAX_SUPPLY) {
> > 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value start_need_supply out of range.");return;
> > 	}
> > #endif
> > 	needSupply = start_need_supply;
> > }
> > 
> > const unsigned int START_CONDITION::getGas() const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(gas > MAX_GAS) {
> > 		toLog("DEBUG: (START_CONDITION::getGas): Variable gas out of range.");return(0);
> > 	}
> > #endif
> > 	return(gas);
> > }
> > 
> > const unsigned int START_CONDITION::getMinerals() const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(minerals > MAX_MINERALS)
> > 	{
> > 		toLog("DEBUG: (START_CONDITION::getMinerals): Variable minerals out of range.");
> > 		return(0);
> > 	}
> > #endif
> > 	return(minerals);
> > }
> > 	
> > void START_CONDITION::setMinerals(const unsigned int start_minerals)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(start_minerals > MAX_MINERALS) {
> > 		toLog("DEBUG: (START_CONDITION::setMinerals): Value start_minerals out of range.");return;
> > 	}
> > #endif
> > 	minerals = start_minerals;
> > }
> > 
> > void START_CONDITION::setGas(const unsigned int start_gas)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(start_gas > MAX_GAS) {
> > 		toLog("DEBUG: (START_CONDITION::setGas): Value start_gas out of range.");return;
> > 	}
> > #endif
> > 	gas = start_gas;	
> > }
> > 
> > const unsigned int START_CONDITION::getStartTime() const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(startTime >= MAX_TIME) { // TODO was wenn im Nachhinein settings.maxtime veraendert wird? 
> > 		toLog("DEBUG: (START_CONDITION::getStartTime): Variable startTime out of range.");return(0);
> > 	}
> > #endif
> > 	return(startTime);
> > }
> > 
> > void START_CONDITION::setStartTime(const unsigned int start_time)
> > {
> > #ifdef _SCC_DEBUG
> > 	if(start_time >= MAX_TIME) {
> > 		toLog("DEBUG: (START_CONDITION::setStartTime): Value start_time out of range.");return;
> > 	}
> > #endif
> > 	startTime = start_time;
> > }
> > 
> > void START_CONDITION::setLocationAvailible(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((location == 0) || (location >= MAX_LOCATIONS)) {
> > 		toLog("DEBUG: (START_CONDITION::setLocationAvailible): Value location out of range.");return;
> > 	}
> > #endif
> > 	unit[location].setAvailible(unit_type, unit_count);
> > 	unit[GLOBAL].addAvailible(unit_type, unit_count);
> > 	// TODO UNSAUBER!
> > }
> > 
> > const unsigned int START_CONDITION::getLocationAvailible(const unsigned int location, const unsigned int unit_type) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(location >= MAX_LOCATIONS) {
> > 		toLog("DEBUG: (START_CONDITION::getLocationAvailible): Value location out of range.");return(0);
> > 	}
> > #endif
> > 	return(unit[location].getAvailible(unit_type));
> > }
> > 
> > const unsigned int START_CONDITION::getLocationTotal(const unsigned int location, const unsigned int unit_type) const
> > {
> > #ifdef _SCC_DEBUG
> > 	if(location >= MAX_LOCATIONS) {
> > 		toLog("DEBUG: (START_CONDITION::getLocationTotal): Value location out of range.");return(0);
> > 	}
> > #endif
> > 	return(unit[location].getTotal(unit_type));
> > }
> > 
> > 
> > void START_CONDITION::setLocationTotal(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
> > {
> > #ifdef _SCC_DEBUG
> > 	if((location == 0)||(location >= MAX_LOCATIONS)) {
> > 		toLog("DEBUG: (START_CONDITION::setLocationTotal): Value location out of range.");return;
> > 	}
> > #endif
> > 	unit[location].setTotal(unit_type, unit_count);
> > 	unit[GLOBAL].addTotal(unit_type, unit_count);
> > 	// TODO UNSAUBER!
> > }
> > 
> > 
> > void START_CONDITION::resetUnits()
> > {
> > 	for(int i=MAX_LOCATIONS;i--;)
> > 		unit[i].resetData();
> > }
> diff ./startcondition.hpp /home/claw/work/sc1063b/sc/core/startcondition.hpp
> 59,239d58
> < inline void START_CONDITION::assignRace(const eRace start_race) {
> < 	race = start_race;
> < }
> < 			
> < inline const eRace START_CONDITION::getRace() const {
> < 	return(race);
> < }
> < 
> < inline const UNIT* START_CONDITION::getUnit(const unsigned int location) const 
1064,1068c7209,7210
< <     if((ip >= 2*MAX_LENGTH)) {
< < 	        toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Value ip out of range.");return(0);
< < 	}
< < 	if(ipStatistics[ip].minerals > MAX_MINERALS) {
< < 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveMinerals): Variable ipStatistics.minerals not initialized.");return(0);
---
> < 	if(location >= MAX_LOCATIONS) { // TODO
> < 		toLog("DEBUG: (START_CONDITION::getUnit): Value location out of range.");return(0);
1071c7213
< < 	return(ipStatistics[ip].minerals);
---
> < 	return(&unit[location]);
1074c7216,7224
< < inline const unsigned int ANARACE::getIPStatisticsHaveGas(const unsigned int ip) const
---
> < inline const std::string& START_CONDITION::getName() const {
> < 	return(name);
> < }
> < 
> < inline void START_CONDITION::setName(const std::string& startcondition_name) {
> < 	name = startcondition_name;
> < }
> < 
> < inline const unsigned int START_CONDITION::getHaveSupply() const 
1077,1081c7227,7228
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Value ip out of range.");return(0);
< <     }
< < 	if(ipStatistics[ip].gas > MAX_GAS) {
< < 		toLog("DEBUG: (ANARACE::getIPStatisticsHaveGas): Variable ipStatistics.gas not initialized.");return(0);
---
> < 	if(haveSupply > MAX_SUPPLY) {
> < 		toLog("DEBUG: (START_CONDITION::getHaveSupply): Value haveSupply out of range.");return(0);
1084c7231
< < 	return(ipStatistics[ip].gas);
---
> < 	return(haveSupply);
1087c7234
< < inline const unsigned int ANARACE::getIPStatisticsFitness(const unsigned int ip) const
---
> < inline void START_CONDITION::setHaveSupply(const unsigned int start_have_supply) 
1090,1095c7237,7238
< <     if((ip >= 2*MAX_LENGTH)) {
< <         toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Value ip out of range.");return(0);
< <     }
< < 	// TODO max pfitness 
< < 	if(ipStatistics[ip].fitness>MAX_PFITNESS) {
< < 		toLog("DEBUG: (ANARACE::getIPStatisticsFitness): Variable ipStatistics.fitness not initialized.");return(0);
---
> < 	if(start_have_supply > MAX_SUPPLY) {
> < 		toLog("DEBUG: (START_CONDITION::setHaveSupply): Value start_have_supply out of range.");return;
1098c7241
< < 	return(ipStatistics[ip].fitness);
---
> < 	haveSupply = start_have_supply;
1101,1102c7244
< < 
< < inline const unsigned int ANARACE::getTimeStatisticsNeedSupply(const unsigned int time) const
---
> < inline const unsigned int START_CONDITION::getNeedSupply() const
1105,1109c7247,7248
< <     if((time>=MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Value time out of range.");return(0);
< <     }
< < 	if(timeStatistics[time].needSupply>10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsNeedSupply): Variable timeStatistics.needSupply not initialized.");return(0);
---
> < 	if(needSupply > MAX_SUPPLY) { // TODO
> < 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value needSupply out of range.");return(0);
1112c7251
< < 	return(timeStatistics[time].needSupply);
---
> < 	return(needSupply);
1115c7254
< < inline const unsigned int ANARACE::getTimeStatisticsHaveSupply(const unsigned int time) const
---
> < inline void START_CONDITION::setNeedSupply(const unsigned int start_need_supply)
1118,1122c7257,7258
< <     if((time>=MAX_TIME)) {
< <         toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Value time out of range.");return(0);
< <     }
< < 	if(timeStatistics[time].haveSupply>10*MAX_SUPPLY) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveSupply): Variable timeStatistics.haveSupply not initialized.");return(0);
---
> < 	if(start_need_supply > MAX_SUPPLY) {
> < 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value start_need_supply out of range.");return;
1125c7261
< < 	return(timeStatistics[time].haveSupply);
---
> < 	needSupply = start_need_supply;
1128c7264
< < inline const unsigned int ANARACE::getTimeStatisticsHaveMinerals(const unsigned int time) const
---
> < inline const unsigned int START_CONDITION::getGas() const
1131,1135c7267,7268
< <     if((time>=MAX_TIME)) {
< < 	        toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Value time out of range.");return(0);
< < 	}
< < 	if(timeStatistics[time].minerals>MAX_MINERALS) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveMinerals): Variable timeStatistics.minerals not initialized.");return(0);
---
> < 	if(gas > MAX_GAS) {
> < 		toLog("DEBUG: (START_CONDITION::getGas): Variable gas out of range.");return(0);
1138c7271
< < 	return(timeStatistics[time].minerals);
---
> < 	return(gas);
1140c7273,7274
< < inline const unsigned int ANARACE::getTimeStatisticsHaveGas(const unsigned int time) const
---
> < 
> < inline const unsigned int START_CONDITION::getMinerals() const
1143,1147c7277,7280
< < 	if((time>=MAX_TIME)) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Value time out of range.");return(0);
< < 	}
< < 	if(timeStatistics[time].gas>MAX_GAS) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsHaveGas): Variable timeStatistics.gas not initialized.");return(0);
---
> < 	if(minerals > MAX_MINERALS)
> < 	{
> < 		toLog("DEBUG: (START_CONDITION::getMinerals): Variable minerals out of range.");
> < 		return(0);
1150c7283
< < 	return(timeStatistics[time].gas);
---
> < 	return(minerals);
1153c7286
< < inline const unsigned int ANARACE::getTimeStatisticsFitness(const unsigned int time) const
---
> < inline void START_CONDITION::setMinerals(const unsigned int start_minerals)
1156,1161c7289,7290
< < 	if((time>=MAX_TIME)) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Value time out of range.");return(0);
< < 	}
< < 	// TODO max pfitness 
< < 	if(timeStatistics[time].fitness>MAX_PFITNESS) {
< < 		toLog("DEBUG: (ANARACE::getTimeStatisticsFitness): Variable timeStatistics.fitness not initialized.");return(0);
---
> < 	if(start_minerals > MAX_MINERALS) {
> < 		toLog("DEBUG: (START_CONDITION::setMinerals): Value start_minerals out of range.");return;
1164c7293
< < 	return(timeStatistics[time].fitness);
---
> < 	minerals = start_minerals;
1166,1167c7295,7296
< 742,800c191
< < inline const bool ANARACE::getProgramIsBuilt(const unsigned int ip) const
---
> < 
> < inline void START_CONDITION::setGas(const unsigned int start_gas)
1170,1171c7299,7300
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramIsBuilt): Value ip out of range.");return(0);
---
> < 	if(start_gas > MAX_GAS) {
> < 		toLog("DEBUG: (START_CONDITION::setGas): Value start_gas out of range.");return;
1174c7303
< < 	return(program[ip].built);
---
> < 	gas = start_gas;	
1177,1178c7306
< < 
< < /*const bool ANARACE::getProgramIsConstant(const unsigned int ip)
---
> < inline const unsigned int START_CONDITION::getStartTime() const
1180,1181c7308,7313
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramIsConstant): Value ip [%i] out of range.",IP);return(false);
---
> < #ifdef _SCC_DEBUG
> < 	if(startTime >= MAX_TIME) { // TODO was wenn im Nachhinein settings.maxtime veraendert wird? 
> < 		toLog("DEBUG: (START_CONDITION::getStartTime): Variable startTime out of range.");return(0);
> < 	}
> < #endif
> < 	return(startTime);
1183,1184d7314
< < 	return(program[ip].isConstant);
< < };*/
1186,1187c7316
< < // first program time is
< < inline const unsigned int ANARACE::getProgramTime(const unsigned int ip) const
---
> < inline void START_CONDITION::setStartTime(const unsigned int start_time)
1190,1194c7319,7320
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramTime): Value ip out of range.");return(0);
< < 	}
< < 	if(program[ip].time > configuration.getMaxTime()) {
< < 		toLog("DEBUG: (ANARACE::getProgramTime): Variable not initialized.");return(0);
---
> < 	if(start_time >= MAX_TIME) {
> < 		toLog("DEBUG: (START_CONDITION::setStartTime): Value start_time out of range.");return;
1197c7323
< < 	return(program[ip].time);
---
> < 	startTime = start_time;
1200c7326
< < inline const unsigned int ANARACE::getRealProgramTime(const unsigned int ip) const
---
> < inline void START_CONDITION::setLocationAvailible(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
1203,1204c7329,7330
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
---
> < 	if((location == 0) || (location >= MAX_LOCATIONS)) {
> < 		toLog("DEBUG: (START_CONDITION::setLocationAvailible): Value location out of range.");return;
1207c7333,7335
< < 	return(configuration.getMaxTime() - getProgramTime(ip));
---
> < 	unit[location].setAvailible(unit_type, unit_count);
> < 	unit[GLOBAL].addAvailible(unit_type, unit_count);
> < 	// TODO UNSAUBER!
1210,1211c7338
< < 
< < inline const unsigned int ANARACE::getProgramLocation(const unsigned int ip) const
---
> < inline const unsigned int START_CONDITION::getLocationAvailible(const unsigned int location, const unsigned int unit_type) const
1214,1218c7341,7342
< < 	if((ip >= MAX_LENGTH)) {
< < 		toLog("DEBUG: (ANARACE::getProgramLocation): Value ip out of range.");return(0);
< < 	}
< < 	if(program[ip].location > MAX_LOCATIONS) {
< < 		toLog("DEBUG: (ANARACE::getProgramLocation): Variable program.location not initialized.");return(0);
---
> < 	if(location >= MAX_LOCATIONS) {
> < 		toLog("DEBUG: (START_CONDITION::getLocationAvailible): Value location out of range.");return(0);
1221c7345
< < 	return(program[ip].location);
---
> < 	return(unit[location].getAvailible(unit_type));
1224,1242c7348
< < inline const unsigned int ANARACE::getTimePercentage() const
< < {
< ---
< > inline const unsigned int ANARACE::getTimePercentage() const {
< 804,805c195
< < inline const unsigned int ANARACE::getFastestGoalTime() const
< < {
< ---
< > inline const unsigned int ANARACE::getFastestGoalTime() const {
< 808,809c198,199
< < inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const
< < {
< ---
< > 
< > inline const GOAL_TREE ANARACE::getGoalTree(const unsigned int currentGoalUnit) const {
< 913a304
< > 
< 934,935c325
< < inline void ANARACE::setTotalGeneration(const unsigned int total_generation)
---
> < inline const unsigned int START_CONDITION::getLocationTotal(const unsigned int location, const unsigned int unit_type) const
1244,1340c7350,7352
< ---
< > inline void ANARACE::setTotalGeneration(const unsigned int total_generation) {
< 969d358
< < //int getProgramSuccessType(int IP);
< Files ./anarace.o and /home/claw/work/sc1064/sc/core/anarace.o differ
< diff -b -w -d ./basicmap.cpp /home/claw/work/sc1064/sc/core/basicmap.cpp
< 1a2
< > #include <iostream>
< 24a26,43
< > unsigned int BASIC_MAP::calculateDistance(unsigned int i, unsigned int j)
< > {
< > 	if(i==j)
< > 		return(0);
< > 	if(location[i].getDistance(j) < 9999)
< > 		return(location[i].getDistance(j));
< > 	unsigned int min = 9999;
< > 	for(unsigned int k=1;k<getMaxLocations();k++)
< > 		if(location[i].getDistance(k) < 9999)
< > 		{
< > 			unsigned int temp = location[i].getDistance(k) + calculateDistance(j, k);
< > 			if(temp < min)
< > 				min = temp;
< > 		}
< > 	return(min);	
< > }
< > 
< > 
< 27c46,71
< < 	for(int i=1;i<MAX_LOCATIONS;i++)
< ---
< > 	for(unsigned int i=1;i<getMaxLocations();i++)
< > 		for(unsigned int j=1;j<getMaxLocations();j++)
< > 			if(location[i].getDistance(j) < 9999)
< > 				location[j].setDistance(i, location[i].getDistance(j));
< > 
< > 	for(unsigned int i = 1; i < getMaxLocations(); i++)
< > 	{
< > 		std::cout << "Location " << i << " ";
< > 		for(unsigned int j = 1; j < getMaxLocations(); j++)
< > 			std::cout << getLocation(i)->getDistance(j) << " ";
< > 		std::cout << std::endl;
< > 	}
< > 				
< > 	for(unsigned int i=1;i<getMaxLocations();i++)
< > 		for(unsigned int j=1;j<getMaxLocations();j++)
< > 			location[i].setDistance(j, calculateDistance(i, j));
< > 
< > 	for(unsigned int i = 1; i < getMaxLocations(); i++)
< > 	{
< > 		std::cout << "Location " << i << " ";
< > 		for(unsigned int j = 1; j < getMaxLocations(); j++)
< > 			std::cout << getLocation(i)->getDistance(j) << " ";
< > 		std::cout << std::endl;
< > 	}
< > 
< > 	for(unsigned int i=1;i<getMaxLocations();i++)
< diff -b -w -d ./basicmap.hpp /home/claw/work/sc1064/sc/core/basicmap.hpp
< 16a17
< > 		unsigned int calculateDistance(unsigned int i, unsigned int j);
< 35c36
< < 		void setLocationDistance(const unsigned int location_number, std::list<std::string> distances);// needs never be changed so a list is fine
< ---
< > 		void setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance);
< 74c75
< < 	if((location_number >= MAX_LOCATIONS)) {
< ---
< > 	if((location_number >= maxLocations)) {
< 84c85
< < 	if((location_number >= MAX_LOCATIONS)) {
< ---
< > 	if((location_number >= maxLocations)) {
< 94c95
< < 	if((location_number >= MAX_LOCATIONS)) {
< ---
< > 	if((location_number >= maxLocations)) {
< 104c105
< < 	if((location_number >= MAX_LOCATIONS)) {
< ---
< > 	if((location_number >= maxLocations)) {
< 114c115
< < 	if((location_number >= MAX_LOCATIONS)) {
< ---
< > 	if((location_number >= maxLocations)) {
< 124c125
< < 	if((location_number >= MAX_LOCATIONS)) {
< ---
< > 	if((location_number >= maxLocations)) {
< 131c132
< < inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const std::list<std::string> distances)
< ---
< > inline void BASIC_MAP::setLocationDistance(const unsigned int location_number, const unsigned int target, const unsigned int distance)
< 134,147c135,136
< < 	if((location_number >= MAX_LOCATIONS)) {
< < 		toLog("DEBUG: (MAP::setLocationDistance): Value out of range.");return;
< < 	}
< < 	if(location_number >= distances.size()) {
< < 		toLog("DEBUG: (MAP::setLocationDistance): Too many locations.");return;
---
> < #ifdef _SCC_DEBUG
> < 	if(location >= MAX_LOCATIONS) { // TODO
> < 		toLog("DEBUG: (START_CONDITION::getLocationTotal): Value location out of range.");return(0);
1343,1345c7355,7359
< < 	std::list<std::string>::const_iterator i=distances.begin();
< < 	unsigned int j=0;
< < 	while(i!=distances.end())
---
> < 	return(unit[location].getTotal(unit_type));
> < }
> < 
> < 
> < inline void START_CONDITION::setLocationTotal(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
1347,1353d7360
< < 		location[location_number].setDistance(j, atoi(i->c_str()));
< < 		i++;
< < 		j++;
< ---
< > 	if((location_number >= maxLocations)) {
< > 		toLog("DEBUG: (MAP::setLocationDistance): Value location_number out of range.");return;
< 149,151c138,139
1355,1373c7362,7369
< < 	if( j < location_number ) {
< < 		toLog("DEBUG: (MAP::setLocationDistance): Not enough locations.");return;
< ---
< > 	if((target >= maxLocations)) {
< > 		toLog("DEBUG: (MAP::setLocationDistance): Value target out of range.");return;
< 152a141,144
< > //	if(distance >= 1000) {
< > //		toLog("DEBUG: (MAP::setLocationDistance): Value distance out of range.");return;
< > //	}
< > 	
< 153a146
< > 	location[location_number].setDistance(target, distance);
< 163a157
< > 	MAP_LOCATION::setMaxLocations(max_locations);
< 179c173
< < 	if(location_number >= MAX_LOCATIONS) {
< ---
< > 	if(location_number >= maxLocations) {
< 186,187d179
---
> < 	if((location == 0)||(location >= MAX_LOCATIONS)) { // TODO
> < 		toLog("DEBUG: (START_CONDITION::setLocationTotal): Value location out of range.");return;
> < 	}
> < #endif
> < 	unit[location].setTotal(unit_type, unit_count);
> < 	unit[GLOBAL].addTotal(unit_type, unit_count);
> < 	// TODO UNSAUBER!
> < }
1376,1400c7372,7375
< Files ./basicmap.o and /home/claw/work/sc1064/sc/core/basicmap.o differ
< diff -b -w -d ./building.cpp /home/claw/work/sc1064/sc/core/building.cpp
< 9c9
< < 	IP(0),
< ---
< > //	IP(0),
< 21c21
< < 	IP(object.IP),
< ---
< > //	IP(object.IP),
< 34c34
< < 	IP = object.IP;
< ---
< > //	IP = object.IP;
< diff -b -w -d ./building.hpp /home/claw/work/sc1064/sc/core/building.hpp
< 14c14
< < 	unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
< ---
< > //		unsigned int IP;		  // for back-tracking certain buildings (especially for the 'cancel building' option of zerg)
< 18a19,22
< > 
< > 		Building();
< > 		Building(const Building& object);
< > 		Building& operator=(const Building& object);
< 24,28c28
---
> < inline void START_CONDITION::resetUnits()
> < {
> < 	for(int i=MAX_LOCATIONS;i--;)
> < 		unit[i].resetData();
1402,1404d7376
< < 	Building();
< < 	Building(const Building& object);
< < 	Building& operator=(const Building& object);
1405a7378,7382
> < 
> Files ./startcondition.o and /home/claw/work/sc1063b/sc/core/startcondition.o differ
> diff ./start.cpp /home/claw/work/sc1063b/sc/core/start.cpp
> 8c8
> < 	for(int i = MAX_PLAYER; i--;)
1407,1451c7384,7391
< > 		};
< 38c38
< < 	const unsigned int getIP() const;
< ---
< > //		const unsigned int getIP() const;
< 49c49
< < 	void setIP(const unsigned int building_IP);
< ---
< > //		void setIP(const unsigned int building_IP);
< 107c107
< < inline const unsigned int Building::getIP() const
< ---
< > /*inline const unsigned int Building::getIP() const
< 115c115
< < }
< ---
< > }*/
< 120c120
< < 	if(location > MAX_LOCATIONS) {
< ---
< > 	if(location >= MAX_LOCATIONS) { // TODO
< 197c197
< < inline void Building::setIP(const unsigned int building_IP)
< ---
< > /*inline void Building::setIP(const unsigned int building_IP)
< 205c205
< < }
< ---
< > }*/
< Files ./building.o and /home/claw/work/sc1064/sc/core/building.o differ
< diff -b -w -d ./configuration.hpp /home/claw/work/sc1064/sc/core/configuration.hpp
< 10d9
< < #include <deque>
< Files ./configuration.o and /home/claw/work/sc1064/sc/core/configuration.o differ
< diff -b -w -d ./defs.cpp /home/claw/work/sc1064/sc/core/defs.cpp
< 38c38
< < const std::string CORE_VERSION="Beta 1.62final";
< ---
< > const std::string CORE_VERSION="Beta 1.63a";
< 198,202c198,202
< < {"Move 3 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Move 1 Forward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Move 1 Backward",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
---
> > 	for(int i=MAX_PLAYER;i--;)
> 10,15c10,15
> < 		pCurrentGoal[i] = &(currentGoal[i]);
> < 		startcondition[i] = NULL;
> < 		tmpgoal[i] = NULL;
> < 		startPosition[i] = 0;
> < 		playerRace[i] = TERRA;
> < 		pStats[i] = NULL;
1453,1463c7393,7400
< > {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
< 311,315c311,315
< < {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
---
> > 		pCurrentGoal[i]=&(currentGoal[i]);
> > 		startcondition[i]=NULL;
> > 		tmpgoal[i]=NULL;
> > 		startPosition[i]=0;
> > 		playerRace[i]=TERRA;
> > 		pStats[i]=NULL;
> 35c35
> < 	unsigned int maxp = tmpmap->getMaxPlayer();
1465,1475c7402,7404
< > {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
< 420,424c420,424
< < {"Window move+++",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move+",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move-",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Window move prev",		  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< < {"Move from here",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
---
> > 	int maxp=tmpmap->getMaxPlayer();
> 37c37
> < 	for(int j = tmpmap->getMaxLocations();j--;)
1477,1484c7406,7409
< > {"Build parallel 2",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 4",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 8",			  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Build parallel 16",		  0,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {0, 0, 0}, 0, NO_FACILITY, 0, 0, SPECIAL_UNIT_TYPE, 0},
< > {"Send all Gas to Minerals",			  3,    0,    0,  0, 0, 0, {0, 0}, {0 ,0, 0}, {GAS_SCV, 0, 0}, 0, IS_MORPHING, 0, 0, WORKER_UNIT_TYPE, 0},
< diff -b -w -d ./defs.hpp /home/claw/work/sc1064/sc/core/defs.hpp
< 11c11
< < #define MAX_LOCATIONS 3
---
> > 	for(int j=MAX_LOCATIONS;j--;)
> 48,49c48
> < 		// TODO bei mehreren Spielern!
> < 		for(unsigned int j=1;j<tmpmap->getMaxLocations();j++)
1486,1493c7411,7414
< > #define MAX_LOCATIONS 5
< 200,205c200,206
< < 	MOVE_ONE_3_FORWARD,
< < 	MOVE_ONE_1_FORWARD,
< < 	MOVE_ONE_1_BACKWARD,
< < 	ROTATE, 
< < 	FOLLOW,// 70
< < 	RESET,
---
> > 		for(int j=1;j<MAX_LOCATIONS;j++)
> diff ./start.hpp /home/claw/work/sc1063b/sc/core/start.hpp
> 138c138
> < 	if((start_position < 1) || (start_position >= tmpmap->getMaxLocations())) {
1495,1502c7416,7421
< > 	BUILD_PARALLEL_2,
< > 	BUILD_PARALLEL_4,
< > 	BUILD_PARALLEL_8,
< > 	BUILD_PARALLEL_16,
< > 	
< > 	FROM_GAS_TO_MINERALS,
< > 	LAST_UNIT,// 70
< Files ./defs.o and /home/claw/work/sc1064/sc/core/defs.o differ
---
> > 	if((start_position < 1) || (start_position >= MAX_LOCATIONS)) {
> Files ./start.o and /home/claw/work/sc1063b/sc/core/start.o differ
> Only in ./: statistics.cpp
> Only in ./: statistics.hpp
> Only in ./: statistics.o
> Files ./unit.o and /home/claw/work/sc1063b/sc/core/unit.o differ
diff -b -w -d ./goalentry.cpp /home/claw/work/sc1064/sc/core/goalentry.cpp
26,36c26,34
< 	for(int i=UNIT_TYPE_COUNT;i--;)
< 	{
< 		genoToPhaenotype[i]=object.genoToPhaenotype[i];
< 		phaenoToGenotype[i]=object.phaenoToGenotype[i];
< 		allGoal[i]=object.allGoal[i];
< 		isStatic[i]=object.isStatic[i];
< 		isBuildable[i]=object.isBuildable[i];
< 		isHaveable[i]=object.isHaveable[i];
< 		for(int j=MAX_LOCATIONS;j--;)
< 			globalGoal[j][i]=object.globalGoal[j][i];
< 	}
---
>         memcpy(genoToPhaenotype, object.genoToPhaenotype, UNIT_TYPE_COUNT * sizeof(int));
>         memcpy(phaenoToGenotype, object.phaenoToGenotype, UNIT_TYPE_COUNT * sizeof(int));
>         memcpy(allGoal, object.allGoal, UNIT_TYPE_COUNT * sizeof(int));
> 
>         memcpy(isStatic, object.isStatic, UNIT_TYPE_COUNT * sizeof(bool));
>         memcpy(isBuildable, object.isBuildable, UNIT_TYPE_COUNT * sizeof(bool));
>         memcpy(isHaveable, object.isHaveable, UNIT_TYPE_COUNT * sizeof(bool));
> 
>         memcpy(globalGoal, object.globalGoal, UNIT_TYPE_COUNT * MAX_LOCATIONS * sizeof(int));
52,62c50,59
< 	for(int i=UNIT_TYPE_COUNT;i--;)
< 	{
< 		genoToPhaenotype[i]=object.genoToPhaenotype[i];
< 		phaenoToGenotype[i]=object.phaenoToGenotype[i];
< 		allGoal[i]=object.allGoal[i];
< 		isStatic[i]=object.isStatic[i];
< 		isBuildable[i]=object.isBuildable[i];
< 		isHaveable[i]=object.isHaveable[i];
< 		for(int j=MAX_LOCATIONS;j--;)
< 			globalGoal[j][i]=object.globalGoal[j][i];
< 	}
---
> 	memcpy(genoToPhaenotype, object.genoToPhaenotype, UNIT_TYPE_COUNT * sizeof(int));
> 	memcpy(phaenoToGenotype, object.phaenoToGenotype, UNIT_TYPE_COUNT * sizeof(int));
> 	memcpy(allGoal, object.allGoal, UNIT_TYPE_COUNT * sizeof(int));
> 		
> 	memcpy(isStatic, object.isStatic, UNIT_TYPE_COUNT * sizeof(bool));
> 	memcpy(isBuildable, object.isBuildable, UNIT_TYPE_COUNT * sizeof(bool));
> 	memcpy(isHaveable, object.isHaveable, UNIT_TYPE_COUNT * sizeof(bool));
> 
> 	memcpy(globalGoal, object.globalGoal, UNIT_TYPE_COUNT * MAX_LOCATIONS * sizeof(int));
> 		
74c71,72
< 	for(int i=UNIT_TYPE_COUNT;i--;)
---
> 	// DO NOT MEMSET!
> 	for(unsigned int i = UNIT_TYPE_COUNT; i--; )
78d75
< 		allGoal[i]=0;
82,83d78
< 		for(int j=MAX_LOCATIONS;j--;)
< 			globalGoal[j][i]=0;
84a80,82
> 
> 	memset(allGoal, 0, UNIT_TYPE_COUNT * sizeof(int));
> 	memset(globalGoal, 0, UNIT_TYPE_COUNT * MAX_LOCATIONS * sizeof(int));
171c169
< 	for(int i=UNIT_TYPE_COUNT;i--;)
---
> 	for(unsigned int i=UNIT_TYPE_COUNT;i--;)
362,366c360,363
< 	for(unsigned int i = 0; i <= GAS_SCV; i++)
< 	{
< 		tree.level[i]=0;
< 		tree.coloumn[i]=0;
< 	}
---
> 
> 	memset(tree.level, 0, (GAS_SCV+1) * sizeof(int));
> 	memset(tree.coloumn, 0, (GAS_SCV+1) * sizeof(int));
> 
416,417c413
< 		for(unsigned int i = 1; i <= GAS_SCV; i++)
< 			tcheck[i]=false;
---
> 		memset(tcheck, 0, (GAS_SCV+1) * sizeof(bool)); // ?
467c463
< 	for(int i=UNIT_TYPE_COUNT;i--;)
---
>         for(unsigned int i = UNIT_TYPE_COUNT; i--; )
471c467
< 		isStatic[i] = true; //?
---
>                 isStatic[i] = true;
474a471
> 	
480,482c477,478
< 	for(int i=UNIT_TYPE_COUNT;i--;) {
< 		oldGoal[i]=allGoal[i];
< 	}
---
> 	memcpy(oldGoal, allGoal, UNIT_TYPE_COUNT * sizeof(int));
> 
491c487
< 		for(int i=GAS_SCV+1;i--;)
---
> 		for(int i=LAST_UNIT; i--;)
501c497
< 		for(int i=GAS_SCV+1;i--;)
---
> 		for(int i=LAST_UNIT;i--;)
615a612,617
> //	isBuildable[BUILD_PARALLEL_2] = true;
> //	isBuildable[BUILD_PARALLEL_4] = true;
> //	isBuildable[BUILD_PARALLEL_8] = true;
> //	isBuildable[BUILD_PARALLEL_16] = true;
> 	isBuildable[FROM_GAS_TO_MINERALS] = true;
> 
632a635
> 	
651c654
< 	for(int i = GAS_SCV+1;i--;)
---
> 	for(int i = LAST_UNIT;i--;)
668a672
> 
750c754
< 	if(location>=MAX_LOCATIONS) {
---
> 	if(location >= MAX_LOCATIONS) { // TODO
796,797d799
< 
< 
diff -b -w -d ./goalentry.hpp /home/claw/work/sc1064/sc/core/goalentry.hpp
212c212
< 	if(unit>GAS_SCV) {
---
> 	if(unit >= LAST_UNIT) {
228c228
< 	if(unit>GAS_SCV) {
---
> 	if(unit >= LAST_UNIT) {
242c242
< 	if(unit>GAS_SCV) {
---
> 	if(unit >= LAST_UNIT) {
251c251
< 	if(unit>GAS_SCV) {
---
> 	if(unit > LAST_UNIT) {
261c261
< 	if(unit>GAS_SCV) {
---
> 	if(unit >= LAST_UNIT) {
Files ./goalentry.o and /home/claw/work/sc1064/sc/core/goalentry.o differ
diff -b -w -d ./goal.hpp /home/claw/work/sc1064/sc/core/goal.hpp
69c69
< 	if((goal_location >= MAX_LOCATIONS)) {
---
> 	if((goal_location >= MAX_LOCATIONS)) { // TODO
120c120
< 	if((location >= MAX_LOCATIONS)) {
---
> 	if((location >= MAX_LOCATIONS)) { // TODO
Files ./goal.o and /home/claw/work/sc1064/sc/core/goal.o differ
diff -b -w -d ./harvest.cpp /home/claw/work/sc1064/sc/core/harvest.cpp
12,13c12
< {
< }
---
> { }
Files ./harvest.o and /home/claw/work/sc1064/sc/core/harvest.o differ
diff -b -w -d ./location.cpp /home/claw/work/sc1064/sc/core/location.cpp
11c11,15
< 	resetData();
---
> 	for(unsigned int i=MAX_LOCATIONS;i--;)
> 	{
> 		distance[i] = 9999;
> 		nearest[i] = 0;
> 	}
23c27
< 		setDistance(i,0);
---
> 		distance[i] = 9999;
60c64
< 	for(unsigned int step = 1; step < MAX_LOCATIONS; step++)
---
> 	for(unsigned int step = 1; step < getMaxLocations(); step++)
63c67
< 		for(unsigned int loc = 1;loc < MAX_LOCATIONS;loc++)
---
> 		for(unsigned int loc = 1;loc < getMaxLocations();loc++)
78c82
< 
---
> unsigned int MAP_LOCATION::maxLocations = 0;
diff -b -w -d ./location.hpp /home/claw/work/sc1064/sc/core/location.hpp
13a14,15
> 		static unsigned int maxLocations;
> 		static const unsigned int getMaxLocations();
35a38,39
> 		
> 		static void setMaxLocations(const unsigned int max_locations);
37a42,63
> inline void MAP_LOCATION::setMaxLocations(const unsigned int max_locations)
> {
> #ifdef _SCC_DEBUG
> // TODO constant
>         if(max_locations > MAX_LOCATIONS) {
>                 toLog("DEBUG: (MAP_LOCATION::setMaxLocations): Value out of range.");return;
>         }
> #endif
> 	maxLocations=max_locations;
> }
> 
> inline const unsigned int MAP_LOCATION::getMaxLocations()
> {
> #ifdef _SCC_DEBUG
> // TODO constant
>         if(maxLocations > MAX_LOCATIONS) {
>                 toLog("DEBUG: (MAP_LOCATION::getMaxLocations): Variable maxLocations out of range.");return(0);
>         }
> #endif
> 	return(maxLocations);
> }
> 
44a71,76
> #ifdef _SCC_DEBUG
> // TODO constant
> 	if(mineralPatches > 100) {
> 		toLog("DEBUG: (MAP_LOCATION::getMineralPatches): Variable mineralPatches out of range.");return(0);
> 	}
> #endif			
49a82,87
> #ifdef _SCC_DEBUG
> // TODO constantv
>         if(vespeneGeysirs > 100) {
>                 toLog("DEBUG: (MAP_LOCATION::getVespeneGeysirs): Value vespeneGeysirs out of range.");return(0);
>         }
> #endif
88c126
< 	if((step<=0)||(step>=MAX_LOCATIONS)) {
---
> 	if((step<=0)||(step>=maxLocations)) {
99c137
< 	if(target>=MAX_LOCATIONS) {
---
> 	if(target>=maxLocations) {
102,104c140,142
< 	if(location_distance>500) {
< 		toLog("DEBUG: (MAP_LOCATION::setDistance): Value distance out of range.");return;
< 	}
---
> //	if(location_distance>) {
> //		toLog("DEBUG: (MAP_LOCATION::setDistance): Value distance out of range.");return;
> //	}
127c165
< 	if(location>=MAX_LOCATIONS) {
---
> 	if(location>=maxLocations) {
130,132c168,170
< 	if(distance[location]>500) {
< 		toLog("DEBUG: (MAP_LOCATION::getDistance): Value distance out of range.");return(0);
< 	}
---
> //	if(distance[location]>500) {
> //		toLog("DEBUG: (MAP_LOCATION::getDistance): Value distance out of range.");return(0);
> //	}
Files ./location.o and /home/claw/work/sc1064/sc/core/location.o differ
diff -b -w -d ./prerace.cpp /home/claw/work/sc1064/sc/core/prerace.cpp
38c38
< 	memset(gasHarvestPerSecond, 0, 6 * MAX_LOCATIONS*sizeof(int));
---
> 	memset(gasHarvestPerSecond, 0, 5 * MAX_LOCATIONS*sizeof(int));
40c40
< 	memset(Marker, 0, MAX_LENGTH*sizeof(int));
---
> //	memset(Marker, 0, MAX_LENGTH*sizeof(int));
69c69
< 	memset(gasHarvestPerSecond, 0, 6 * MAX_LOCATIONS*sizeof(int));
---
> 	memset(gasHarvestPerSecond, 0, 5 * MAX_LOCATIONS*sizeof(int));
71c71
< 	memset(Marker, 0, MAX_LENGTH*sizeof(int));
---
> //	memset(Marker, 0, MAX_LENGTH*sizeof(int));
75,85d74
< void PRERACE::resetStaticPrerace()
< {
< 	pMap=NULL;
< 	memset(noise, 0, MAX_TIME*sizeof(int));
< 	markerCounter=1;
< 	for(int i = MAX_PLAYER;i--;)
< 		for(int j = MAX_LOCATIONS;j--;)
< 			unit[i][j].resetData();
< 	pStart=NULL;
< }
< 
111,125c100,102
< 	for(unsigned int i=MAX_LENGTH;i--;)
< 	{
< 	//	last[i] = object.last[i];
< 		setCode(i, object.getCode(i));
< 		setMarker(i, object.getMarker(i));
< 	}
< 		
< 	for(int i=MAX_LOCATIONS;i--;)
< 	{
< 		larvaInProduction[i] = object.larvaInProduction[i];
< 		for(unsigned int j = 0; j<45; j++)
< 			mineralHarvestPerSecond[i][j] = object.mineralHarvestPerSecond[i][j];
< 		for(unsigned int j = 0; j<5; j++)
< 			gasHarvestPerSecond[i][j] = object.gasHarvestPerSecond[i][j];
< 	}	
---
> 	memcpy(Code, object.Code, MAX_LENGTH * sizeof(int));
> //	memcpy(Marker, object.Marker, MAX_LENGTH * sizeof(int));
> 	//memcpy(last, object.last, MAX_LENGTH * sizeof(int));
126a104,106
> 	memcpy(larvaInProduction, object.larvaInProduction, MAX_LOCATIONS * sizeof(int));
> 	memcpy(mineralHarvestPerSecond, mineralHarvestPerSecond, MAX_LOCATIONS * 45 * sizeof(int));
> 	memcpy(gasHarvestPerSecond, object.gasHarvestPerSecond, MAX_LOCATIONS * 5 * sizeof(int));
155c135
< 	memcpy(Marker, object.Marker, MAX_LENGTH * sizeof(int));
---
> //	memcpy(Marker, object.Marker, MAX_LENGTH * sizeof(int));
158,160c138
< 	for(int i=MAX_LOCATIONS;i--;)
< 		larvaInProduction[i] = object.larvaInProduction[i];
< 	
---
> 	memcpy(larvaInProduction, object.larvaInProduction, MAX_LOCATIONS * sizeof(int));	
169a148,159
> 	std::list<PARALLEL_COMMAND*>::iterator i = parallelCommandQueues.begin();
> 	while(i!=parallelCommandQueues.end())
> 	{
> 		delete *i;
> 		i = parallelCommandQueues.erase(i);
> 	}
> 
> 	PARALLEL_COMMAND* gimme = new PARALLEL_COMMAND();
> 	gimme->unit = SCV;
> 	gimme->count = 64;
> 	parallelCommandQueues.push_back(gimme);
> 								
214c204,211
< { }
---
> {
> 	std::list<PARALLEL_COMMAND*>::iterator i = parallelCommandQueues.begin();
> 	while(i!=parallelCommandQueues.end())
> 	{
> 		delete *i;
> 		i = parallelCommandQueues.erase(i);
> 	}
> }
236,237c233,234
< 	markerCounter++;
< 	setMarker(ip, markerCounter);
---
> //	markerCounter++;
> //	setMarker(ip, markerCounter);
291c288
< void PRERACE::adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2)
---
> void PRERACE::adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2, const unsigned int count)
293,299d289
< #ifdef _SCC_DEBUG
< 	if((location_number >= MAX_LOCATIONS))  {
< 		toLog("DEBUG: (PRERACE::adjustLocationUnitsAfterCompletion): Value location_number out of range.");return;
< 	}
< // TODO andere facilities!!	
< #endif
< 
304a295,302
> 			if(count!=1)
> 			{
> 				if(facility)
> 					setLocationTotal(location_number, facility, getLocationTotal(location_number, facility) - count);
> //				if(facility2)
> //					removeOneLocationTotal(location_number, facility2);
> 			} else
> 			{
309a308
> 			}
434a434,435
> 
> // STARK VON LOCATIONS ABHAENGIG!
473c474
< 						while((j<MAX_LOCATIONS) && (bon>getLocationTotal(loc, i->getUnit())))
---
> 						while((j<(*getMap())->getMaxLocations()) && (bon>getLocationTotal(loc, i->getUnit())))
477a479
> 							loc = (*pMap)->getLocation(i->getLocation())->getNearest(j);
480c482
< 						if(j<MAX_LOCATIONS)
---
> 						if(j<(*getMap())->getMaxLocations())
519c521
< 		std::priority_queue<Building, std::deque<Building> >  save = buildingQueue;
---
> 		std::priority_queue<Building, std::vector<Building> >  save = buildingQueue;
561c563
< 
---
> #if 0
564d565
< 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
566a568,570
> 
> 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> 	bool ok = false;
577c581
< 	bool ok = false;
---
> 
673a678,679
> 
> 		TODO program!
685,686c691,692
< 
< const bool PRERACE::isDifferent(const unsigned int* code, const unsigned int* marker) const
---
> #endif
> const bool PRERACE::isDifferent(const unsigned int* code) const //, const unsigned int* marker) const
689c695
< 		if((getCode(i)!=code[i])||(getMarker(i)!=marker[i]))
---
> 		if((getCode(i)!=code[i]))//||(getMarker(i)!=marker[i]))
700,704d705
< #ifdef _SCC_DEBUG
< 	if((location_number >= MAX_LOCATIONS)) {
< 		toLog("DEBUG: (PRERACE::adjustMineralHarvest): Value location_number out of range.");return;
< 	}
< #endif
740,744d740
< #ifdef _SCC_DEBUG
< 	if((location_number >= MAX_LOCATIONS))	{
< 		toLog("DEBUG: (PRERACE::adjustGasHarvest): Value location_number out of range.");return;
< 	}
< #endif
776c772,773
< 	for(int i=MAX_LOCATIONS;i--;) {
---
> 	for(int i = (*getMap())->getMaxLocations();i--;)
> 	{
786c783
< 	for(int i=1;i<MAX_LOCATIONS;i++)//~~
---
> 	for(unsigned int i=1;i<(*getMap())->getMaxLocations();i++)//~~
816c813
< 	for(int i=1;i<MAX_LOCATIONS;i++)//~~
---
> 	for(unsigned int i=1;i<(*getMap())->getMaxLocations();i++)//~~
818c815
< 		int s=location[i].getAvailible(GAS_SCV);
---
> 		unsigned int s = location[i].getAvailible(GAS_SCV);
858a856,860
> 	memset(noise, 0, MAX_TIME * sizeof(int));
> //	markerCounter = 1;
> 	for(int i = MAX_PLAYER;i--;)
> 		for(int j = (*getMap())->getMaxLocations();j--;)
> 			unit[i][j].resetData();
859a862
> 
867d869
< 
879,906c881
< 	for(int i=MAX_LOCATIONS;i--;)
< 		larvaInProduction[i]=0;
< }
< 
< void PRERACE::removeLarvaFromQueue(const unsigned int location_number)
< {
< #ifdef _SCC_DEBUG
< 	if((location_number<1) || (location_number >= MAX_LOCATIONS)) {
< 			toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Value location_number out of range.");return;
< 	}
< 	if((larvaInProduction[location_number]<1)||(larvaInProduction[location_number]>=MAX_SUPPLY)) {
< 			toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
< 	}
< #endif
< 	larvaInProduction[location_number]--;
< }
< 
< void PRERACE::addLarvaToQueue(const unsigned int location_number)
< {
< #ifdef _SCC_DEBUG
< 	if((location_number<1) || (location_number >= MAX_LOCATIONS)) {
< 			toLog("DEBUG: (PRERACE::addLarvaFromQueue): Value location_number out of range.");return;
< 	}
< 	if(larvaInProduction[location_number]>=MAX_SUPPLY) {
< 			toLog("DEBUG: (PRERACE::addLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
< 	}
< #endif
< 	larvaInProduction[location_number]++;
---
> 	memset(larvaInProduction, 0, MAX_LOCATIONS * sizeof(int));
1315c1290
< 					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
---
> //					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
1338c1313
<                                         markerCounter++;Marker[x]=markerCounter;
---
> //					markerCounter++;Marker[x]=markerCounter;
1505,1506d1479
< 	
< 
1518c1491
< 	for(unsigned int i=GAS_SCV+1;i--;)
---
> 	for(unsigned int i = LAST_UNIT;i--;)
1567c1540
< 						Marker[i] = Marker[i+1];
---
> //						Marker[i] = Marker[i+1];
1570c1543
< 					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
---
> //					markerCounter++;Marker[MAX_LENGTH-1] = markerCounter;
1586c1559
< 					memmove(Marker+x+1, Marker+x, MAX_LENGTH-x-1);
---
> //					memmove(Marker+x+1, Marker+x, MAX_LENGTH-x-1);
1593c1566
<                                         markerCounter++;Marker[x]=markerCounter;
---
> //					markerCounter++;Marker[x]=markerCounter;
1615c1588
<                                                 markerCounter++;Marker[x]=markerCounter;
---
> //						markerCounter++;Marker[x]=markerCounter;
1629c1602
<                                                         l=Marker[x];Marker[x]=Marker[y];Marker[y]=l;
---
> //							l=Marker[x];Marker[x]=Marker[y];Marker[y]=l;
1641c1614
<                                                         unsigned int tmpMarker[MAX_LENGTH];
---
> //							unsigned int tmpMarker[MAX_LENGTH];
1646c1619
<                                                                 tmpMarker[i] = Marker[x + i];
---
> //								tmpMarker[i] = Marker[x + i];
1652c1625
<                                                                 Marker[i+block_length] = Marker[i];
---
> //								Marker[i+block_length] = Marker[i];
1658c1631
<                                                                 Marker[target_position + i] = tmpMarker[i];
---
> //								Marker[target_position + i] = tmpMarker[i];
1913c1886
< 			markerCounter++;setMarker(i, markerCounter);
---
> //			markerCounter++;setMarker(i, markerCounter);
1972,1977c1945
< 	memcpy(Marker, player.Marker, sizeof(int) * MAX_LENGTH);
< /*	for(int i=MAX_LENGTH;i--;)
< 	{
< 		Code[i] = player.Code[i];
< 		Marker[i] = player.Marker[i];
< 	}*/
---
> //	memcpy(Marker, player.Marker, sizeof(int) * MAX_LENGTH);
1989c1957
< unsigned int PRERACE::markerCounter;
---
> //unsigned int PRERACE::markerCounter;
diff -b -w -d ./prerace.hpp /home/claw/work/sc1064/sc/core/prerace.hpp
54a55,60
> struct PARALLEL_COMMAND
> {
> 	unsigned int unit;
> 	unsigned int count;
> };
> 
68c74,75
< 	priority_queue<Building, deque<Building> > buildingQueue;
---
> 		priority_queue<Building, vector<Building> > buildingQueue;
> 		list<PARALLEL_COMMAND*> parallelCommandQueues;
72c79
< 	static unsigned int markerCounter;
---
> //		static unsigned int markerCounter;
85d91
< 	static void resetStaticPrerace();
92c98
< 	void adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2);
---
> 		void adjustLocationUnitsAfterCompletion(const unsigned int location_number, const eFacilityType facilityType, const unsigned int facility, const unsigned int facility2, const unsigned int count);
101,103c107
< 	GOAL_ENTRY* getpGoal() const {
< 		return(*pGoal);
< 	}
---
> 		GOAL_ENTRY* getpGoal() const;
110c114
< 	unsigned int Marker[MAX_LENGTH];
---
> //		unsigned int Marker[MAX_LENGTH];
124,125d127
< 
< 
141c143
< 	const bool isDifferent(const unsigned int* code, const unsigned int* marker) const;
---
> 		const bool isDifferent(const unsigned int* code) const; //, const unsigned int* marker) const;
173d174
< 	const bool buildIt(const unsigned int build_unit);
176c177
< 	void setMarker(const unsigned int ip, const unsigned int value);
---
> //		void setMarker(const unsigned int ip, const unsigned int value);
180c181
< 	 const unsigned int getMarker(const unsigned int ip) const;
---
> //		const unsigned int getMarker(const unsigned int ip) const;
243d243
< 
245a246,250
> inline GOAL_ENTRY* PRERACE::getpGoal() const {
> 	return(*pGoal);
> }
> 
> 
249c254
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
256c261
< inline void PRERACE::setMarker(const unsigned int ip, const unsigned int value)
---
> /*inline void PRERACE::setMarker(const unsigned int ip, const unsigned int value)
264c269
< }
---
> }*/
303c308
< inline const unsigned int PRERACE::getMarker(const unsigned int ip) const
---
> /*inline const unsigned int PRERACE::getMarker(const unsigned int ip) const
311c316
< }
---
> }*/
322c327
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
335c340
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
348c353
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
361c366
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
374c379
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
387c392
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
400c405
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
414c419
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
424c429
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
434c439
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
444c449
< 	if(location_number >= MAX_LOCATIONS)	{
---
> 	if(location_number >= (*getMap())->getMaxLocations())	{
454c459
< 	if(location_number >= MAX_LOCATIONS) {
---
> 	if(location_number >= (*getMap())->getMaxLocations()) {
466c471
< 	if(location_number >= MAX_LOCATIONS)	{
---
> 	if(location_number >= (*getMap())->getMaxLocations())	{
478c483
< 	if(location_number >= MAX_LOCATIONS) {
---
> 	if(location_number >= (*getMap())->getMaxLocations()) {
491c496
< 	if(location_number >= MAX_LOCATIONS) {
---
> 	if(location_number >= (*getMap())->getMaxLocations()) {
503c508
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
516c521
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
617c622
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
630c635
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
649c654
< 	if((location_number >= MAX_LOCATIONS)) {
---
> 	if((location_number >= (*getMap())->getMaxLocations())) {
662c667
< 	if((location_number >= MAX_LOCATIONS))	{
---
> 	if((location_number >= (*getMap())->getMaxLocations()))	{
936a942,953
> inline void PRERACE::removeLarvaFromQueue(const unsigned int location_number)
> {
> #ifdef _SCC_DEBUG
> 	if((location_number<1) || (location_number >= (*getMap())->getMaxLocations())) {
> 		toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Value location_number out of range.");return;
> 	}
> 	if((larvaInProduction[location_number]<1)||(larvaInProduction[location_number]>=MAX_SUPPLY)) {
> 		toLog("DEBUG: (PRERACE::removeLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
> 	}
> #endif
> 	larvaInProduction[location_number]--;
> }
938c955,966
< 
---
> inline void PRERACE::addLarvaToQueue(const unsigned int location_number)
> {
> #ifdef _SCC_DEBUG
> 	if((location_number<1) || (location_number >= (*getMap())->getMaxLocations())) {
> 		toLog("DEBUG: (PRERACE::addLarvaFromQueue): Value location_number out of range.");return;
> 	}
> 	if(larvaInProduction[location_number]>=MAX_SUPPLY) {
> 		toLog("DEBUG: (PRERACE::addLarvaFromQueue): Variable larvaInProduction not initialized or out of range.");return;
> 	}
> #endif
> 	larvaInProduction[location_number]++;
> }
Files ./prerace.o and /home/claw/work/sc1064/sc/core/prerace.o differ
Only in /home/claw/work/sc1064/sc/core/: program.cpp
Only in /home/claw/work/sc1064/sc/core/: program.hpp
Only in /home/claw/work/sc1064/sc/core/: program.o
diff -b -w -d ./race.cpp /home/claw/work/sc1064/sc/core/race.cpp
38,42d37
< void RACE::resetStaticData()
< {
< 	PRERACE::resetStaticPrerace();
< }
< 
111d105
< 	bool first=true;
119a114,135
> 		int code = getpGoal()->toPhaeno(getCurrentCode());
> 		if((code >= BUILD_PARALLEL_2) && (code <= BUILD_PARALLEL_16))
> 		{
> 			setIP(getIP()-1);
> 			while((getpGoal()->toPhaeno(getCurrentCode()) > GAS_SCV)&&(getIP()))
> 				setIP(getIP()-1);
> 			PARALLEL_COMMAND* pcommand = new PARALLEL_COMMAND;
> 			switch(code)
> 			{
> 				case BUILD_PARALLEL_2:pcommand->count = 2;break;
> 				case BUILD_PARALLEL_4:pcommand->count = 4;break;
> 				case BUILD_PARALLEL_8:pcommand->count = 8;break;
> 				case BUILD_PARALLEL_16:pcommand->count = 16;break;
> 				default:break; // ~~
> 			}
> 			pcommand->unit = getpGoal()->toPhaeno(getCurrentCode());
> 			if(getIP()) 
> 				setIP(getIP()-1);
> 			parallelCommandQueues.push_back(pcommand);
> 			ok = true;
> 		} else
> 		{
121c137
< 		
---
> 		// ~~
124,126c140,142
< 			if(!first)
< 				settFitness(gettFitness()-1);
< 			first=false;
---
> //                        if(!first)
>   //                              settFitness(gettFitness()-1);
>     //                    first=false; TODO
129d144
< 			
131,132d145
< 
< 
134a148,166
> 		else if(!ok)
> 		{
> // TEST FOR PARALLEL COMMANDQUEUES
> 			std::list<PARALLEL_COMMAND*>::iterator i = parallelCommandQueues.begin(); 
> 			while(i != parallelCommandQueues.end())
> 			{
> 				ok = buildGene((*i)->unit);
> 				if(ok)
> 				{
> 					(*i)->count--;
> 					if(!(*i)->count)
> 					{
> 						delete *i;
> 						i = parallelCommandQueues.erase(i);
> 					}
> 				} else i++;
> 			}
> 		}
> 		}
136d167
< 
165c196
< 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2);			
---
> 			adjustLocationUnitsAfterCompletion(build.getLocation(), stat->facilityType, build.getFacility(), stat->facility2, build.getUnitCount());
268d298
< 			{
276,277c306
< 					if((getMinerals()*5/4<stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit))||
< 					   (getGas()*5/4<stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)))
---
>                                         if((getMinerals()*5/4<stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit))||(getGas()*5/4<stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)))
279,281c308
< 				}
< // ------ END RACE SPECIFIC, tFITNESS ------
< 			} //end minerals/gas else
---
>                                 } else ok = false;
377a405,531
> const bool RACE::buildIt(const unsigned int build_unit)
> {
> 	//Zuerst: availible pruefen ob am Ort gebaut werden kann
> 	//Wenn nicht => +/- absteigen bis alle locations durch sind
> 
> 	const UNIT_STATISTICS* stat = &((*pStats)[build_unit]);
> 	bool ok = false;
> 	unsigned int picked_facility = 0;
> 	unsigned int current_location_window = 1; // TODO
> //	unsigned int ttloc=0;
> //	unsigned int j=0;
> 
> /*	if(lastcounter>0)
> 	{	
> 		lastcounter--;
> 		tloc=last[lastcounter].location;
> 	}*/
> 
> 	if(stat->facility[0]==0)
> 		ok=true;
> 	else
> 	// special rule for morphing units of protoss
> 	if((stat->facility2>0) && ((stat->facilityType == IS_LOST) || (stat->facilityType == IS_MORPHING)) && (stat->facility[0] == stat->facility2))
> 	{
> 		if(getLocationAvailible(current_location_window, stat->facility2) >=2)
> 		{
> 			ok = true;
> 			picked_facility = 0;
> 		}
> 	} else
> 	{
> 		// research/upgrade:
> 		if((stat->facility2==0) || (getLocationAvailible(current_location_window, stat->facility2)>=1))
> 		{
> 		// pick one availible facility: 
> 			for(picked_facility = 0; picked_facility<3; picked_facility++)
> 				if((stat->facility[picked_facility]>0)&&(getLocationAvailible(current_location_window, stat->facility[picked_facility])>0))
> 				{
> 					ok=true;
> 					break;
> 				}
> 		}						
> 	}
> 				
> //				j=1;
> 				// none found? search other parts of the map... TODO
> /*				if(!ok)
> 					while(j<MAX_LOCATIONS)
> 					{
> 						ttloc=(*pMap)->getLocation(tloc)->getNearest(j);
> //						if((stat->facility2==0)||(getLocationAvailible(ttloc,stat->facility2)>0)) TODO
> //						{
> //						for(fac=3;fac--;)
> 						for(fac=0;fac<3; fac++)
> 						if(
> 						// special rules for morphing units of protoss
> 						((stat->facilityType != IS_LOST) || (stat->facility[fac] != stat->facility2) || (getLocationAvailible(ttloc, stat->facility[fac]) >= 2)) &&
> 						((stat->facility[fac] > 0) && (getLocationAvailible(ttloc, stat->facility[fac])))
> 						|| ((stat->facility[fac]==0)&&(fac==0))) //~~
> 																													   
> //					  for(fac=3;fac--;)
> //						  if( ((stat->facility[fac]>0)&&(getLocationAvailible(ttloc,stat->facility[fac])>((stat->facilityType==IS_LOST)&&(stat->facility[fac]==stat->facility2)))) || ((stat->facility[fac]==0)&&(fac==0)))
> 							{
> 								tloc=ttloc;
> 								ok=true;
> 								break;
> 							}
> //						  break;
> //					  }
> 						j++;
> 					}*/
> 																													   
> 	if((ok)&&(build_unit==REFINERY)) {
> 		if(getMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR) <=0)
> 			ok = false;
> 		else
> 			removeOneMapLocationAvailible(GLOBAL, current_location_window, VESPENE_GEYSIR);
> 	}
> //TODO: Wenn verschiedene facilities moeglich sind, dann das letzte nehmen
> //			  bewegliche Sachen ueberdenken...
> //				  evtl zusaetzliche Eigenschaft 'speed' einbauen (muss sowieso noch...)... bei speed>0 ... mmmh... trifft aber auch nur auf scvs zu ... weil bringt ja wenig erst mit der hydra rumzulaufen und dann zum lurker... mmmh... aber waere trotzdem zu ueberlegen...
> //				  auch noch ueberlegen, wenn z.B. mit scv ohne kommandozentrale woanders gesammelt wird...
> //	  Phagen ueber Phagen...
> 	if(ok)
> 	{ 
>  		if((getpGoal()->getRace()==ZERG) &&
> //		  ((*pStats)[build_unit].facility[0]==LARVA)&&
> 			(build_unit!=LARVA) &&
> 		// Larva wird benoetigt zum Bau? Fein, dann bauen wir eine neue Larva falls nicht schon alle hatcheries etc. belegt sidn
> 				// Gesamtzahl der Larven < 3 * HATCHERY?
> 		   ((getLocationTotal(current_location_window, HATCHERY)+
> 			 getLocationTotal(current_location_window, LAIR)+
> 			 getLocationTotal(current_location_window, HIVE)) *3 > 
> 			 (larvaInProduction[current_location_window]+getLocationTotal(current_location_window, LARVA)))  &&
> // max 1 larva pro Gebaeude produzieren
>  		   ((getLocationTotal(current_location_window, HATCHERY)+
> 			 getLocationTotal(current_location_window, LAIR)+
> 			 getLocationTotal(current_location_window, HIVE) > 
> 			  larvaInProduction[current_location_window]))) // => zuwenig Larven da!
> 			{
> 				addLarvaToQueue(current_location_window);
> 				if(!buildIt(LARVA));
> //					removeLarvaFromQueue(current_location_window);
> 			}
> 																													  
> 		Building build;
> 		build.setOnTheRun(false);
> 		build.setFacility(stat->facility[picked_facility]);
> 		build.setLocation(current_location_window);
> 		if(build_unit == FROM_GAS_TO_MINERALS)
> 			build.setUnitCount(getLocationAvailible(current_location_window, GAS_SCV));
> 		else
> 			build.setUnitCount(1+(stat->create == build_unit));
> 		build.setBuildFinishedTime(getTimer()-stat->BT);
> 		build.setTotalBuildTime(stat->BT);
> 		build.setType(build_unit);
> // upgrade_cost is 0 if it's no upgrade
> 		setMinerals(getMinerals()-(stat->minerals+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> 		setGas(getGas()-(stat->gas+stat->upgrade_cost*getLocationTotal(GLOBAL, build_unit)));
> 		setNeedSupply(getNeedSupply()+stat->needSupply);
> //		if((stat->needSupply>0)||(((*pStats)[stat->facility[0]].needSupply<0)&&(stat->facilityType==IS_LOST)))  TODO!!!!
> //		setNeedSupply(getNeedSupply()-stat->needSupply); //? Beschreibung!
> 		adjustAvailibility(current_location_window, picked_facility, stat);
> 		buildingQueue.push(build);
> 	} //end if(ok)
> 	return(ok);
> }
382d535
< 
diff -b -w -d ./race.hpp /home/claw/work/sc1064/sc/core/race.hpp
14a15
> 		const bool buildIt(const unsigned int build_unit);
21d21
< 		static void resetStaticData();
72a73
> 
102a104
> 
Files ./race.o and /home/claw/work/sc1064/sc/core/race.o differ
diff -b -w -d ./settings.cpp /home/claw/work/sc1064/sc/core/settings.cpp
197a198,200
> 						ostringstream sdf;
> 						sdf << unit << " " << count << " " << time << " " << location;
> 						toLog(sdf.str());
355c358
< 			if((i=block.find("Distances"))!=block.end()) 
---
> 			if((i=block.find("Distance to"))!=block.end()) 
358c361,364
< 				basicmap->setLocationDistance(location-1, i->second);
---
> 				int target = atoi(i->second.front().c_str());
> 				i->second.pop_front();
> 				basicmap->setLocationDistance(location-1, target-1, atoi(i->second.front().c_str()));
> 				cout << location-1 << "->" << target-1 << " : " << atoi(i->second.front().c_str()) << std::endl;
372a379,387
> 	
> 	for(unsigned int i = 1; i < basicmap->getMaxLocations(); i++)
> 	{	
> 		std::cout << "Location " << i << " ";
> 		for(unsigned int j = 1; j < basicmap->getMaxLocations(); j++)
> 			std::cout << basicmap->getLocation(i)->getDistance(j) << " ";
> 		std::cout << std::endl;
> 	}
> 
373a389,397
> 
> 	for(unsigned int i = 1; i < basicmap->getMaxLocations(); i++)
> 	{	
> 		std::cout << "Location " << i << " ";
> 		for(unsigned int j = 1; j < basicmap->getMaxLocations(); j++)
> 			std::cout << basicmap->getLocation(i)->getDistance(j) << " ";
> 		std::cout << std::endl;
> 	}
> 	
488a513
> 	
518,519c543
< for(int i = MAX_LENGTH;i--;)
< 	if(anarace->getProgramIsBuilt(i))
---
> 	for(std::list<PROGRAM>::const_iterator order = anarace->programList.begin(); order != anarace->programList.end(); ++order)
521,523c545,546
< pFile << "    <tr style=\"text-align: center; vertical-align: middle; background-color: rgb(" << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][anarace->getPhaenoCode(i)].unitType))->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][anarace->getPhaenoCode(i)].unitType))->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][anarace->getPhaenoCode(i)].unitType))->GetColor()->b() << ");\">" << std::endl;
< 
< pFile << "      <td style=\"\">" << *UI_Object::theme.lookUpString((eString)(UNIT_TYPE_COUNT*anarace->getRace()+anarace->getPhaenoCode(i)+UNIT_NULL_STRING)) << "<br>" << std::endl;
---
> 		pFile << "	<tr style=\"text-align: center; vertical-align: middle; background-color: rgb(" << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][order->getUnit()].unitType))->GetColor()->r() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][order->getUnit()].unitType))->GetColor()->g() << ", " << (int)UI_Object::theme.lookUpBrush((eBrush)(UNIT_TYPE_0_BRUSH+stats[anarace->getRace()][order->getUnit()].unitType))->GetColor()->b() << ");\">" << std::endl;
> 		pFile << "	  <td style=\"\">" << *UI_Object::theme.lookUpString((eString)(UNIT_TYPE_COUNT*anarace->getRace() + order->getUnit() + UNIT_NULL_STRING)) << "<br>" << std::endl;
525,526c548
< 
< pFile << "      <td style=\"\">" << anarace->getIPStatisticsNeedSupply(2*i) << "/" << anarace->getIPStatisticsHaveSupply(2*i) << "<br>" << std::endl;
---
> 		pFile << "	  <td style=\"\">" << order->getStatisticsBefore().getNeedSupply() << "/" << order->getStatisticsBefore().getHaveSupply() << "<br>" << std::endl;
529c551
< pFile << "      <td style=\"\">" << anarace->getIPStatisticsHaveMinerals(2*i)/100 << "<br>" << std::endl;
---
> 		pFile << "	  <td style=\"\">" << order->getStatisticsBefore().getHaveMinerals()/100 << "<br>" << std::endl;
532c554
< pFile << "      <td style=\"\">" << anarace->getIPStatisticsHaveGas(2*i)/100 << "<br>" << std::endl;
---
> 		pFile << "	  <td style=\"\">" << order->getStatisticsBefore().getHaveGas()/100 << "<br>" << std::endl;
535c557
< pFile << "      <td style=\"\">" << (*anarace->getMap())->getLocation(anarace->getProgramLocation(i))->getName() << "<br>" << std::endl;
---
> 		pFile << "	  <td style=\"\">" << (*anarace->getMap())->getLocation(order->getLocation())->getName() << "<br>" << std::endl;
538c560
< pFile << "      <td style=\"\">" << formatTime(anarace->getRealProgramTime(i)) << "<br>" << std::endl;
---
> 		pFile << "	  <td style=\"\">" << formatTime(order->getRealTime()) << "<br>" << std::endl;
547,548c569,570
< pFile << "<b><a href=\"http://www.clawsoftware.de\">www.clawsoftware.de</a></b>"<< std::endl;
< pFile << "</body>" << std::endl;
---
> 	pFile << "<b><a href=\"http://www.clawsoftware.de\">www.clawsoftware.de</a></b>\n";
> 	pFile << "</body>\n";
582,692d603
< // -------------------------------
< // ------ GET/SET FUNCTIONS ------
< // -------------------------------
< 
< const bool SETTINGS::getIsNewRun()
< {
< 	return(soup.getIsNewRun());
< }
< 
< const BASIC_MAP* SETTINGS::getMap(const unsigned int mapNumber) const
< {
< #ifdef _SCC_DEBUG
< 	if(mapNumber>loadedMap.size()) {
< 		toLog("WARNING: (SETTINGS::getMap): Value out of range.");return(0);
< 	}
< #endif
< 	return(loadedMap[mapNumber]);
< }
< 
< GOAL_ENTRY* SETTINGS::getCurrentGoal(const unsigned int player)
< {
< 	return(*(start.getCurrentGoal(player)));
< }
< 
< //void SETTINGS::setPreprocessBuildOrder(const bool preprocess)
< //{
< //	configuration.setPreprocessBuildOrder(preprocess);
< //}
< 
< void SETTINGS::assignMap(const unsigned int mapNumber)
< {
< #ifdef _SCC_DEBUG
< 	if(mapNumber>=loadedMap.size()) {
< 		toLog("WARNING: (SETTINGS::assignMap): Value out of range.");return;
< 	}
< #endif
< 	start.assignMap(loadedMap[mapNumber]);
< //	soup.initializeMap(&(loadedMap[mapNumber])); //?
< }
< 
< void SETTINGS::assignStartRace(const unsigned int player, const eRace race)
< {
< 	start.setPlayerRace(player, race);
< }
< 
< void SETTINGS::assignStartcondition(const unsigned int player, const unsigned int startcondition)
< {
< #ifdef _SCC_DEBUG
<     if(startcondition>=loadedStartcondition[start.getPlayerRace(player)].size()) {
<         toLog("WARNING: (SETTINGS::setStartcondition): Value out of range.");return;
<     }
< #endif
< 	start.assignStartcondition(player, loadedStartcondition[start.getPlayerRace(player)][startcondition]);
< }
< 
< void SETTINGS::setHarvestSpeed(const eRace race, const unsigned int harvest)
< {
< 	// todo: checken ob harvest dazupasst
< 	start.setHarvestSpeed(race, &(loadedHarvestSpeed[harvest]));
< }
< 
< void SETTINGS::setStartPosition(const unsigned int player, const unsigned int startPosition)
< {
< 	start.setStartPosition(player, startPosition);
< }
< 
< void SETTINGS::assignGoal(const unsigned int player, const unsigned int goal)
< {
< #ifdef _SCC_DEBUG
< 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
< 		toLog("WARNING: (SETTINGS::assignGoal): Value out of range.");return;
< 	}
< #endif
< 	start.assignGoal(player, loadedGoal[start.getPlayerRace(player)][goal]);
< }
< 
< const unsigned int SETTINGS::getStartconditionCount(const unsigned int player) const
< {
< 	return(loadedStartcondition[start.getPlayerRace(player)].size());
< }
< 
< const unsigned int SETTINGS::getGoalCount(const unsigned int player) const
< {
< 	return(loadedGoal[start.getPlayerRace(player)].size());
< }
< 
< const unsigned int SETTINGS::getMapCount() const
< {
< 	return(loadedMap.size());
< }
< 
< const GOAL_ENTRY* SETTINGS::getGoal(const unsigned int player, const unsigned int goal) const
< 
< {
< #ifdef _SCC_DEBUG
< 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
< 		toLog("WARNING: (SETTINGS::getGoal): Value out of range.");return(NULL);
< 	}
< #endif
< 	return(loadedGoal[start.getPlayerRace(player)][goal]);
< }
< 
< const START_CONDITION* SETTINGS::getStartcondition(const unsigned int player, const unsigned int startconditionNumber) const
< {
< #ifdef _SCC_DEBUG
< 	if(startconditionNumber>=loadedStartcondition[start.getPlayerRace(player)].size()) {
< 		toLog("WARNING: (SETTINGS::getStartcondition): Value out of range.");return(NULL);
< 	}
< #endif
< 	return(loadedStartcondition[start.getPlayerRace(player)][startconditionNumber]);
< }
diff -b -w -d ./settings.hpp /home/claw/work/sc1064/sc/core/settings.hpp
85a86,189
> // -------------------------------
> // ------ GET/SET FUNCTIONS ------
> // -------------------------------
> 
> inline const bool SETTINGS::getIsNewRun() {
> 	return(soup.getIsNewRun());
> }
> 
> inline const BASIC_MAP* SETTINGS::getMap(const unsigned int mapNumber) const
> {
> #ifdef _SCC_DEBUG
> 	if(mapNumber>loadedMap.size()) {
> 		toLog("WARNING: (SETTINGS::getMap): Value out of range.");return(0);
> 	}
> #endif
> 	return(loadedMap[mapNumber]);
> }
> 
> inline GOAL_ENTRY* SETTINGS::getCurrentGoal(const unsigned int player)
> {
> 	return(*(start.getCurrentGoal(player)));
> }
> 
> //inline void SETTINGS::setPreprocessBuildOrder(const bool preprocess)
> //{
> //	configuration.setPreprocessBuildOrder(preprocess);
> //}
> 
> inline void SETTINGS::assignMap(const unsigned int mapNumber)
> {
> #ifdef _SCC_DEBUG
> 	if(mapNumber>=loadedMap.size()) {
> 		toLog("WARNING: (SETTINGS::assignMap): Value out of range.");return;
> 	}
> #endif
> 	start.assignMap(loadedMap[mapNumber]);
> //	soup.initializeMap(&(loadedMap[mapNumber])); //?
> }
> 
> inline void SETTINGS::assignStartRace(const unsigned int player, const eRace race) {
> 	start.setPlayerRace(player, race);
> }
> 
> inline void SETTINGS::assignStartcondition(const unsigned int player, const unsigned int startcondition)
> {
> #ifdef _SCC_DEBUG
> 	if(startcondition>=loadedStartcondition[start.getPlayerRace(player)].size()) {
> 		toLog("WARNING: (SETTINGS::setStartcondition): Value out of range.");return;
> 	}
> #endif
> 	start.assignStartcondition(player, loadedStartcondition[start.getPlayerRace(player)][startcondition]);
> }
> 
> inline void SETTINGS::setHarvestSpeed(const eRace race, const unsigned int harvest) {
> 	// todo: checken ob harvest dazupasst
> 	start.setHarvestSpeed(race, &(loadedHarvestSpeed[harvest]));
> }
> 
> inline void SETTINGS::setStartPosition(const unsigned int player, const unsigned int startPosition) {
> 	start.setStartPosition(player, startPosition);
> }
> 
> inline void SETTINGS::assignGoal(const unsigned int player, const unsigned int goal)
> {
> #ifdef _SCC_DEBUG
> 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
> 		toLog("WARNING: (SETTINGS::assignGoal): Value out of range.");return;
> 	}
> #endif
> 	start.assignGoal(player, loadedGoal[start.getPlayerRace(player)][goal]);
> }
> 
> inline const unsigned int SETTINGS::getStartconditionCount(const unsigned int player) const {
> 	return(loadedStartcondition[start.getPlayerRace(player)].size());
> }
> 
> inline const unsigned int SETTINGS::getGoalCount(const unsigned int player) const {
> 	return(loadedGoal[start.getPlayerRace(player)].size());
> }
> 
> inline const unsigned int SETTINGS::getMapCount() const {
> 	return(loadedMap.size());
> }
> 
> inline const GOAL_ENTRY* SETTINGS::getGoal(const unsigned int player, const unsigned int goal) const
> {
> #ifdef _SCC_DEBUG
> 	if(goal>=loadedGoal[start.getPlayerRace(player)].size()) {
> 		toLog("WARNING: (SETTINGS::getGoal): Value out of range.");return(NULL);
> 	}
> #endif
> 	return(loadedGoal[start.getPlayerRace(player)][goal]);
> }
> 
> inline const START_CONDITION* SETTINGS::getStartcondition(const unsigned int player, const unsigned int startconditionNumber) const
> {
> #ifdef _SCC_DEBUG
> 	if(startconditionNumber>=loadedStartcondition[start.getPlayerRace(player)].size()) {
> 		toLog("WARNING: (SETTINGS::getStartcondition): Value out of range.");return(NULL);
> 	}
> #endif
> 	return(loadedStartcondition[start.getPlayerRace(player)][startconditionNumber]);
> }
> 
Files ./settings.o and /home/claw/work/sc1064/sc/core/settings.o differ
diff -b -w -d ./soup.cpp /home/claw/work/sc1064/sc/core/soup.cpp
10,13c10,11
< 	for(int i=MAX_PROGRAMS;i--;)
< 		player[i]=NULL;
< 	for(int i=MAX_PLAYER;i--;)
< 		anaplayer[i]=NULL;
---
> 	memset(player, 0, MAX_PROGRAMS * sizeof(RACE*));
> 	memset(anaplayer, 0, MAX_PLAYER * sizeof(ANARACE*));
16d13
< //	gaInitialized=0;
59,61d55
< 
< 
< 	
78,82c72
< 	if(!gaInitialized)
< 	{
< 		toLog("ERROR: (SOUP::initSoup) GA not initialized.");
< 		return(0);
< 	}*/
---
> 	*/
144d133
< 			anaplayer[k]->setMaxtFitness(0);
150a140
> 
153,154c143
< 		return ((playerStart->getpFitness()>playerEnd->getpFitness())||
< 			   ((playerStart->getpFitness()==playerEnd->getpFitness())&&(playerStart->getsFitness() > playerEnd->getsFitness()))||
---
>                 return ((playerStart->getpFitness()>playerEnd->getpFitness())||((playerStart->getpFitness()==playerEnd->getpFitness())&&(playerStart->getsFitness() > playerEnd->getsFitness()))||
163c152
< 	for(int k=mapPlayerNum;k--;)
---
> 	for(unsigned int k = mapPlayerNum; k--;)
175c164
< 		for(int k=mapPlayerNum;k--;)
---
> 		for(unsigned int k = mapPlayerNum; k--;)
197,201c186
< 	if(!gaInitialized)
< 	{
< 		toLog("ERROR: (SOUP::newGeneration) GA not initialized.");
< 		return(0);
< 	}*/
---
> 	*/
230c215
< 	for(int i=groupSize;i--;)
---
> 	for(unsigned int i=groupSize;i--;)
236c221
< 		for(int k=mapPlayerNum;k--;)
---
> 		for(unsigned int k = mapPlayerNum; k--;)
275d259
< 
276a261
> 
289c274
< 		newcalc=0;
---
> 		newcalc = false;
317c302
< 					newcalc=1;
---
>                                         newcalc = true;
344,345c329
< 						  ((player[j]->getpFitness()==player[l]->getpFitness())&&(player[j]->getsFitness()>player[l]->getsFitness()))||
< 						  ((player[j]->getpFitness()==player[l]->getpFitness())&&(player[j]->getsFitness()==player[l]->getsFitness())&&(player[j]->gettFitness()>player[l]->gettFitness())) )
---
> 						  ((player[j]->getpFitness()==player[l]->getpFitness())&&(player[j]->getsFitness()>player[l]->getsFitness()))))
384c368
< 				int z=anaplayer[k]->fitnessAverage-player[i]->getpFitness();
---
> 				unsigned int z = anaplayer[k]->fitnessAverage-player[i]->getpFitness();
434d417
< 			s[k]->setMaxtFitness(anaplayer[k]->getMaxtFitness());
489,500d471
< 
< 
< void SOUP::setMapPlayerNum(const unsigned int map_player_num)
< {
< #ifdef _SCC_DEBUG
< 	if((map_player_num<1)||(map_player_num>=MAX_PLAYER)) {
< 		toLog("DEBUG: (SOUP::setMapPlayerNum): map_player_num not initialized.");return;
< 	}
< #endif
< 	mapPlayerNum = map_player_num;
< }
< 
508,509d478
< //	gaInitialized=1;
< 	ANARACE::resetStaticData();
512a482
> 	ANARACE::resetStaticData();
diff -b -w -d ./soup.hpp /home/claw/work/sc1064/sc/core/soup.hpp
41a42,51
> inline void SOUP::setMapPlayerNum(const unsigned int map_player_num)
> {
> #ifdef _SCC_DEBUG
> 	if((map_player_num < 1) || (map_player_num >= MAX_PLAYER)) {
> 		toLog("DEBUG: (SOUP::setMapPlayerNum): map_player_num not initialized.");return;
> 	}
> #endif
> 	mapPlayerNum = map_player_num;
> }
> 
Files ./soup.o and /home/claw/work/sc1064/sc/core/soup.o differ
diff -b -w -d ./startcondition.cpp /home/claw/work/sc1064/sc/core/startcondition.cpp
62,244d61
< void START_CONDITION::assignRace(const eRace start_race)
< {
< 	race = start_race;
< }
< 			
< const eRace START_CONDITION::getRace() const
< {
< 	return(race);
< }
< 
< const UNIT* START_CONDITION::getUnit(const unsigned int location) const 
< {
< #ifdef _SCC_DEBUG
< 	if(location >= MAX_LOCATIONS) {
< 		toLog("DEBUG: (START_CONDITION::getUnit): Value location out of range.");return(0);
< 	} 
< #endif
< 	return(&unit[location]);
< }
< 
< const std::string& START_CONDITION::getName() const
< {
< 	return(name);
< }
< 
< void START_CONDITION::setName(const std::string& startcondition_name)
< {
< 	name = startcondition_name;
< }
< 
< const unsigned int START_CONDITION::getHaveSupply() const
< {
< #ifdef _SCC_DEBUG
< 	if(haveSupply > MAX_SUPPLY) {
< 		toLog("DEBUG: (START_CONDITION::getHaveSupply): Value haveSupply out of range.");return(0);
< 	}
< #endif
< 	return(haveSupply);
< }
< 
< void START_CONDITION::setHaveSupply(const unsigned int start_have_supply)
< {
< #ifdef _SCC_DEBUG
< 	if(start_have_supply > MAX_SUPPLY) {
< 		toLog("DEBUG: (START_CONDITION::setHaveSupply): Value start_have_supply out of range.");return;
< 	}
< #endif
< 	haveSupply = start_have_supply;
< }
< 		
< const unsigned int START_CONDITION::getNeedSupply() const
< {
< #ifdef _SCC_DEBUG
< 	if(needSupply > MAX_SUPPLY) { // TODO
< 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value needSupply out of range.");return(0);
< 	}
< #endif
< 	return(needSupply);
< }
< 
< void START_CONDITION::setNeedSupply(const unsigned int start_need_supply)
< {
< #ifdef _SCC_DEBUG
< 	if(start_need_supply > MAX_SUPPLY) {
< 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value start_need_supply out of range.");return;
< 	}
< #endif
< 	needSupply = start_need_supply;
< }
< 
< const unsigned int START_CONDITION::getGas() const
< {
< #ifdef _SCC_DEBUG
< 	if(gas > MAX_GAS) {
< 		toLog("DEBUG: (START_CONDITION::getGas): Variable gas out of range.");return(0);
< 	}
< #endif
< 	return(gas);
< }
< 
< const unsigned int START_CONDITION::getMinerals() const
< {
< #ifdef _SCC_DEBUG
< 	if(minerals > MAX_MINERALS)
< 	{
< 		toLog("DEBUG: (START_CONDITION::getMinerals): Variable minerals out of range.");
< 		return(0);
< 	}
< #endif
< 	return(minerals);
< }
< 	
< void START_CONDITION::setMinerals(const unsigned int start_minerals)
< {
< #ifdef _SCC_DEBUG
< 	if(start_minerals > MAX_MINERALS) {
< 		toLog("DEBUG: (START_CONDITION::setMinerals): Value start_minerals out of range.");return;
< 	}
< #endif
< 	minerals = start_minerals;
< }
< 
< void START_CONDITION::setGas(const unsigned int start_gas)
< {
< #ifdef _SCC_DEBUG
< 	if(start_gas > MAX_GAS) {
< 		toLog("DEBUG: (START_CONDITION::setGas): Value start_gas out of range.");return;
< 	}
< #endif
< 	gas = start_gas;	
< }
< 
< const unsigned int START_CONDITION::getStartTime() const
< {
< #ifdef _SCC_DEBUG
< 	if(startTime >= MAX_TIME) { // TODO was wenn im Nachhinein settings.maxtime veraendert wird? 
< 		toLog("DEBUG: (START_CONDITION::getStartTime): Variable startTime out of range.");return(0);
< 	}
< #endif
< 	return(startTime);
< }
< 
< void START_CONDITION::setStartTime(const unsigned int start_time)
< {
< #ifdef _SCC_DEBUG
< 	if(start_time >= MAX_TIME) {
< 		toLog("DEBUG: (START_CONDITION::setStartTime): Value start_time out of range.");return;
< 	}
< #endif
< 	startTime = start_time;
< }
< 
< void START_CONDITION::setLocationAvailible(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
< {
< #ifdef _SCC_DEBUG
< 	if((location == 0) || (location >= MAX_LOCATIONS)) {
< 		toLog("DEBUG: (START_CONDITION::setLocationAvailible): Value location out of range.");return;
< 	}
< #endif
< 	unit[location].setAvailible(unit_type, unit_count);
< 	unit[GLOBAL].addAvailible(unit_type, unit_count);
< 	// TODO UNSAUBER!
< }
< 
< const unsigned int START_CONDITION::getLocationAvailible(const unsigned int location, const unsigned int unit_type) const
< {
< #ifdef _SCC_DEBUG
< 	if(location >= MAX_LOCATIONS) {
< 		toLog("DEBUG: (START_CONDITION::getLocationAvailible): Value location out of range.");return(0);
< 	}
< #endif
< 	return(unit[location].getAvailible(unit_type));
< }
< 
< const unsigned int START_CONDITION::getLocationTotal(const unsigned int location, const unsigned int unit_type) const
< {
< #ifdef _SCC_DEBUG
< 	if(location >= MAX_LOCATIONS) {
< 		toLog("DEBUG: (START_CONDITION::getLocationTotal): Value location out of range.");return(0);
< 	}
< #endif
< 	return(unit[location].getTotal(unit_type));
< }
< 
< 
< void START_CONDITION::setLocationTotal(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
< {
< #ifdef _SCC_DEBUG
< 	if((location == 0)||(location >= MAX_LOCATIONS)) {
< 		toLog("DEBUG: (START_CONDITION::setLocationTotal): Value location out of range.");return;
< 	}
< #endif
< 	unit[location].setTotal(unit_type, unit_count);
< 	unit[GLOBAL].addTotal(unit_type, unit_count);
< 	// TODO UNSAUBER!
< }
< 
< 
< void START_CONDITION::resetUnits()
< {
< 	for(int i=MAX_LOCATIONS;i--;)
< 		unit[i].resetData();
< }
diff -b -w -d ./startcondition.hpp /home/claw/work/sc1064/sc/core/startcondition.hpp
58a59,239
> inline void START_CONDITION::assignRace(const eRace start_race) {
> 	race = start_race;
> }
> 			
> inline const eRace START_CONDITION::getRace() const {
> 	return(race);
> }
> 
> inline const UNIT* START_CONDITION::getUnit(const unsigned int location) const 
> {
> #ifdef _SCC_DEBUG
> 	if(location >= MAX_LOCATIONS) { // TODO
> 		toLog("DEBUG: (START_CONDITION::getUnit): Value location out of range.");return(0);
> 	} 
> #endif
> 	return(&unit[location]);
> }
> 
> inline const std::string& START_CONDITION::getName() const {
> 	return(name);
> }
> 
> inline void START_CONDITION::setName(const std::string& startcondition_name) {
> 	name = startcondition_name;
> }
> 
> inline const unsigned int START_CONDITION::getHaveSupply() const 
> {
> #ifdef _SCC_DEBUG
> 	if(haveSupply > MAX_SUPPLY) {
> 		toLog("DEBUG: (START_CONDITION::getHaveSupply): Value haveSupply out of range.");return(0);
> 	}
> #endif
> 	return(haveSupply);
> }
> 
> inline void START_CONDITION::setHaveSupply(const unsigned int start_have_supply) 
> {
> #ifdef _SCC_DEBUG
> 	if(start_have_supply > MAX_SUPPLY) {
> 		toLog("DEBUG: (START_CONDITION::setHaveSupply): Value start_have_supply out of range.");return;
> 	}
> #endif
> 	haveSupply = start_have_supply;
> }
> 		
> inline const unsigned int START_CONDITION::getNeedSupply() const
> {
> #ifdef _SCC_DEBUG
> 	if(needSupply > MAX_SUPPLY) { // TODO
> 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value needSupply out of range.");return(0);
> 	}
> #endif
> 	return(needSupply);
> }
> 
> inline void START_CONDITION::setNeedSupply(const unsigned int start_need_supply)
> {
> #ifdef _SCC_DEBUG
> 	if(start_need_supply > MAX_SUPPLY) {
> 		toLog("DEBUG: (START_CONDITION::getNeedSupply): Value start_need_supply out of range.");return;
> 	}
> #endif
> 	needSupply = start_need_supply;
> }
> 
> inline const unsigned int START_CONDITION::getGas() const
> {
> #ifdef _SCC_DEBUG
> 	if(gas > MAX_GAS) {
> 		toLog("DEBUG: (START_CONDITION::getGas): Variable gas out of range.");return(0);
> 	}
> #endif
> 	return(gas);
> }
> 
> inline const unsigned int START_CONDITION::getMinerals() const
> {
> #ifdef _SCC_DEBUG
> 	if(minerals > MAX_MINERALS)
> 	{
> 		toLog("DEBUG: (START_CONDITION::getMinerals): Variable minerals out of range.");
> 		return(0);
> 	}
> #endif
> 	return(minerals);
> }
> 	
> inline void START_CONDITION::setMinerals(const unsigned int start_minerals)
> {
> #ifdef _SCC_DEBUG
> 	if(start_minerals > MAX_MINERALS) {
> 		toLog("DEBUG: (START_CONDITION::setMinerals): Value start_minerals out of range.");return;
> 	}
> #endif
> 	minerals = start_minerals;
> }
> 
> inline void START_CONDITION::setGas(const unsigned int start_gas)
> {
> #ifdef _SCC_DEBUG
> 	if(start_gas > MAX_GAS) {
> 		toLog("DEBUG: (START_CONDITION::setGas): Value start_gas out of range.");return;
> 	}
> #endif
> 	gas = start_gas;	
> }
> 
> inline const unsigned int START_CONDITION::getStartTime() const
> {
> #ifdef _SCC_DEBUG
> 	if(startTime >= MAX_TIME) { // TODO was wenn im Nachhinein settings.maxtime veraendert wird? 
> 		toLog("DEBUG: (START_CONDITION::getStartTime): Variable startTime out of range.");return(0);
> 	}
> #endif
> 	return(startTime);
> }
> 
> inline void START_CONDITION::setStartTime(const unsigned int start_time)
> {
> #ifdef _SCC_DEBUG
> 	if(start_time >= MAX_TIME) {
> 		toLog("DEBUG: (START_CONDITION::setStartTime): Value start_time out of range.");return;
> 	}
> #endif
> 	startTime = start_time;
> }
> 
> inline void START_CONDITION::setLocationAvailible(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
> {
> #ifdef _SCC_DEBUG
> 	if((location == 0) || (location >= MAX_LOCATIONS)) {
> 		toLog("DEBUG: (START_CONDITION::setLocationAvailible): Value location out of range.");return;
> 	}
> #endif
> 	unit[location].setAvailible(unit_type, unit_count);
> 	unit[GLOBAL].addAvailible(unit_type, unit_count);
> 	// TODO UNSAUBER!
> }
> 
> inline const unsigned int START_CONDITION::getLocationAvailible(const unsigned int location, const unsigned int unit_type) const
> {
> #ifdef _SCC_DEBUG
> 	if(location >= MAX_LOCATIONS) {
> 		toLog("DEBUG: (START_CONDITION::getLocationAvailible): Value location out of range.");return(0);
> 	}
> #endif
> 	return(unit[location].getAvailible(unit_type));
> }
> 
> inline const unsigned int START_CONDITION::getLocationTotal(const unsigned int location, const unsigned int unit_type) const
> {
> #ifdef _SCC_DEBUG
> 	if(location >= MAX_LOCATIONS) { // TODO
> 		toLog("DEBUG: (START_CONDITION::getLocationTotal): Value location out of range.");return(0);
> 	}
> #endif
> 	return(unit[location].getTotal(unit_type));
> }
> 
> 
> inline void START_CONDITION::setLocationTotal(const unsigned int location, const unsigned int unit_type, const unsigned int unit_count)
> {
> #ifdef _SCC_DEBUG
> 	if((location == 0)||(location >= MAX_LOCATIONS)) { // TODO
> 		toLog("DEBUG: (START_CONDITION::setLocationTotal): Value location out of range.");return;
> 	}
> #endif
> 	unit[location].setTotal(unit_type, unit_count);
> 	unit[GLOBAL].addTotal(unit_type, unit_count);
> 	// TODO UNSAUBER!
> }
> 
> 
> inline void START_CONDITION::resetUnits()
> {
> 	for(int i=MAX_LOCATIONS;i--;)
> 		unit[i].resetData();
> }
> 
> 
Files ./startcondition.o and /home/claw/work/sc1064/sc/core/startcondition.o differ
diff -b -w -d ./start.cpp /home/claw/work/sc1064/sc/core/start.cpp
35c35
< 	int maxp=tmpmap->getMaxPlayer();
---
> 	unsigned int maxp = tmpmap->getMaxPlayer();
37c37
< 	for(int j=MAX_LOCATIONS;j--;)
---
> 	for(int j = tmpmap->getMaxLocations();j--;)
48c48,49
< 		for(int j=1;j<MAX_LOCATIONS;j++)
---
> 		// TODO bei mehreren Spielern!
> 		for(unsigned int j=1;j<tmpmap->getMaxLocations();j++)
diff -b -w -d ./start.hpp /home/claw/work/sc1064/sc/core/start.hpp
138c138
< 	if((start_position < 1) || (start_position >= MAX_LOCATIONS)) {
---
> 	if((start_position < 1) || (start_position >= tmpmap->getMaxLocations())) {
Files ./start.o and /home/claw/work/sc1064/sc/core/start.o differ
Only in /home/claw/work/sc1064/sc/core/: statistics.cpp
Only in /home/claw/work/sc1064/sc/core/: statistics.hpp
Only in /home/claw/work/sc1064/sc/core/: statistics.o
Files ./unit.o and /home/claw/work/sc1064/sc/core/unit.o differ
